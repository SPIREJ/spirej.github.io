<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>等风来，等花开❀~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-17T17:19:37.229Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ぱゐずだιονε゜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS多线程详解</title>
    <link href="http://yoursite.com/2018/05/18/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/18/iOS多线程详解/</id>
    <published>2018-05-17T17:18:30.000Z</published>
    <updated>2018-05-17T17:19:37.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><blockquote><p>本文用来介绍 iOS 多线程中 GCD的相关知识以及使用方法。通过本文，您将了解到：</p><ol><li>GCD 简介</li><li>GCD 任务和队列</li><li>GCD 的使用步骤</li><li>GCD 的基本使用（6种不同组合区别）</li><li>GCD 线程间的通信</li><li>GCD 的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore</li></ol></blockquote><h3 id="1-GCD简介"><a href="#1-GCD简介" class="headerlink" title="1. GCD简介"></a>1. GCD简介</h3><p>什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念</p><blockquote><p>引自百度百科<br>Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p></blockquote><p><strong>为什么要用 GCD 呢？</strong></p><p>因为 GCD 有很多好处啊，具体如下：</p><ul><li>GCD 可用于多核的并行运算</li><li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li><li>既然 GCD 有这么多的好处，那么下面我们就来系统的学习一下 GCD 的使用方法。</li></ul><h3 id="2-GCD任务和队列"><a href="#2-GCD任务和队列" class="headerlink" title="2. GCD任务和队列"></a>2. GCD任务和队列</h3><p>学习 GCD 之前，先来了解 GCD 中两个核心概念：<strong>任务</strong>和<strong>队列</strong>。</p><p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：<strong>同步执行（sync）</strong>和<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力</strong>。</p><ul><li><strong>同步执行（sync）</strong>：<ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul></li><li><strong>异步执行（async）</strong>：<ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul></li></ul><p>举个简单例子：你要打电话给小明和小白。<br>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。<br>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p><blockquote><p>注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p></blockquote><p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：<br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-DispatchQueue.png" alt="image"><br>在 GCD 中有两种队列：<strong>串行队列和并发队列</strong>。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：<strong>执行顺序不同，以及开启线程数不同</strong>。</p><ul><li><strong>串行队列（Serial Dispatch Queue）</strong>：<ul><li>每次只有一个任务被执行。让任务一个接着一个地执行。一个任务执行完毕后，再执行下一个任务。</li><li>只开启一个新线程（或者不开启新线程，在当前线程执行任务）。</li></ul></li><li><strong>并发队列（Concurrent Dispatch Queue）</strong>：<ul><li>可以让多个任务并发（同时）执行。</li><li>可以开启多个线程，并且同时执行任务。<blockquote><p>注意：并发队列的并发功能只有在异步（dispatch_async）函数下才有效。</p></blockquote></li></ul></li></ul><p>两者具体区别如下两图所示。<br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-SerialDispatchQueue.png" alt="image"><br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-ConcurrentDispatchQueue.png" alt="image"></p><h3 id="3-GCD的使用步骤"><a href="#3-GCD的使用步骤" class="headerlink" title="3. GCD的使用步骤"></a>3. GCD的使用步骤</h3><p>GCD 的使用步骤其实很简单，只有两步。</p><blockquote><ol><li>创建一个队列（串行队列或并发队列）</li><li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li></ol></blockquote><p>下边来看看队列的创建方法/获取方法，以及任务的创建方法。</p><h4 id="3-1-队列的创建方法-获取方法"><a href="#3-1-队列的创建方法-获取方法" class="headerlink" title="3.1 队列的创建方法/获取方法"></a>3.1 队列的创建方法/获取方法</h4><p>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列的创建方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><ul><li>对于串行队列，GCD 提供了的一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。<ul><li>所有放在主队列中的任务，都会放到主线程中执行。</li><li>可使用<code>dispatch_get_main_queue()</code>获得主队列。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主队列的获取方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><ul><li>对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue）。<ul><li>可以使用dispatch_get_global_queue来获取。需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局并发队列的获取方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-任务的创建方法"><a href="#3-2-任务的创建方法" class="headerlink" title="3.2 任务的创建方法"></a>3.2 任务的创建方法</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法<code>dispatch_async</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步执行任务创建方法</span></span><br><span class="line"><span class="selector-tag">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放同步执行任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 异步执行任务创建方法</span></span><br><span class="line"><span class="selector-tag">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放异步执行任务代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p><blockquote><ol><li>同步执行 + 并发队列</li><li>异步执行 + 并发队列</li><li>同步执行 + 串行队列</li><li>异步执行 + 串行队列</li></ol></blockquote><p>实际上，刚才还说了两种特殊队列：<strong>全局并发队列、主队列</strong>。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p><blockquote><ol><li>同步执行 + 主队列</li><li>异步执行 + 主队列</li></ol></blockquote><p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。</p><table><thead><tr><th>区别</th><th>并发队列</th><th>串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步(sync)</td><td>没有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td><td>主线程调用：死锁卡住不执行 其他线程调用：没有开启新线程，串行执行任务</td></tr><tr><td>异步(async)</td><td>有开启新线程，并发执行任务</td><td>有开启新线程(1条)，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr></tbody></table><h3 id="4-GCD的基本使用"><a href="#4-GCD的基本使用" class="headerlink" title="4. GCD的基本使用"></a>4. GCD的基本使用</h3><p>先来讲讲并发队列的两种执行方式。</p><h4 id="4-1-同步执行-并发队列"><a href="#4-1-同步执行-并发队列" class="headerlink" title="4.1 同步执行 + 并发队列"></a>4.1 同步执行 + 并发队列</h4><ul><li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">55.095932</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">55.096086</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] syncConcurrent—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">57.097589</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34:59.099100</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35</span>:<span class="number">01.099843</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:03.101171</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:05.101750</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:07.102414</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:07.102575</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] syncConcurrent—end</span><br></pre></td></tr></table></figure><p>从同步执行 + 并发队列中可看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（同步执行不具备开启新线程的能力）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行的（同步任务需要等待队列的任务执行结束）。</li><li>任务按顺序执行的。按顺序执行的原因：虽然并发队列可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（同步任务需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li></ul><h4 id="4-2-异步执行-并发队列"><a href="#4-2-异步执行-并发队列" class="headerlink" title="4.2 异步执行 + 并发队列"></a>4.2 异步执行 + 并发队列</h4><ul><li>可以开启多个线程，任务交替（同时）执行</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：可以开启多个线程，任务交替（同时）执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769269</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769496</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] asyncConcurrent—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769725</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] asyncConcurrent—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774442</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005566</span>] <span class="number">2</span>—&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774440</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005567</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774440</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005565</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779286</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005567</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779302</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005565</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779286</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005566</span>] <span class="number">2</span>—&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在异步执行 + 并发队列中可以看出：</p><ul><li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，可以继续执行任务）。</li></ul><p><strong>接下来再来讲讲串行队列的两种执行方式</strong>。</p><h5 id="4-3-同步执行-串行队列"><a href="#4-3-同步执行-串行队列" class="headerlink" title="4.3 同步执行 + 串行队列"></a>4.3 同步执行 + 串行队列</h5><ul><li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">37.876811</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">37.876998</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] syncSerial—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">39.878316</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">41.879829</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">43.880660</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">45.881265</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">47.882257</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">49.883008</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39:49.883253</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] syncSerial—end</span><br></pre></td></tr></table></figure><p>在同步执行 + 串行队列可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行不具备开启新线程的能力）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><h4 id="4-4-异步执行-串行队列"><a href="#4-4-异步执行-串行队列" class="headerlink" title="4.4 异步执行 + 串行队列"></a>4.4 异步执行 + 串行队列</h4><ul><li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">17.029999</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:17.030212</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] asyncSerial—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">17.030364</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] asyncSerial—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">19.035379</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:21.037140</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:23.042220</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">25.042971</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">27.047690</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">3</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">29.052327</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">3</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在异步执行 + 串行队列可以看到：</p><ul><li>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><p>下边讲讲刚才我们提到过的特殊队列：<strong>主队列</strong>。</p><ul><li>主队列：GCD自带的一种特殊的串行队列<ul><li>所有放在主队列中的任务，都会放到主线程中执行</li><li>可使用dispatch_get_main_queue()获得主队列</li></ul></li></ul><p><strong>我们再来看看主队列的两种组合方式。</strong></p><h4 id="4-5-同步执行-主队列"><a href="#4-5-同步执行-主队列" class="headerlink" title="4.5 同步执行 + 主队列"></a>4.5 同步执行 + 主队列</h4><ul><li>同步执行 + 主队列在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</li></ul><h5 id="4-5-1-在主线程中调用同步执行-主队列"><a href="#4-5-1-在主线程中调用同步执行-主队列" class="headerlink" title="4.5.1 在主线程中调用同步执行 + 主队列"></a>4.5.1 在主线程中调用同步执行 + 主队列</h5><ul><li>互相等待卡住不可行</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点(主线程调用)：互等卡主不执行。</span></span><br><span class="line"><span class="comment"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncMain &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">36.842892</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20041</span>:<span class="number">5030982</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">36.843050</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20041</span>:<span class="number">5030982</span>] syncMain—begin</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>在<code>同步执行 + 主队列</code>可以惊奇的发现：</p><ul><li>在主线程中使用<code>同步执行 + 主队列</code>，追加到主线程的任务1、任务2、任务3都不再执行了，而且<code>syncMain---end</code>也没有打印，在XCode 9上还会报崩溃。这是为什么呢？</li></ul><p>这是因为我们在主线程中执行<code>syncMain</code>方法，相当于把<code>syncMain</code>任务放到了主线程的队列中。而<code>同步执行</code>会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把<code>任务1</code>追加到主队列中，<code>任务1</code>就在等待主线程处理完<code>syncMain</code>任务。而<code>syncMain</code>任务需要等待<code>任务1</code>执行完毕，才能接着执行。</p><p>那么，现在的情况就是<code>syncMain</code>任务和<code>任务1</code>都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p><p><strong>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</strong></p><h5 id="4-5-2-在其他线程中调用同步执行-主队列"><a href="#4-5-2-在其他线程中调用同步执行-主队列" class="headerlink" title="4.5.2 在其他线程中调用同步执行 + 主队列"></a>4.5.2 在其他线程中调用同步执行 + 主队列</h5><ul><li>不会开启新线程，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行 selector 任务</span></span><br><span class="line">[NSThread <span class="string">detachNewThreadSelector:</span><span class="meta">@selector</span>(syncMain) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">19.377321</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] currentThread—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">19.377494</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] syncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">21.384716</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">23.386091</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">25.387687</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">27.388648</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">29.390459</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">31.391965</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">31.392513</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] syncMain—end</span><br></pre></td></tr></table></figure><p>在其他线程中使用<code>同步执行 + 主队列</code>可看到：</p><ul><li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><p><strong>为什么现在就不会卡住了呢？</strong></p><p>因为<code>syncMain</code> 任务放到了其他线程里，而<code>任务1</code>、<code>任务2</code>、<code>任务3</code>都在追加到主队列中，这三个任务都会在主线程中执行。<code>syncMain</code>任务在其他线程中执行到追加<code>任务1</code>到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的<code>任务1</code>，等<code>任务1</code>执行完毕，再接着执行<code>任务2</code>、<code>任务3</code>。所以这里不会卡住线程。</p><h3 id="4-6-异步执行-主队列"><a href="#4-6-异步执行-主队列" class="headerlink" title="4.6 异步执行 + 主队列"></a>4.6 异步执行 + 主队列</h3><ul><li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncMain &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.981505</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.981935</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] asyncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.982352</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] asyncMain—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">51.991096</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">53.991959</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">55.992937</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">57.993649</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">59.994928</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">01.995589</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>在<code>异步执行 + 主队列</code>可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（因为主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。<br>弄懂了难理解、绕来绕去的<strong>队列+任务</strong>之后，我们来学习一个简单的东西：<strong>5. GCD 线程间的通信。</strong></li></ul><h3 id="5-GCD-线程间的通信"><a href="#5-GCD-线程间的通信" class="headerlink" title="5. GCD 线程间的通信"></a>5. GCD 线程间的通信</h3><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)communication &#123;</span><br><span class="line">    <span class="comment">// 获取全局并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">// 获取主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue(); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 异步追加任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            <span class="comment">// 追加在主线程中执行的任务</span></span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">03.462394</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5053282</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">05.465912</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5053282</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">07.466657</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5052953</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li></ul><h3 id="6-GCD的其他方法"><a href="#6-GCD的其他方法" class="headerlink" title="6. GCD的其他方法"></a>6. GCD的其他方法</h3><h4 id="6-1-GCD-栅栏方法：dispatch-barrier-async"><a href="#6-1-GCD-栅栏方法：dispatch-barrier-async" class="headerlink" title="6.1 GCD 栅栏方法：dispatch_barrier_async"></a>6.1 GCD 栅栏方法：dispatch_barrier_async</h4><ul><li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于<code>栅栏</code>一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到<code>dispatch_barrier_async</code>方法在两个操作组间形成栅栏。</li></ul><p><code>dispatch_barrier_async</code>函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在<code>dispatch_barrier_async</code>函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-barrier.png" alt="image"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栅栏方法 dispatch_barrier_async</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)barrier &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务 barrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"barrier---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);<span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务4</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"4---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">18.297745</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">1</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">18.297745</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48:20.301139</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">1</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48:20.301139</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">22.306290</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] barrier—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">24.311655</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] barrier—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">26.316943</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">4</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">26.316956</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">28.320660</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">4</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">28.320649</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在<code>dispatch_barrier_async</code>执行结果中可以看出：</p><ul><li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li></ul><h4 id="6-2-GCD-延时执行方法：dispatch-after"><a href="#6-2-GCD-延时执行方法：dispatch-after" class="headerlink" title="6.2 GCD 延时执行方法：dispatch_after"></a>6.2 GCD 延时执行方法：dispatch_after</h4><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的<code>dispatch_after</code>函数来实现。</p><p><strong>需要注意的是</strong>:<code>dispatch_after</code>函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code>函数是很有效的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时执行方法 dispatch_after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)after &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 2.0秒后异步追加任务代码到主队列，并开始执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"after---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">08.713784</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">08.713962</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] asyncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">10.714283</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] after—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看出：在打印 <code>asyncMain---begin</code> 之后大约 <strong>2.0</strong> 秒的时间，打印了 <code>after---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}</code></p><p>感谢：<br>(<a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">https://bujige.net/blog/iOS-Complete-learning-GCD.html</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文用来介绍 iOS 多线程中 GCD的相关知识以及使用方法。通过本文，您将了解到：&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="iOS开发" scheme="http://yoursite.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="GCD" scheme="http://yoursite.com/tags/GCD/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>追忆</title>
    <link href="http://yoursite.com/2017/06/09/%E8%BF%BD%E5%BF%86/"/>
    <id>http://yoursite.com/2017/06/09/追忆/</id>
    <published>2017-06-09T09:52:21.000Z</published>
    <updated>2017-06-09T10:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>突然听到一首歌<br>想起是你曾经很喜欢的歌<br>“你说过牵了手就算约定”<br>“但亲爱的那并不是爱情”</p><a id="more"></a><p>虽然这么多年过去了<br>虽然好几年没联系了<br>但关于你的一切都在遇到熟悉的东西时不自然的想起</p><p>把你送我的东西整理起来<br>当年没勇气带在身边<br>但后来朋友告诉我把东西弄丢了<br>我的内心几乎是崩溃的<br>仿佛感觉我的青春被焚烧了一般<br>感觉自己永远都不会再拥有青春</p><p>现在<br>我们成了永远的陌路人<br>但我们一起走过的青春岁月<br>我会一直记得<br>那是生命中最美好的部分</p><p>其实<br>我一直想告诉你<br>男人是需要成长的<br>如果当年我有你那样成熟的高度<br>且不那么懦弱的面对一些现实问题<br>也许…<br>罢了…<br>如果就是如果<br>也许也只能是也许<br>现在想起那句一个男人在最无用的时候<br>遇到想要保护一生的女人<br>奈何奈何</p><p>现在我成长了<br>我不在渴求那样的爱情<br>我也从不觉得年近而立就得恋爱结婚<br>一个人的日子有点孤单<br>但也自在快乐</p><p>现在我没有你的消息<br>你不需要我的消息<br>但我永远祝福你过的比我好<br>祝福你一定要幸福</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=36841953&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然听到一首歌&lt;br&gt;想起是你曾经很喜欢的歌&lt;br&gt;“你说过牵了手就算约定”&lt;br&gt;“但亲爱的那并不是爱情”&lt;/p&gt;
    
    </summary>
    
      <category term="随笔~" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>swift入门项目实战之遇坑出坑</title>
    <link href="http://yoursite.com/2017/05/27/swift%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E9%81%87%E5%9D%91%E5%87%BA%E5%9D%91/"/>
    <id>http://yoursite.com/2017/05/27/swift入门项目实战之遇坑出坑/</id>
    <published>2017-05-27T07:10:22.000Z</published>
    <updated>2017-05-27T07:16:51.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>初学swift，找来一个项目拿来练手。下面是几个效果图-&gt;<br>项目源码☞<a href="https://github.com/SPIREJ/XSLC_Swift" target="_blank" rel="noopener">传送门https://github.com/SPIREJ/XSLC_Swift</a></li></ul><a id="more"></a><ul><li>首页：<ul><li>首页主要由banner、collectionView、tableView 组成</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-8dd445ec88ad80c9.gif?imageMogr2/auto-orient/strip" alt="首页"></p><ul><li>理财页<ul><li>理财列表页、计划详情页以及键盘等</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-54ba71800d8ad53a.gif?imageMogr2/auto-orient/strip" alt="理财"></p><ul><li>我的页<ul><li>collectionView 、webView</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-dc48d734c996f772.gif?imageMogr2/auto-orient/strip" alt="我的"></p><ul><li>初学者，UI就这么多，就说说遇到的两个坑吧~<h5 id="第一个坑，使用pod建立工程时终端出错"><a href="#第一个坑，使用pod建立工程时终端出错" class="headerlink" title="第一个坑，使用pod建立工程时终端出错"></a>第一个坑，使用pod建立工程时终端出错</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod[!] Unable <span class="built_in">to</span> <span class="built_in">add</span> <span class="keyword">a</span> source <span class="keyword">with</span> url `<span class="keyword">https</span>://github.com/CocoaPods/Specs.git` named `master`.You can</span><br><span class="line"> <span class="keyword">try</span> adding <span class="keyword">it</span> manually <span class="keyword">in</span> `~/.cocoapods/repos` <span class="keyword">or</span> via `pod repo <span class="built_in">add</span>`.</span><br></pre></td></tr></table></figure></li></ul><p>解决方案：终端输入以下命令<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add <span class="keyword">master</span> <span class="title">https</span>://github.com/CocoaPods/Specs.git</span><br></pre></td></tr></table></figure></p><p>然后提示执行<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="built_in">setup</span></span><br></pre></td></tr></table></figure></p><p>如果出现<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod[!] The `master` repo is <span class="literal">not</span> <span class="literal">a</span> git repo.</span><br></pre></td></tr></table></figure></p><p>进入/users/你的用户名/.cocoapods/repos，删除master文件夹然后执行，如我这么进入<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.cocoapods/repos/</span></span><br></pre></td></tr></table></figure></p><p>master文件夹是个目录，删除时需要连下面的分支一起删掉<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~<span class="regexp">/.cocoapods/</span>repos<span class="regexp">/master</span></span><br></pre></td></tr></table></figure></p><p>删除master之后，再<code>pod setup</code>,之后配置好你的<code>Podfile</code>,最后<code>pod install</code>就成功的建立了 同名的<code>.xcworkspace</code>工程了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pod setup</span><br><span class="line"><span class="meta">#</span><span class="bash">先 <span class="built_in">cd</span> 到你工程的目录</span></span><br><span class="line">pod init</span><br><span class="line">open -a Xcode Podfile</span><br><span class="line"><span class="meta">#</span><span class="bash">添加你需要的三方库</span></span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p><ul><li>还有以下情况：<br>如果是安装多个Xcdoe，还需要选择Xcode的路径,后面是你自己的Xcode路径，显示Xcode包内容可查看<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sudo</span> xcode-<span class="keyword">select </span>-<span class="keyword">switch </span>/Applications/Xcode.app/</span><br></pre></td></tr></table></figure></li></ul><p>在终端里输入下方命令可以知道Xcode的路径：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span> -p</span><br></pre></td></tr></table></figure></p><h5 id="第二个坑，加载基于XIB创建的自定义控件时报错"><a href="#第二个坑，加载基于XIB创建的自定义控件时报错" class="headerlink" title="第二个坑，加载基于XIB创建的自定义控件时报错"></a>第二个坑，加载基于XIB创建的自定义控件时报错</h5><ul><li><p>我像写OC的基于XIB自定义控件一样,创建一个基于<code>UIView</code>的新类<code>XSCustomView</code><br><img src="http://upload-images.jianshu.io/upload_images/1276164-1b14c0c6d09230a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建基于UIView的新类XSCustomView"></p></li><li><p>创建一个同名的<code>XIB</code>文件<br><img src="http://upload-images.jianshu.io/upload_images/1276164-5cf6d8adcca145fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建一个同名的XIB文件"></p></li><li><p>像OC一样给文件指定类<br><img src="http://upload-images.jianshu.io/upload_images/1276164-c8a1c91da6af44f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="像OC一样给文件连线"></p></li><li><p>然后加载View就会出错</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="keyword">error</span>: init(coder:) has not been implemented: <span class="keyword">file</span> </span><br><span class="line">/路径/XXX.swift, <span class="keyword">line</span> 43</span><br><span class="line">(lldb)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 解决办法，查了好久资料，找到解决办法</span><br><span class="line">swift指定类与OC略有不同，swift需要的是<span class="symbol">`File'</span>s Owner`归属于咱们定义的哪个类,而下面的<span class="keyword">View</span>是不需要指定类的</span><br><span class="line">![解决问题](http:<span class="comment">//upload-images.jianshu.io/upload_images/1276164-f09189b3807fa34b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">- 最后咱们从XIB加载<span class="keyword">View</span>即可，如在custom.swift文件里有如下代码</span><br></pre></td></tr></table></figure></li></ul><p>class XSCustomView: UIView {</p><pre><code>var contentView:UIView!override func awakeFromNib() {    super.awakeFromNib()}override init(frame: CGRect) {    super.init(frame: frame)    contentView = loadFromNib()    addSubview(contentView)}func loadFromNib() -&gt; UIView {    return Bundle.main.loadNibNamed(&quot;XSCustomView&quot;, owner: nil, options: nil)?.first as! UIView}override func layoutSubviews() {    contentView.frame = bounds}required init?(coder aDecoder: NSCoder) {    super.init(coder: aDecoder)    fatalError(&quot;init(coder:) has not been implemented&quot;)}</code></pre><p>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;初学swift，找来一个项目拿来练手。下面是几个效果图-&amp;gt;&lt;br&gt;项目源码☞&lt;a href=&quot;https://github.com/SPIREJ/XSLC_Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门https://github.com/SPIREJ/XSLC_Swift&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何在swift中实现oc中的分类</title>
    <link href="http://yoursite.com/2017/05/22/%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E5%AE%9E%E7%8E%B0oc%E4%B8%AD%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/05/22/如何在swift中实现oc中的分类/</id>
    <published>2017-05-22T09:02:24.000Z</published>
    <updated>2017-05-22T09:06:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>在oc中为了增强已有类的功能，我们经常使用<code>分类</code>。使用分类，我们可以在不破坏原有类的结构的前提下，对原有类进行模块化的扩展。</p><p>但是在swift中没有分类这种写法了。相对应的是swift中只有扩展(<code>Extensions</code>)。</p><p>下面是swift中扩展(<code>Extensions</code>)的说明:<br>扩展就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（<code>functionality</code>）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（<code>categories</code>）类似。（不过与 Objective-C 不同的是，Swift 的扩展没有名字。）<br><a id="more"></a></p><h4 id="2-对UIView的扩展"><a href="#2-对UIView的扩展" class="headerlink" title="2.对UIView的扩展"></a>2.对UIView的扩展</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">extension UIView &#123;</span><br><span class="line">    <span class="comment">// .x</span></span><br><span class="line">    public <span class="selector-tag">var</span> x: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.x</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.origin</span><span class="selector-class">.x</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .y</span></span><br><span class="line">    public <span class="selector-tag">var</span> y: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.y</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.origin</span><span class="selector-class">.y</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .maxX</span></span><br><span class="line">    public <span class="selector-tag">var</span> maxX: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.maxX</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .maxY</span></span><br><span class="line">    public <span class="selector-tag">var</span> maxY: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.maxY</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .centerX</span></span><br><span class="line">    public <span class="selector-tag">var</span> centerX: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.center</span><span class="selector-class">.x</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self<span class="selector-class">.center</span> = CGPoint(x: newValue, y: self<span class="selector-class">.center</span><span class="selector-class">.y</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .centerY</span></span><br><span class="line">    public <span class="selector-tag">var</span> centerY: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.center</span><span class="selector-class">.y</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self<span class="selector-class">.center</span> = CGPoint(x: self<span class="selector-class">.center</span><span class="selector-class">.x</span>, y: newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .width</span></span><br><span class="line">    public <span class="selector-tag">var</span> <span class="attribute">width</span>: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.width</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.size</span><span class="selector-class">.width</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .height</span></span><br><span class="line">    public <span class="selector-tag">var</span> <span class="attribute">height</span>: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.height</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.size</span><span class="selector-class">.height</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="selector-tag">label</span> = UILabel()</span><br><span class="line">        <span class="selector-tag">label</span>.x</span><br><span class="line">        <span class="selector-tag">label</span>.<span class="attribute">width</span></span><br><span class="line">        <span class="selector-tag">label</span>.centerX</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h4 id="3-对UIColor的扩展"><a href="#3-对UIColor的扩展" class="headerlink" title="3.对UIColor的扩展"></a>3.对UIColor的扩展</h4><p>十六进制颜色转换为rgb<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">colorWithHex</span><span class="params">(rgb:Int, alpha: CGFloat)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>(red: ((<span class="type">CGFloat</span>)((rgb &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span>, green: ((<span class="type">CGFloat</span>)((rgb &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span>, blue: ((<span class="type">CGFloat</span>)(rgb &amp; <span class="number">0xFF</span>)) / <span class="number">255.0</span>, alpha: alpha)        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">UIColor</span><span class="selector-class">.clear</span><span class="selector-class">.colorWithHex</span>(<span class="selector-tag">rgb</span>: 0<span class="selector-tag">x2588dd</span>, <span class="selector-tag">alpha</span>: 1<span class="selector-class">.0</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h4&gt;&lt;p&gt;在oc中为了增强已有类的功能，我们经常使用&lt;code&gt;分类&lt;/code&gt;。使用分类，我们可以在不破坏原有类的结构的前提下，对原有类进行模块化的扩展。&lt;/p&gt;
&lt;p&gt;但是在swift中没有分类这种写法了。相对应的是swift中只有扩展(&lt;code&gt;Extensions&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;下面是swift中扩展(&lt;code&gt;Extensions&lt;/code&gt;)的说明:&lt;br&gt;扩展就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（&lt;code&gt;functionality&lt;/code&gt;）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（&lt;code&gt;categories&lt;/code&gt;）类似。（不过与 Objective-C 不同的是，Swift 的扩展没有名字。）&lt;br&gt;
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>归期不遇2</title>
    <link href="http://yoursite.com/2017/04/06/%E5%BD%92%E6%9C%9F%E4%B8%8D%E9%81%872/"/>
    <id>http://yoursite.com/2017/04/06/归期不遇2/</id>
    <published>2017-04-06T09:06:20.000Z</published>
    <updated>2017-04-06T09:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>只想先把这首歌放在这~<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=186811&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只想先把这首歌放在这~&lt;br&gt;
    
    </summary>
    
      <category term="随笔~" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>归期不遇</title>
    <link href="http://yoursite.com/2017/03/20/%E5%BD%92%E6%9C%9F%E4%B8%8D%E9%81%87/"/>
    <id>http://yoursite.com/2017/03/20/归期不遇/</id>
    <published>2017-03-20T14:46:40.000Z</published>
    <updated>2017-03-27T02:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="临时出发"><a href="#临时出发" class="headerlink" title="临时出发"></a>临时出发</h4><p>此刻我坐在从北京开往西安的火车上，由于临时出发没买到卧铺只有硬座将就一下，说“将就”可能对我来说还太牵强了，想起以前站过的火车，想起当年逃票的光辉历史，想起为了省点钱不买卧铺的日子，想起去武汉站13小时的信念……此刻，我觉得人活着还是不能缺了信念的。</p><a id="more"></a><h4 id="信念是什么？"><a href="#信念是什么？" class="headerlink" title="信念是什么？"></a>信念是什么？</h4><p>但是，关于信念到底是一种什么东西我又摸不清的，可能在我这就是一个你真心爱的人，一个你觉得舒适的城，一份你不讨厌的工作，一个可以实现的目标或者是你应尽的义务，比如作为子女应该像父母无私无怨养育你一样亲近父母，善待朋友，真诚待人不虚伪不造作。一个人真正有信念的时候，那时候他是强大的，拥有强大的内心力量和精神力量。</p><h4 id="向左向右？"><a href="#向左向右？" class="headerlink" title="向左向右？"></a>向左向右？</h4><p>有朋友面临毕业再为工作犯愁，大多数人都是这么走过来的，我觉得毕业的时候分几类人，其他的外界条件就都不考虑了，一类人完全明确自己想要做什么不担心做不好，一类人想做这个也想做那个但是担心自己做不做得好，还有一类人不知道自己想要做什么也觉得自己做不好。很不幸当年我就是属于最后一类，后来我发现大多数人毕业的时候都有焦虑症，我把这统称为“毕业综合症”。这绝对不是病，我们要离开一个熟悉的环境熟悉的人去探知不确定的未来，有焦虑有排斥有不舍，这种不舍在将来的几年内会更浓烈呢。总之，再没开始探险之前，未知的前方总是充满传奇的色彩和迷样的精彩，所以在向左还是向右的十字路口，不要害怕迈出哪一步是错误的还是正确的，因为不管是向左还是向右，最终都会在一个路口会和，迎来你想要的生活。</p><h4 id="曾很潇洒"><a href="#曾很潇洒" class="headerlink" title="曾很潇洒"></a>曾很潇洒</h4><p>和朋友聊到毕业时的情景，又想到去年另一位朋友告诉我 当年我说“那不是我想要的生活”，然后毅然决然就北漂了很帅气，觉得我是个很有主见的人。时隔两年听到别人这么赞美我很是高兴，没想到我也曾如此潇洒过。不可否认，虽然是面相长得年轻了点，但小时候的经历，二年级就自己报名以及一路走来坎坎坷坷的我向来是知道如何生存，如何独立的。说实话我并不是一个有很多正能力的人，也偶尔（可能是经常）负能量爆棚，所以我才一直积极乐观的生活，也害怕给身边的人带去负能量，我一直相信着自己，经历那么多不是被打败的，而是真正的强大起来。我相信人生没有如果只有后果和结果，我从不后悔自己做的每个决定和每件事。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>现在不止春节的时候父母才会讲我的终生大事了，已经成为每次通话的不可少话题了，好像无论聊什么都能聊到这的样子，每次大概是这样“都二十六七的人了，还不打算说媳妇儿…”。讲真，一个人的生活我也过了好多年了，谁不想找一个爱的人在一起互相慰藉，然而人生总是有很多不如意，比如在你不懂爱的年纪遇到爱你的人，不懂爱的年纪遇到你爱的，懂爱的年纪遇到你爱的不爱你的，懂爱的年纪遇不到你爱的也遇不到爱你的，最美好的年纪没有能力保护最想要保护的，有能力的时候已经淡然。父母总认为自己的孩子是最好的，也认为现在年轻人那么多，然而他们并不知其实现在人与人之间的交集早已经不如他们那个年代了，而且对于我这类人来说，喜欢一个人是多么的不容易的一件事。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someone == <span class="literal">I</span> loved) &#123;</span><br><span class="line"><span class="keyword">do</span> everything;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="literal">I</span> would like to sleeping alone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能这就是所谓的以前喜欢一个人，现在喜欢一个人吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;临时出发&quot;&gt;&lt;a href=&quot;#临时出发&quot; class=&quot;headerlink&quot; title=&quot;临时出发&quot;&gt;&lt;/a&gt;临时出发&lt;/h4&gt;&lt;p&gt;此刻我坐在从北京开往西安的火车上，由于临时出发没买到卧铺只有硬座将就一下，说“将就”可能对我来说还太牵强了，想起以前站过的火车，想起当年逃票的光辉历史，想起为了省点钱不买卧铺的日子，想起去武汉站13小时的信念……此刻，我觉得人活着还是不能缺了信念的。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔~" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>使用CAShapeLayer &amp; UIBezierPath画图</title>
    <link href="http://yoursite.com/2017/02/24/%E4%BD%BF%E7%94%A8CAShapeLayer&amp;UIBezierPath%E7%94%BB%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/02/24/使用CAShapeLayer&amp;UIBezierPath画图/</id>
    <published>2017-02-24T03:14:10.000Z</published>
    <updated>2017-02-27T09:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要从以下几个方面来写的一点东西：</p><ul><li>线段</li><li>曲线</li><li>动画</li><li>简单的柱状图</li><li>简单的折线图<a id="more"></a></li></ul></blockquote><h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-8c6af273e49d1835.gif?imageMogr2/auto-orient/strip" alt="线段"></p><ul><li>单线段<br>两点确定一条直线，给贝塞尔曲线一个起始点<code>moveToPoint</code>再添加一条线的终点<code>addLineToPoint</code>，这样就确定了一条直线。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLine &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1024</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">524</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"直线"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *line = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    line.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    line.strokeColor = [UIColor <span class="keyword">orangeColor].CGColor;</span></span><br><span class="line"><span class="keyword"> </span>   line.fillColor = nil<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:line];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(100, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    line.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>多线段<br>前面线段的终点是后面线段的起点。给一个起点<code>moveToPoint</code>，然后想添加几条线就给几个线的终点<code>addLineToPoint</code>。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawDoubleLine &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1025</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">525</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"折线"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *line = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    line.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    line.strokeColor = [UIColor <span class="keyword">orangeColor].CGColor;</span></span><br><span class="line"><span class="keyword"> </span>   line.fillColor = nil<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:line];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(100, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">100</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(250, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    line.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>闭合多边形<br>也是多线段连起来的，只不过最后一条线的终点为第一条线段的起点。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawTriangle &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1026</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">526</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"闭合多边形"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *triangle = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    triangle.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    triangle.strokeColor = [UIColor redColor].CGColor<span class="comment">;</span></span><br><span class="line">    triangle.fillColor = [UIColor clearColor].CGColor<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:triangle];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0-100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0+100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    triangle.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>线端点样式<br>CAShapeLayer的<code>lineCap</code>属性决定线端点样式，可选样式<code>kCALineCapButt（默认）</code>，<code>kCALineCapRound（圆角）</code>，<code>kCALineCapSquare（平角）</code>。默认为<code>kCALineCapButt</code>也是平角。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3950101908ae9c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线端点样式示例"></p></li><li><p>线段拐点处样式<br>CAShapeLayer的<code>lineJoin</code>属性决定线端点样式，可选样式<code>kCALineJoinMiter（尖角）</code>，<code>kCALineJoinRound（圆角）</code>，<code>kCALineJoinBevel（平角）</code>。默认为<code>kCALineJoinMiter</code>。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-ae5278976c113bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拐角样式示例"></p></li><li><p>虚线</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *lineDashPattern;</span><br></pre></td></tr></table></figure><p>CAShapeLayer的<code>lineDashPattern</code>属性决定你画出一条什么样的虚线，这个属性返回一组<code>NSNumber</code>类型的数组，其实就是<code>实虚相交</code>来表示你的虚线，数组的长度由你决定（当然最好不要第一轮实虚相加超过线段长度）。比如<code>line.lineDashPattern = @[@10,@5,@2,@8];</code>就是表示每轮都为长度为10的实线，长度为5的虚线，长度为2的实线，长度为8的虚线，循环直到线段结束。</p><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-6cbeb754f0ff140f.gif?imageMogr2/auto-orient/strip" alt="曲线"></p><ul><li>二次贝塞尔曲线<br><img src="http://upload-images.jianshu.io/upload_images/1276164-db1b50a659d63560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二次贝塞尔曲线"><br>二次贝塞尔曲线有一个控制点，控制点的位置决定了显示一条怎样的曲线。下面的例子，我把起点pA、终点pB、控制点pC 都画出来方便观察。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//篇幅限制 只贴主要代码</span></span><br><span class="line"><span class="comment">//曲线</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *layerOne = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">layerOne.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">layerOne.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">layerOne.strokeStart = <span class="number">0</span>;</span><br><span class="line">layerOne.strokeEnd = <span class="number">1</span>;</span><br><span class="line">[view.layer addSublayer:layerOne];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:pA];</span><br><span class="line">[path addQuadCurveToPoint:pB controlPoint:pC];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关联路径</span></span><br><span class="line">layerOne.path = path.CGPath;</span><br></pre></td></tr></table></figure><ul><li>三次贝塞尔曲线<br>![Uploading Glass_和_iPhone_7_Plus_–_iOS_10_2__14C89__158499.png . . .]<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3cfcc224f189e5a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次贝塞尔曲线"><br>三次贝塞尔曲线有两个控制点，两个控制点的位置决定了显示一条怎样的曲线。下面的例子，我把起点pA、终点pB、控制点pC、pD 都画出来方便观察。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//篇幅限制 只贴主要代码</span></span><br><span class="line"><span class="comment">//曲线</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *layerTwo = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">layerTwo.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">layerTwo.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">layerTwo.strokeStart = <span class="number">0</span>;</span><br><span class="line">layerTwo.strokeEnd = <span class="number">1</span>;</span><br><span class="line">[view.layer addSublayer:layerTwo];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:pA];</span><br><span class="line">[path addCurveToPoint:pB controlPoint1:pC controlPoint2:pD];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关联路径</span></span><br><span class="line">layerTwo.path = path.CGPath;</span><br></pre></td></tr></table></figure><ul><li>圆角矩形</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRectRound &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [<span class="keyword">self</span>.view viewWithTag:<span class="number">1028</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *rectRound = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(kDeviceWidth/<span class="number">2.0</span><span class="number">-100</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">100</span>) byRoundingCorners:<span class="built_in">UIRectCornerBottomLeft</span> | <span class="built_in">UIRectCornerBottomRight</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *layer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    layer.strokeColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    layer.fillColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">    layer.path = rectRound.CGPath;</span><br><span class="line">    </span><br><span class="line">    [view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1276164-7def553629daf890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆角矩形"></p><ul><li>虚线圆<br>如果是静态的(无动画)，那么需要两个贝塞尔圆环曲线表示内圆和外圆，内圆一周，外圆实时进度。<br>如果是动态的(有动画)，那么可以一个贝塞尔圆环曲线表示内圆和外圆，内、外圆都一周，外圆添加动画，动画的<code>toValue</code>标志实时进度。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-0e78eb5eaa0f4f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚线圆"></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawXuCircle &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [<span class="keyword">self</span>.view viewWithTag:<span class="number">1029</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//底部虚圆</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *xuCircle = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    xuCircle.lineWidth = <span class="number">10</span>;</span><br><span class="line">    xuCircle.strokeColor = ColorWithHex(<span class="number">0xbebebe</span>, <span class="number">1</span>).CGColor;</span><br><span class="line">    xuCircle.fillColor = <span class="literal">nil</span>;</span><br><span class="line">    xuCircle.lineJoin = kCALineJoinMiter;</span><br><span class="line">    xuCircle.lineDashPattern = @[@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    [view.layer addSublayer:xuCircle];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//外部虚圆</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *circle = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    circle.lineWidth = <span class="number">10</span>;</span><br><span class="line">    circle.strokeColor = ColorWithHex(<span class="number">0xa2d100</span>, <span class="number">1</span>).CGColor;</span><br><span class="line">    circle.fillColor = <span class="literal">nil</span>;</span><br><span class="line">    circle.lineJoin = kCALineJoinMiter;</span><br><span class="line">    circle.lineDashPattern = @[@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    [view.layer addSublayer:circle];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *xuBezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(kDeviceWidth/<span class="number">2.0</span>, <span class="number">100</span>) radius:<span class="number">55</span> startAngle:-M_PI_2 endAngle:<span class="number">3</span>*M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *bezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(kDeviceWidth/<span class="number">2.0</span>, <span class="number">100</span>) radius:<span class="number">55</span> startAngle:-M_PI_2 endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    xuCircle.path = xuBezierPath.CGPath;</span><br><span class="line">    circle.path = bezierPath.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><blockquote><p>现在我们来给一些图形加上动画，使运行起来更美观。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-879cf2a6c243266b.gif?imageMogr2/auto-orient/strip" alt="动画"></p></blockquote><ul><li>主要写了三类动画<br>1.最常用的普通动画<br>2.进度条动画<br>3.其他属性的动画（比如这里有重复次数和逆执行）</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通动画，strokeEnd</span></span><br><span class="line">- (CABasicAnimation *)animComm &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animComm</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animComm</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animComm</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animComm</span>.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        <span class="variable">_animComm</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animComm</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进度条动画</span></span><br><span class="line">- (CABasicAnimation *)animProgress &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animProgress</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animProgress</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animProgress</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animProgress</span>.toValue = @<span class="number">0.7</span>;</span><br><span class="line">        <span class="variable">_animProgress</span>.fillMode = kCAFillModeForwards;</span><br><span class="line">        <span class="variable">_animProgress</span>.removedOnCompletion = NO;</span><br><span class="line">        <span class="variable">_animProgress</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animProgress</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重复次数，逆执行试用</span></span><br><span class="line">- (CABasicAnimation *)animRepeat &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animRepeat</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animRepeat</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animRepeat</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.autoreverses = YES;</span><br><span class="line">        <span class="variable">_animRepeat</span>.repeatCount = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animRepeat</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的柱状图"><a href="#简单的柱状图" class="headerlink" title="简单的柱状图"></a>简单的柱状图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-452e7362dd44076b.gif?imageMogr2/auto-orient/strip" alt="简单柱状图"></p><p>这是个非常简单的柱状图，需要注意的是柱子的三个重要部分，起点、终点、柱宽。柱子由起点根据柱宽向左右两边扩张，如下图柱子的起点是位置2而不是位置1。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-f226f1e227c4c8f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="柱状图"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SJBarChart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> lineWidth  = <span class="number">1.0</span>;      <span class="comment">//坐标轴线宽</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> distance   = <span class="number">20.0</span>;     <span class="comment">//距屏幕边距</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> cornerW    = <span class="number">10.0</span>f;    <span class="comment">//拐角长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> barWidth   = <span class="number">50.0</span>f;    <span class="comment">//柱状宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> space      = <span class="number">30.0</span>f;    <span class="comment">//柱状之间的间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> scale      = <span class="number">3.0</span>f;     <span class="comment">//柱状显示高度计算比例 *scale</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJBarChart</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> selfW, selfH;</span><br><span class="line">    <span class="built_in">NSArray</span> *source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *xAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *yAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *barScrollView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CABasicAnimation</span> *animation;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SJBarChart</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        selfW = frame.size.width;</span><br><span class="line">        selfH = frame.size.height;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showBarChart:(<span class="built_in">NSArray</span> *)sourceArray &#123;</span><br><span class="line">    source = sourceArray;</span><br><span class="line">    [<span class="keyword">self</span> addxyAxis];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.barScrollView];</span><br><span class="line">    _barScrollView.contentSize = <span class="built_in">CGSizeMake</span>(sourceArray.count*(space+barWidth) + space, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    [sourceArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *bar = [<span class="keyword">self</span> drawBar:idx];</span><br><span class="line">        [_barScrollView.layer addSublayer:bar];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//柱状图</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)drawBar:(<span class="built_in">NSInteger</span>)index &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *layer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    layer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    layer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    layer.lineWidth = barWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//终点y</span></span><br><span class="line">    <span class="built_in">CGFloat</span> y = _barScrollView.frame.size.height<span class="number">-60</span> - lineWidth/<span class="number">2.0</span> - ([[source objectAtIndex:index] floatValue] * scale);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>((space + barWidth)*index + (space+barWidth/<span class="number">2.0</span>), _barScrollView.frame.size.height<span class="number">-60</span>)];</span><br><span class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>((space + barWidth)*index + (space+barWidth/<span class="number">2.0</span>), y)];</span><br><span class="line">    layer.path = path.CGPath;</span><br><span class="line">    </span><br><span class="line">    [layer addAnimation:<span class="keyword">self</span>.animation forKey:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加坐标轴</span></span><br><span class="line">- (<span class="keyword">void</span>)addxyAxis &#123;</span><br><span class="line">    <span class="keyword">self</span>.xAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance, selfH<span class="number">-30</span>) endPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance-cornerW, selfH<span class="number">-30</span>-cornerW)];</span><br><span class="line">    <span class="keyword">self</span>.yAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance+lineWidth/<span class="number">2.0</span>, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(distance, <span class="number">30</span>) endPoint:<span class="built_in">CGPointMake</span>(distance+cornerW, <span class="number">30</span>+cornerW)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.xAxis];</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.yAxis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画坐标轴</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)lineWithStartPoint:(<span class="built_in">CGPoint</span>)startPoint breakPoint:(<span class="built_in">CGPoint</span>)breakPoint endPoint:(<span class="built_in">CGPoint</span>)endPoint &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *line = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    line.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    line.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">    line.lineWidth = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *linePath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [linePath moveToPoint:startPoint];</span><br><span class="line">    [linePath addLineToPoint:breakPoint];</span><br><span class="line">    [linePath addLineToPoint:endPoint];</span><br><span class="line">    line.path = linePath.CGPath;</span><br><span class="line">    </span><br><span class="line">    [line addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"xyLineStrokeEndAnimation"</span>];</span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)barScrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (_barScrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _barScrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(distance+lineWidth, <span class="number">30</span>, kDeviceWidth-distance*<span class="number">2</span>-lineWidth-cornerW, selfH<span class="number">-60</span>-lineWidth/<span class="number">2.0</span>)];</span><br><span class="line">        _barScrollView.bounces = <span class="literal">NO</span>;</span><br><span class="line">        _barScrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _barScrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CABasicAnimation</span> *)animation &#123;</span><br><span class="line">    <span class="keyword">if</span> (_animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</span><br><span class="line">        _animation.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        _animation.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        _animation.duration = <span class="number">2.0</span>;</span><br><span class="line">        _animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _animation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-927e70f03aad6179.gif?imageMogr2/auto-orient/strip" alt="折线图"></p><p>柱状图是一条条单独的线段，折线图就是一条连起来的完整折线。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SJLineChart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> lineWidth  = <span class="number">1.0</span>;      <span class="comment">//坐标轴线宽</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> distance   = <span class="number">20.0</span>;     <span class="comment">//距屏幕边距</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> cornerW    = <span class="number">10.0</span>f;    <span class="comment">//拐角长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> space      = <span class="number">50.0</span>f;    <span class="comment">//柱状之间的间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> scale      = <span class="number">3.0</span>f;     <span class="comment">//直线显示高度计算比例 *scale</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> radius     = <span class="number">3.0</span>f;     <span class="comment">//标记每个点的小圆半径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJLineChart</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> selfW, selfH;</span><br><span class="line">    <span class="built_in">NSArray</span> *source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *xAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *yAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *lineScrollView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CABasicAnimation</span> *animation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SJLineChart</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        selfW = frame.size.width;</span><br><span class="line">        selfH = frame.size.height;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showLineChart:(<span class="built_in">NSArray</span> *)sourceArray &#123;</span><br><span class="line">    source = sourceArray;</span><br><span class="line">    [<span class="keyword">self</span> addxyAxis];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.lineScrollView];</span><br><span class="line">    _lineScrollView.contentSize = <span class="built_in">CGSizeMake</span>(sourceArray.count*(space+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    [<span class="keyword">self</span> drawLineChart:sourceArray];</span><br><span class="line">    [<span class="keyword">self</span> drawPoint:sourceArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLineChart:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *lineLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    lineLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    lineLayer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    lineLayer.lineWidth = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//轨迹</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(space, _lineScrollView.frame.size.height - <span class="number">60</span> - lineWidth/<span class="number">2.0</span> - ([[array objectAtIndex:<span class="number">0</span>] floatValue] * scale))];</span><br><span class="line">    </span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> y = _lineScrollView.frame.size.height<span class="number">-60</span> - lineWidth/<span class="number">2.0</span> - ([obj floatValue] * scale);</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(space*(idx+<span class="number">1</span>), y)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    lineLayer.path = path.CGPath;</span><br><span class="line">    [<span class="keyword">self</span>.lineScrollView.layer addSublayer:lineLayer];</span><br><span class="line">    [lineLayer addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"lineStrokeEndAnimation"</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把点标出来</span></span><br><span class="line">- (<span class="keyword">void</span>)drawPoint:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    </span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">CGFloat</span> y = _lineScrollView.frame.size.height - <span class="number">60</span> - lineWidth/<span class="number">2.0</span> - [obj floatValue]*scale;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIBezierPath</span> *circlePath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(space * (idx+<span class="number">1</span>), y) radius:radius startAngle:<span class="number">0</span> endAngle:(M_PI)*<span class="number">2</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *circleLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">        circleLayer.fillColor = [<span class="built_in">UIColor</span> orangeColor].CGColor;</span><br><span class="line">        circleLayer.strokeColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">        circleLayer.path = circlePath.CGPath;</span><br><span class="line">        </span><br><span class="line">        [_lineScrollView.layer addSublayer:circleLayer];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加坐标轴</span></span><br><span class="line">- (<span class="keyword">void</span>)addxyAxis &#123;</span><br><span class="line">    <span class="keyword">self</span>.xAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance, selfH<span class="number">-30</span>) endPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance-cornerW, selfH<span class="number">-30</span>-cornerW)];</span><br><span class="line">    <span class="keyword">self</span>.yAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance+lineWidth/<span class="number">2.0</span>, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(distance, <span class="number">30</span>) endPoint:<span class="built_in">CGPointMake</span>(distance+cornerW, <span class="number">30</span>+cornerW)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.xAxis];</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.yAxis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画坐标轴</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)lineWithStartPoint:(<span class="built_in">CGPoint</span>)startPoint breakPoint:(<span class="built_in">CGPoint</span>)breakPoint endPoint:(<span class="built_in">CGPoint</span>)endPoint &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *line = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    line.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    line.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">    line.lineWidth = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *linePath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [linePath moveToPoint:startPoint];</span><br><span class="line">    [linePath addLineToPoint:breakPoint];</span><br><span class="line">    [linePath addLineToPoint:endPoint];</span><br><span class="line">    line.path = linePath.CGPath;</span><br><span class="line">    </span><br><span class="line">    [line addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"xyLineStrokeEndAnimation"</span>];</span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)lineScrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (_lineScrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _lineScrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(distance+lineWidth, <span class="number">30</span>, kDeviceWidth-distance*<span class="number">2</span>-lineWidth, selfH<span class="number">-60</span>-lineWidth/<span class="number">2.0</span>)];</span><br><span class="line">        _lineScrollView.bounces = <span class="literal">NO</span>;</span><br><span class="line">        _lineScrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _lineScrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CABasicAnimation</span> *)animation &#123;</span><br><span class="line">    <span class="keyword">if</span> (_animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</span><br><span class="line">        _animation.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        _animation.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        _animation.duration = <span class="number">2.0</span>;</span><br><span class="line">        _animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _animation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>感谢阅读全文的朋友。<br>☞demo地址 <a href="https://github.com/SPIREJ/SJCAShapeLayer" target="_blank" rel="noopener">https://github.com/SPIREJ/SJCAShapeLayer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇主要从以下几个方面来写的一点东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线段&lt;/li&gt;
&lt;li&gt;曲线&lt;/li&gt;
&lt;li&gt;动画&lt;/li&gt;
&lt;li&gt;简单的柱状图&lt;/li&gt;
&lt;li&gt;简单的折线图
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="图形" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>CAShapeLayer &amp; UIBezierPath &amp; CABasicAnimation</title>
    <link href="http://yoursite.com/2017/02/16/CAShapeLayer&amp;UIBezierPath&amp;CABasicAnimation/"/>
    <id>http://yoursite.com/2017/02/16/CAShapeLayer&amp;UIBezierPath&amp;CABasicAnimation/</id>
    <published>2017-02-16T10:22:05.000Z</published>
    <updated>2017-02-24T04:57:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><p>普通<code>CALayer</code>在被初始化时是需要给一个frame值的,这个frame值一般都与给定view的bounds值一致,它本身是有形状的,而且是矩形.<br>每个<code>CAShapeLayer</code>对象都代表着将要被渲染到屏幕上的形状(shape),CAShapeLayer在初始化时也需要给一个frame值,但是,它本身没有形状,它的形状来源于你给定的一个path,然后它去取<code>CGPath</code>值,它与CALayer有着很大的区别.</p><p>并且，系统仅会渲染CAShapeLayer对象的形状，其他任何非CAShapeLayer的自由属性在渲染是都会被忽略。因此从某种意义上讲CAShapeLayer仅是形状的容器。虽然由于其实CALayer的子类，可以设置<code>contents</code>、<code>backgroundColor</code>等属性，但这些属性在渲染时也会被忽略。</p><h4 id="但是，CAShapeLayer提供了自身的可设置性："><a href="#但是，CAShapeLayer提供了自身的可设置性：" class="headerlink" title="- 但是，CAShapeLayer提供了自身的可设置性："></a>- 但是，CAShapeLayer提供了自身的可设置性：</h4><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>path</td><td>fillColor</td><td>fillRule</td><td>strokeColor</td></tr><tr><td>strokeStart</td><td>strokeEnd</td><td>lineWidth</td><td>miterLimit</td></tr><tr><td>lineCap</td><td>lineJoin</td><td>lineDashPhase</td><td>lineDashPattern</td></tr></tbody></table><a id="more"></a><ul><li><p>path<br>  动画路径，默认为NULL，不支持隐式动画。路径可以使用任何的具体子类的动画CAPropertyAnimation。如果此属性的值是不为NULL，则path使用指定的路径，而不是创建该层的合成后的alpha通道。它使用的是非零缠绕规则和当前颜色，不透明度和模糊半径填充。 </p></li><li><p>fillColor<br>  填充颜色，默认为不透明的黑色，若值为nil，则没有填充效果。<br>fillColor针对于闭合的图形，对于镂空图形只需设置画笔颜色<code>strokeColor</code>即可。</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//闭合多边形</span><br><span class="line">- (void)drawTriangle &#123;</span><br><span class="line">    UIView *view = [<span class="keyword">self.view </span>viewWithTag:<span class="number">1026</span>]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *triangle = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    triangle.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    triangle.<span class="keyword">strokeColor </span>= [UIColor clearColor].CGColor<span class="comment">;</span></span><br><span class="line">    triangle.fillColor = [UIColor redColor].CGColor<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:triangle];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0-100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0+100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    triangle.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1276164-cd35cad81961ab23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fillColor和strokeColor两种设置的效果"></p><ul><li><p>fillRule<br>  填充规则，默认是kCAFillRuleNonZero。<br>  kCAFillRuleNonZero：指定非零缠绕规则。计算每个左到右的路径+1或-1为每个从右到左的道路。如果所有交叉的总和为0，则点是路径之外，如果该和为非零，改点是在路径内与包含它的区域被填充。<br>  kCAFillRuleEvenOdd：指定奇偶缠绕规则。算路径交叉的总和，如果横跨的数目是偶数，改点在路径之外。如果横跨的数目是奇数，所述点是在路径内与包含它的区域应被填充。</p></li><li><p>strokeColor<br>  画笔颜色。</p></li><li><p>strokeStart<br>  和strokeEnd组合使用，默认值为1.0，取值范围0.0~1.0</p></li><li><p>strokeEnd<br>  和strokeStart组合使用，默认值为1.0，取值范围为0.0~1.0</p></li><li><p>lineWidth<br>  线宽。注意线宽有一个特点，线宽从你设置的起点往左右两边同时伸展。</p></li><li><p>miterLimit<br>  斜接样式，默认值为10.0</p></li><li><p>lineCap<br>  线端点样式，默认值为kCALineCapButt，还有kCALineCapRound，kCALineCapSquare<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3950101908ae9c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线端点样式示例"></p></li><li><p>lineJoin<br>  拐角样式，默认值为kCALineJoinMiter（尖角），还有kCALineJoinRound（圆角），kCALineJoinBevel（平角）<br><img src="http://upload-images.jianshu.io/upload_images/1276164-ae5278976c113bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拐角样式示例"></p></li><li><p>lineDashPhase<br>  冲刺阶段应用到的形状的路径，默认是0.0</p></li><li><p>lineDashPattern<br>设置线的样式，默认为实线，该数组为一个NSNumber数组，数组中的数值依次表示虚线中，单个线的长度，和空白的长度，如:数组@[@10,@5] 表示 有长度为10的线，长度为5的空白，不断循环后组成的虚线。<br>当然数组的长度是不做限制的，你亦可以@[@2,@3,@4,@5],可以表示为长度为2的线+长度为3的空白+长度为4的线+长度为5的空白，不断循环直到线段结束。</p></li><li><p>mask<br>  mask本身就是个CALayer，mask属性用作裁剪功能。<br>mask只作为形状（shape）的样子，裁剪后的形状以mask为准，其他例如颜色等属性以原图为准。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-30817b1838eee1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种mask裁剪示例"></p></li></ul><h4 id="CAShapeLayer有以下几点特点："><a href="#CAShapeLayer有以下几点特点：" class="headerlink" title="- CAShapeLayer有以下几点特点："></a>- CAShapeLayer有以下几点特点：</h4><ul><li>它依附于一个<code>path</code>，必须给予path，即使path不完整也会自动首尾相接。</li><li><code>strokeStart</code>及<code>strokeEnd</code>代表着在这个path中所占用的百分比。</li><li>CAShapeLayer动画仅限于沿着边缘的动画效果，它不能直接实现填充效果，但可以间接实现填充效果。</li></ul><h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><p>使用<code>UIBezierPath</code>可以创建基于矢量的路径，此类是<code>Core Graphics</code>框架关于路径的封装。使用此类可以定义简单的形状，如椭圆、矩形或有多个直线和曲线组成的形状等。</p><p><code>UIBezierPath</code>是<code>CGPathRef</code>数据类型的封装。如果是基于矢量形状的路径，都用直线或曲线去创建。我们使用直线段去创建矩形和多边形，使用曲线去创建圆弧、圆或其他复杂的曲线形状。</p><ul><li>最基本的初始化方法，用它创建的对象，我们可以根据我们的需要任意定制样式，可以话任何想画的图形。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPath;</span><br></pre></td></tr></table></figure><ul><li>初始化一个矩形矩形贝塞尔曲线。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRect:(<span class="type">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><ul><li>根据一个矩形画内切曲线，通常用来画圆或椭圆（取决于传入的rect是正方形还是长方形）。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithOvalInRect:(<span class="type">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><ul><li>画矩形，但是这个矩形可以画圆角。第一个参数是矩形，第二个参数是圆角大小。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRoundedRect:(<span class="type">CGRect</span>)rect cornerRadius:(<span class="type">CGFloat</span>)cornerRadius;</span><br></pre></td></tr></table></figure><ul><li>画矩形，矩形可以圆角，可以指定某个角或其中多个角成为圆角。参数：<code>UIRectCornerTopLeft</code>，<code>UIRectCornerTopRight</code>，<code>UIRectCornerBottomLeft</code>，<code>UIRectCornerBottomRight</code>，<code>UIRectCornerAllCorners</code></li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRoundedRect:(<span class="type">CGRect</span>)rect byRoundingCorners:(<span class="type">UIRectCorner</span>)corners cornerRadii:(<span class="type">CGSize</span>)cornerRadii;</span><br></pre></td></tr></table></figure><ul><li>画弧线，参数说明：<ul><li>center 弧线中心点的坐标</li><li>radius 弧线所在圆的半径</li><li>startAngle 弧线开始的角度值</li><li>endAngle 弧线结束的角度值</li><li>clockwise 是否顺时针画弧线</li></ul></li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithArcCenter:(<span class="type">CGPoint</span>)center radius:(<span class="type">CGFloat</span>)radius startAngle:(<span class="type">CGFloat</span>)startAngle endAngle:(<span class="type">CGFloat</span>)endAngle clockwise:(<span class="type">BOOL</span>)clockwise;</span><br></pre></td></tr></table></figure><h3 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h3><p><code>CABasicAnimation</code>类的使用方式就是关键帧动画，所谓关键帧动画，就是将Layer的属性作为<code>keyPath</code>来注册，指定动画的起始帧和结束帧，然后自动计算和实现中间的过渡动画的一种动画方式。</p><p>CABasicAnimation自己只有三个property:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> fromValue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> toValue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> byValue</span><br></pre></td></tr></table></figure><p>当创建一个<code>CABasicAnimation</code>的时候，需要通过 <code>-setFromValue</code>和 <code>-setToValue</code> 来指定一个开始值和结束值。当你增加基础动画到层中的时候，它开始运行。当用属性做动画完成时，例如用位置属性做动画，层就会立刻返回到它的初始位置。</p><h4 id="设定动画的属性说明"><a href="#设定动画的属性说明" class="headerlink" title="- 设定动画的属性说明"></a>- 设定动画的属性说明</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>duration</td><td>动画时长（单位：秒）</td></tr><tr><td>repeatCount</td><td>重复次数，永久重复的话设置为HUGE_VALF</td></tr><tr><td>beginTime</td><td>指定动画开始时间。从开始指定延迟几秒执行的话，请设置为「CACurrentMediaTime() + 秒数」的形式</td></tr><tr><td>timingFunction</td><td>设定动画的速度变化</td></tr><tr><td>autoreverses</td><td>动画结束时是否执行逆动画</td></tr><tr><td>shadowColor</td><td>阴影的颜色</td></tr><tr><td>shadowOffset</td><td>阴影的偏移量</td></tr><tr><td>shadowOpacity</td><td>阴影的透明度</td></tr><tr><td>shadowRadius</td><td>阴影的圆角</td></tr><tr><td>fromValue</td><td>所改变属性的起始值</td></tr><tr><td>toValue</td><td>所改变属性的结束时的值</td></tr><tr><td>byValue</td><td>所改变属性相同起始值得改变量</td><td>;</td></tr></tbody></table><h4 id="常用的animationWithKeyPath值的总结"><a href="#常用的animationWithKeyPath值的总结" class="headerlink" title="- 常用的animationWithKeyPath值的总结"></a>- 常用的animationWithKeyPath值的总结</h4><table><thead><tr><th>值</th><th>说明</th><th>使用形式</th></tr></thead><tbody><tr><td>transform.scale</td><td>比例转化</td><td>@(0.8)</td></tr><tr><td>transform.scale.x</td><td>宽的比例</td><td>@(0.8)</td></tr><tr><td>transform.scale.y</td><td>高的比例</td><td>@(0.8)</td></tr><tr><td>transform.rotation.x</td><td>围绕x轴旋转</td><td>@(M_PI)</td></tr><tr><td>transform.rotation.y</td><td>围绕y轴旋转</td><td>@(M_PI)</td></tr><tr><td>transform.rotation.z</td><td>围绕z轴旋转</td><td>@(M_PI)</td></tr><tr><td>cornerRadius</td><td>圆角的设置</td><td>@(20)</td></tr><tr><td>backgroundColor</td><td>背景颜色的变化</td><td>[UIColor orangeColor].CGColor;</td></tr><tr><td>bounds</td><td>大小，中心不变</td><td>[NSValue valueWithCGRect:CGRectMake(100,100)];</td></tr><tr><td>position</td><td>位置(中心点的改变)</td><td>[NSValue valueWithCGPoint:CGPointMake(100,100)];</td></tr><tr><td>contents</td><td>内容(比如UIImageView的图片)</td><td>imageAnima.toValue = (id)[UIImage imageNamed:@“toIcon”].CGImage;</td></tr><tr><td>opacity</td><td>透明度</td><td>@(0.8)</td></tr><tr><td>contentsRect.size.width</td><td>横向拉伸缩放</td><td>@(0.5)最好在0~1之间</td></tr></tbody></table><h5 id="捕获动画开始时和终了时的事件"><a href="#捕获动画开始时和终了时的事件" class="headerlink" title="- 捕获动画开始时和终了时的事件"></a>- 捕获动画开始时和终了时的事件</h5><p>设置委托对象，实现委托方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 动画开始时 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animationDidStart</span><span class="selector-pseudo">:(CAAnimation</span> *)<span class="selector-tag">theAnimation</span> &#123;</span><br><span class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"begin"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 动画结束时 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animationDidStop</span><span class="selector-pseudo">:(CAAnimation</span> *)<span class="selector-tag">theAnimation</span> <span class="selector-tag">finished</span><span class="selector-pseudo">:(BOOL)flag</span> &#123;  </span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"end"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><code>CAShapeLayer</code>和<code>UIBezierPath</code>规定一个形状，<code>CABasicAnimation</code>为其添加动画。下一篇我将写具体的实例。最后，非常感谢您阅读全文。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=347128&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CAShapeLayer&quot;&gt;&lt;a href=&quot;#CAShapeLayer&quot; class=&quot;headerlink&quot; title=&quot;CAShapeLayer&quot;&gt;&lt;/a&gt;CAShapeLayer&lt;/h3&gt;&lt;p&gt;普通&lt;code&gt;CALayer&lt;/code&gt;在被初始化时是需要给一个frame值的,这个frame值一般都与给定view的bounds值一致,它本身是有形状的,而且是矩形.&lt;br&gt;每个&lt;code&gt;CAShapeLayer&lt;/code&gt;对象都代表着将要被渲染到屏幕上的形状(shape),CAShapeLayer在初始化时也需要给一个frame值,但是,它本身没有形状,它的形状来源于你给定的一个path,然后它去取&lt;code&gt;CGPath&lt;/code&gt;值,它与CALayer有着很大的区别.&lt;/p&gt;
&lt;p&gt;并且，系统仅会渲染CAShapeLayer对象的形状，其他任何非CAShapeLayer的自由属性在渲染是都会被忽略。因此从某种意义上讲CAShapeLayer仅是形状的容器。虽然由于其实CALayer的子类，可以设置&lt;code&gt;contents&lt;/code&gt;、&lt;code&gt;backgroundColor&lt;/code&gt;等属性，但这些属性在渲染时也会被忽略。&lt;/p&gt;
&lt;h4 id=&quot;但是，CAShapeLayer提供了自身的可设置性：&quot;&gt;&lt;a href=&quot;#但是，CAShapeLayer提供了自身的可设置性：&quot; class=&quot;headerlink&quot; title=&quot;- 但是，CAShapeLayer提供了自身的可设置性：&quot;&gt;&lt;/a&gt;- 但是，CAShapeLayer提供了自身的可设置性：&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;fillColor&lt;/td&gt;
&lt;td&gt;fillRule&lt;/td&gt;
&lt;td&gt;strokeColor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strokeStart&lt;/td&gt;
&lt;td&gt;strokeEnd&lt;/td&gt;
&lt;td&gt;lineWidth&lt;/td&gt;
&lt;td&gt;miterLimit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lineCap&lt;/td&gt;
&lt;td&gt;lineJoin&lt;/td&gt;
&lt;td&gt;lineDashPhase&lt;/td&gt;
&lt;td&gt;lineDashPattern&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>一个程序员的12个新年愿望</title>
    <link href="http://yoursite.com/2017/02/05/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8412%E4%B8%AA%E6%96%B0%E5%B9%B4%E6%84%BF%E6%9C%9B/"/>
    <id>http://yoursite.com/2017/02/05/一个程序员的12个新年愿望/</id>
    <published>2017-02-04T16:00:00.000Z</published>
    <updated>2017-02-05T13:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：有感于 <a href="http://mp.weixin.qq.com/s/05SPiUui9Nx-3kO0bIyU_Q" target="_blank" rel="noopener">一个程序员的12个新年愿望</a></p></blockquote><p>2017年的工作从今天正式开始了(从春节后算)，在新的一年，总结了12个新年心愿。</p><blockquote><ul><li>保持健康</li><li>学习一门新的编程语言</li><li>坚持写博客</li><li>注意安全</li><li>戒烟</li><li>早睡早起</li><li>出去走走</li><li>追求喜欢的人</li><li>健身</li><li>有自己的窝</li><li>保持联系</li><li>完成一个个人项目<a id="more"></a></li></ul></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31445772&auto=1&height=66"></iframe><ul><li><code>保持健康</code></li></ul><p>保持健康，不管是现在还是将来。<br>每天都久坐在座位上，又不爱锻炼的程序员，带来了健康的严峻挑战。<br>当我还在二十一二岁的时候，那时的我当然没察觉到健康到底对我有多重要，能跑能跳能熬夜能饿肚子能吃很多；当我快要三十岁了得时候，我终于意识到健康对我来说有多重要，不能跑不能跳不能熬夜不能饿肚子只能吃很少，以前认为的那种旺盛精力是不可能一直存在的，生活的方方面面都潜存着压力，身体的机能也一直在慢慢下降，你以为自己还好的很，但是身体是最不会撒谎的，如果不爱惜，它会准时的提醒你。<br>譬如现在一年总会感冒二到三次，而且必经三阶段：嗓子疼—&gt;流鼻涕—&gt;头疼，总是持续很长时间，吃药才能好，以前那个感冒了睡一觉出身汗就屁事儿没有的我已经不复存在了%&gt;_&lt;%。<br>现在，腰、颈、背 都是问题，纠正坐姿，站立结合，越快越好~<br>现在，不管是作息、饮食、心情、身体 都保持健康QAQ。</p><ul><li><code>学习一门新的编程语言</code></li></ul><p>保持学习是对自己不被淘汰的最大负责。<br>不管是主流的，还是非主流的，只要坚持学习，就一定是自己的收获~</p><ul><li><code>坚持写博客</code></li></ul><p>写博客已经是一个爱好了，有时候就是觉得自己写的不够好才不敢放出来，看了大神的写作确实会受到打击，但谁不是从新手过来的呢。<br>只要做好自己，应该就是最好的了吧~<br>工作，生活，学习，感想 都想统统的记下来~<br>积累下来，也不失为一笔财富~<br>也许多年之后，再回首，也感慨，不度虚年~</p><ul><li><code>注意安全</code></li></ul><p>注意安全，其实包括着方方面面。比如说每天出门的时候记得锁门，记得带钥匙。过马路的时候注意车辆，出去玩的时候注意保护自己，骑行的时候注意安全，</p><ul><li><code>戒烟</code></li></ul><p>啥也不说了，抽完这包不抽了…<br><img src="http://upload-images.jianshu.io/upload_images/1276164-d857e649f08f2dff.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这是最后一包烟"></p><ul><li><code>早睡早起</code></li></ul><p>早睡早起可能是最容易做到也可能是最难做到的了，舍不得早晨温暖的被窝，舍不得浪费夜晚大把的时光~</p><ul><li><code>出去走走</code></li></ul><p>河山大好，出去走走，别窝在家当懒虫，碧海蓝天吹吹风~<br>弹指一挥人生苦短，好地方一生都看不完。</p><ul><li><code>追求喜欢的人</code></li></ul><p>略。</p><ul><li><code>健身</code></li></ul><p>不让自己的身体提前进入老年化，要健康也要好身材QAQ</p><ul><li><code>有自己的窝</code></li></ul><p>这可能是一件最令我幸福也是最有压力的一件事了…</p><ul><li><code>保持联系</code></li></ul><p>和亲近的人保持联系，和不亲近的人随风而去~</p><ul><li><code>完成一个个人项目</code></li></ul><p>抽时间选一个有趣的项目慢慢完成它，不用赶进度，尽量完美，再好不过。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;声明：有感于 &lt;a href=&quot;http://mp.weixin.qq.com/s/05SPiUui9Nx-3kO0bIyU_Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个程序员的12个新年愿望&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2017年的工作从今天正式开始了(从春节后算)，在新的一年，总结了12个新年心愿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;保持健康&lt;/li&gt;
&lt;li&gt;学习一门新的编程语言&lt;/li&gt;
&lt;li&gt;坚持写博客&lt;/li&gt;
&lt;li&gt;注意安全&lt;/li&gt;
&lt;li&gt;戒烟&lt;/li&gt;
&lt;li&gt;早睡早起&lt;/li&gt;
&lt;li&gt;出去走走&lt;/li&gt;
&lt;li&gt;追求喜欢的人&lt;/li&gt;
&lt;li&gt;健身&lt;/li&gt;
&lt;li&gt;有自己的窝&lt;/li&gt;
&lt;li&gt;保持联系&lt;/li&gt;
&lt;li&gt;完成一个个人项目
    
    </summary>
    
      <category term="随笔~" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>纪念狗正八</title>
    <link href="http://yoursite.com/2017/01/28/%E7%BA%AA%E5%BF%B5%E7%8B%97%E6%AD%A3%E5%85%AB/"/>
    <id>http://yoursite.com/2017/01/28/纪念狗正八/</id>
    <published>2017-01-28T14:02:13.000Z</published>
    <updated>2017-02-05T14:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在青春中，爱情只是其中的一部分，甚至在青春的爱情里，闪光的不是结局，而是那青涩懵懂的过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/1276164-bc83b67a349af60f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请回答1988"></p><p>狗正八，一张苦瓜脸，首尔大学补刀专业毕业，性情冷漠。</p><p>但是狗正八，真的很man，因为他是狗正八，是珍惜所有人的狗正八。为了爸爸开心可以做不喜欢的（goldstar）见面礼，为了妈妈开心可以做听话的“二女儿”，为了哥哥去飞行学院；为了朋友伸出拳头，为了维系伙伴关系不跨越界限一直逃避，在这个青春懵懂的年纪，已经是如此成熟的狗正八！</p><p>很可惜，狗正八和德善永远是一个人进，一个人退，他们从未相向而行。正如他经过的时候，她低下了头，错过了一秒就错过了一生。</p><p>可能在狗正八的世界里，暗恋，已经是对自己的圆满了，我爱你，与你无关。</p><p>正如我一直相信他能和德善走在一起一样，直到最后的错过，雨中的独白，错过的时机，自我剖析的悔恨，狗正八的爱情在独白中已经交代，他已经完全退出了，而后餐厅借戒指的表白，可能是对自己青春的一种交代，一种释怀，对自己暗恋画上一个句号。然后还是开心的叫着特工队、喜东东、崔大师。</p><a id="more"></a><p>狗正八的爱情无疑是青涩的，他一直爱着那个叫德善的女孩，爱情和喷嚏是藏不住的，而他却把全部的力气用作隐藏。</p><p>一遍遍的拆解鞋带，直到那个女孩出现在假装不耐烦的离开~<br>若无其事的路过吐槽，而后带着憨厚的傻笑躲在窗口偷看~<br>在那个女孩每次看过来的时候收回凝视的目光~<br>当着小伙伴的面用力划开和女孩的界限~<br>夜晚的时候担心女孩有没有按时回家~<br>违背自己的心意说一些不好听得话~<br>收到粉红色衬衫开心的不得了~<br>下雨的时候撑伞等待~<br>精心准备圣诞礼物~<br>…<br><img src="http://upload-images.jianshu.io/upload_images/1276164-f6aa02bc8dd38beb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QAQ"></p><p>他的爱情无疑是纯真的，他的爱情缺无疑是稚嫩的。<br>然而，爱情从来不是逃避和躲藏后，期待对方的蓦然回首。<br>爱情需要努力的一步步靠近，而终相濡以沫。<br>爱情是世界上最脆弱的东西，它需要不断的呵护。更重要的是，它不是单方面的付出，而是两个人的靠近。</p><p>狗正八的独白：缘分就像是机遇，是他的犹豫摧毁了他的缘分。<br>是的，如果，他能少一点逃避，在德善被善宇伤害之前能够有勇气听善宇解释他的爱情，如果他能够在得知崔大师的心意后，有勇气正视德善，而不是用力逃开，那么最后那个红绿灯，根本不是上天的戏弄。</p><p>甚至，在最最开始的时候，当一切还没开始，他能坦率的告诉所有人，他喜欢德善，那么接下来的故事应该也很有趣。</p><p>可惜，他是狗正八，是珍惜所有人的狗正八，是贴心的“二女儿”，他想得太多，他也想得太少，他只是一个18岁的少年，只是一个普通的青春期的孩子，他没有做出该有的选择。<br>他的爱情，也许在他没解释粉红色衬衫的那一天就已经死了。<br>可是他却是如此的真实，我们是否也拥有一段无疾而终的暗恋，在那个蠢动的青春时代，在那个最初对异性有过萌动的青春，是否也偷偷爱着那么一个人，不敢告诉任何人，甚至是你最好的朋友。</p><p>你小心的爱着，全心全意的爱着，又用尽全身的力气去掩饰，知道你们各奔东西，知道你们再无缘分，于是某一天你们再次相遇，所有的萌动和情愫都已经远去，但是内心深处正如狗正八一样的低俗：如果当初我能够勇敢一点，如果没有选择逃避，如果不介意别人的眼光，如果没有那么多犹豫爱你所爱……可是没有如果，失去了所有如果，也没有任何可能。<br>甚至，连一次开玩笑的告白，都显得多余。</p><p>关于德善，其实正如她当时告诉阿爸的没有想做的事情一样，虽然看起来他喜欢过善宇，喜欢过狗正八，也喜欢崔大师，但是我只能认为她那是在情窦初开的时候对爱情的渴望，不像狗正八爱她那般，那么真切。</p><p>一句，不要去联谊<br>一句，你想想我为什么会来找你<br>一句，我会去（看电影）</p><p><img src="http://upload-images.jianshu.io/upload_images/1276164-db2e071831bf1f5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QwQ"></p><p>虽然结局也是很好的，但为什么我会如此的心疼狗正八。</p><p>人类是很肤浅的动物，青春充满了自卑和遐想(不仅仅是青春)，现实没有观众，你不能指望你所爱的人从你别扭的言语背后读懂你的内心。</p><p>不要以爱的名义去伤害爱你的人，不要以外爱情不会离开，不要用自己的爱感动了自己却无人所知。</p><p>现实中没有崔大师，没有这么完美的解决所有冲突的人物，故事的结局只会是多年以后，德善找到一个爱人，无意中发现青春时曾有人深深爱着自己，也是自己蠢萌有心意的对方，但是如今摊手耸肩。而狗正八呢，以为放弃了，保住自己珍惜的所有人，当再次见到初恋时，却物是人非。</p><p>如果你现在还在经历着同样的暗恋，还在别扭的掩饰，那么请不要。</p><p>错过的，终究会错过。<br>人类是脆弱的，时间和距离会腐烂所有的爱情，无一幸免。时间和距离也会治愈所有的伤痛，无一例外。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=400876423&auto=1&height=66"></iframe><p>SPIREJ<br>2017.01.28</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在青春中，爱情只是其中的一部分，甚至在青春的爱情里，闪光的不是结局，而是那青涩懵懂的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1276164-bc83b67a349af60f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请回答1988&quot;&gt;&lt;/p&gt;
&lt;p&gt;狗正八，一张苦瓜脸，首尔大学补刀专业毕业，性情冷漠。&lt;/p&gt;
&lt;p&gt;但是狗正八，真的很man，因为他是狗正八，是珍惜所有人的狗正八。为了爸爸开心可以做不喜欢的（goldstar）见面礼，为了妈妈开心可以做听话的“二女儿”，为了哥哥去飞行学院；为了朋友伸出拳头，为了维系伙伴关系不跨越界限一直逃避，在这个青春懵懂的年纪，已经是如此成熟的狗正八！&lt;/p&gt;
&lt;p&gt;很可惜，狗正八和德善永远是一个人进，一个人退，他们从未相向而行。正如他经过的时候，她低下了头，错过了一秒就错过了一生。&lt;/p&gt;
&lt;p&gt;可能在狗正八的世界里，暗恋，已经是对自己的圆满了，我爱你，与你无关。&lt;/p&gt;
&lt;p&gt;正如我一直相信他能和德善走在一起一样，直到最后的错过，雨中的独白，错过的时机，自我剖析的悔恨，狗正八的爱情在独白中已经交代，他已经完全退出了，而后餐厅借戒指的表白，可能是对自己青春的一种交代，一种释怀，对自己暗恋画上一个句号。然后还是开心的叫着特工队、喜东东、崔大师。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔~" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/01/23/hello-world/"/>
    <id>http://yoursite.com/2017/01/23/hello-world/</id>
    <published>2017-01-23T12:55:53.000Z</published>
    <updated>2017-01-23T12:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hi，欢迎您来到我的小站，我是SPIREJ，脑袋一热就想要建立自己的个人网站，于是就是您现在看到的。在这里我会写一些关于工作、关于生活的一些小文章，如果您喜欢的话可以点赞。如果您有疑问或者建议的话可以直接在文章后面留下您的疑问或建议，或者给我发邮件，我会尽量第一时间回复您。</p><p>其他链接：<br><a href="https://github.com/SPIREJ" target="_blank" rel="noopener">GitHub</a>.<br><a href="http://www.jianshu.com/u/21a8887ed7ef" target="_blank" rel="noopener">简书</a><br><a href="http://weibo.com/2027941740/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" rel="noopener">微博</a><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hi，欢迎您来到我的小站，我是SPIREJ，脑袋一热就想要建立自己的个人网站，于是就是您现在看到的。在这里我会写一些关于工作、关于生活的一些小文章，如果您喜欢的话可以点赞。如果您有疑问或者建议的话可以直接在文章后面留下您的疑问或建议，或者给我发邮件，我会尽量第一时间回复您。&lt;/p&gt;
&lt;p&gt;其他链接：&lt;br&gt;&lt;a href=&quot;https://github.com/SPIREJ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/u/21a8887ed7ef&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简书&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://weibo.com/2027941740/profile?topnav=1&amp;amp;wvr=6&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微博&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Work" scheme="http://yoursite.com/categories/Work/"/>
    
    
      <category term="Study" scheme="http://yoursite.com/tags/Study/"/>
    
  </entry>
  
</feed>
