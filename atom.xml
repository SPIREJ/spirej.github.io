<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>等风来，等花开❀~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-20T10:48:35.259Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ぱゐずだιονε゜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>runtime系列之（5）runtime黑魔法Method swizzling</title>
    <link href="http://yoursite.com/2018/06/15/runtime%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%885%EF%BC%89runtime%E9%BB%91%E9%AD%94%E6%B3%95Method%20swizzling/"/>
    <id>http://yoursite.com/2018/06/15/runtime系列之（5）runtime黑魔法Method swizzling/</id>
    <published>2018-06-15T06:16:20.000Z</published>
    <updated>2018-06-20T10:48:35.259Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-653301.jpg" alt=""></p><p>您将了解到：</p><ul><li>Method swizzling原理</li><li>Method swizzling应用</li><li>Method swizzling类簇</li></ul><a id="more"></a><h2 id="从需求开始说起："><a href="#从需求开始说起：" class="headerlink" title="从需求开始说起："></a>从需求开始说起：</h2><p>例如：我们想要在一款iOS APP中追踪每一个视图控制器被用户呈现了几次，我们可能会想到以下几种方式：<br><strong>手动添加</strong><br>直接简单粗暴的在每个视图控制器的viewDidAppear:方法中添加追踪代码来实现，但这样会大量重复的样板代码，消耗时间，难以维护。</p><p><strong>继承</strong><br>继承是另一种可行方式，但是这要求所有被继承的视图控制器如<code>UIViewController</code>，<code>UITableViewController</code>，<code>UINavigationController</code>都在<code>viewDidAppear:</code>实现追踪代码，这同样会定制性差，造成很多重复代码。</p><p><strong>Category</strong><br>我们可以为<code>UIViewController</code>建一个<code>Category</code>，然后在所有控制器中引入这个<code>Category</code>。当然我们也可以添加一个<code>PCH</code>文件，然后将这个<code>Category</code>添加到<code>PCH</code>文件中。</p><p>我们创建一个<code>Category</code>来覆盖系统方法，系统会优先调用<code>Category</code>中的代码，然后再调用原类中的代码。</p><p>伪代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"UIViewController+EventGather.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">EventGather</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"页面统计:%@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>Method swizzling</strong><br>可以使用苹果的“黑魔法”<code>Method swizzling</code>。<code>Method swizzling</code>本质上就是对<code>IMP</code>和<code>SEL</code>进行交换。</p><h2 id="Method-swizzling原理"><a href="#Method-swizzling原理" class="headerlink" title="Method swizzling原理"></a>Method swizzling原理</h2><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是<code>selector</code>的名字。利用Objective-C的动态特性，可以实现在运行时偷换<code>selector</code>对应的方法实现。如何实现，就是接下来要说的Objective-C的运行时最具争议的黑魔法：<code>method swizzling</code>。</p><p><code>Method swizzling</code>用于改变一个已经存在的<code>selector</code>的实现。这项技术使得在运行时通过改变<code>selector</code>在类的消息分发列表中的映射从而改变方法的调用成为可能。</p><p>通过两张图片来了解一下<code>Method swizzling</code>的实现原理：<br><img src="http://p9u62mso1.bkt.clouddn.com/r_method%20swizzling01.png" alt="交换前"><br><img src="http://p9u62mso1.bkt.clouddn.com/r_method%20swizzling02.png" alt="交换后"></p><p><code>method swizzling</code>没有作用前，图一中的<code>selector</code>原本对应着<code>IPM2</code>，但是为了实现特定也无需求，我们在图二中添加了<code>selector2</code>和<code>IMP3</code>，并且让<code>selector2</code>指向了<code>IMP3</code>，而<code>selector3</code>则指向了<code>IMP2</code>，这样就实现了“方法互换”。</p><p>在OC语言的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的<code>SEL</code>，这个<code>SEL</code>对应着一个<code>IMP</code>(一个IMP可以对应多个SEL)，通过这个<code>IMP</code>找到对应的方法调用。</p><p>在每个类中都有一个<code>Dispatch Table</code>，这个<code>Dispatch Table</code>本质是将类中的<code>SEL</code>和<code>IMP</code>(可以理解为函数指针)进行对应。而我们的<code>Method Swizzling</code>就是对这个table进行了操作，让<code>SEL</code>对应另一个<code>IMP</code>。</p><h2 id="Method-swizzling应用"><a href="#Method-swizzling应用" class="headerlink" title="Method swizzling应用"></a>Method swizzling应用</h2><p>例：如上面提到的追踪视图控制器被访问的次数统计，先给UIViewController添加一个Category，然后在Category中的<code>+ (void)load</code>方法中添加<code>Method swizzling</code>方法，我们用来替换的方法也写在这个Category中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"UIViewController+Tracking.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当交换的是类方法时，使用如下：</span></span><br><span class="line">        <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Method originalMethod = class_getClassMethod(class, originalSelector);</span></span><br><span class="line">        <span class="comment">// Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="如何使用Method-swizzling"><a href="#如何使用Method-swizzling" class="headerlink" title="如何使用Method swizzling"></a>如何使用Method swizzling</h2><h4 id="void-load-vs-void-initialize"><a href="#void-load-vs-void-initialize" class="headerlink" title="+(void)load; vs +(void)initialize;"></a>+(void)load; vs +(void)initialize;</h4><p><strong>swizzling应该只在+(void)load;中完成</strong>。在Objective-C的运行时中，每个类有两个方法都会自动调用，<code>+(void)load;</code>是在一个类被初始装载时调用，<code>+(void)initialize;</code>是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。</p><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p><strong>swizzling应该只在dispatch_once中完成</strong>。由于swizzling改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。在<code>dispatch_once</code>中执行Method swizzling是一种防护措施，以保证代码块只会被执行一次并且线程安全。</p><h4 id="Selector，Methods，-amp-Implementations"><a href="#Selector，Methods，-amp-Implementations" class="headerlink" title="Selector，Methods，&amp; Implementations"></a>Selector，Methods，&amp; Implementations</h4><p>在 Objective-C 的运行时中，<code>selectors</code>, <code>methods</code>, <code>implementations</code>指代了不同概念，然而我们通常会说在消息发送过程中，这三个概念是可以相互转换的。</p><p>理解<code>selector</code>, <code>methods</code>, <code>implementation</code>这三个概念之间关系的最好方式是：在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。</p><h4 id="调用-cmd"><a href="#调用-cmd" class="headerlink" title="调用 _cmd"></a>调用 _cmd</h4><p>下面代码在正常情况下会出现循环：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而在交换了方法实现后就不会出现循环了。在交换了方法的实现后，<code>xxx_viewWillAppear:</code>方法的实现已经被替换为UIViewController <code>-viewWillAppear:</code>的原生实现，所以这里并不是在递归调用。</p><p>由于 <code>xxx_viewWillAppear:</code> 这个方法的实现已经被替换为了 <code>viewWillAppear:</code> 的实现，所以，当我们在这个方法中再调用 <code>viewWillAppear:</code> 时便会造成递归循环。</p><h2 id="Method-swizzling类簇"><a href="#Method-swizzling类簇" class="headerlink" title="Method swizzling类簇"></a>Method swizzling类簇</h2><p>在项目开发过程中，经常因为<code>NSArray</code>数组越界或者<code>NSDictionary</code>的<code>key</code>或者<code>value</code>值为<code>nil</code>等问题导致的崩溃，对于这些问题苹果并不会报一个警告，而是直接崩溃。</p><p>由此，我们可以根据上面对<code>Method swizzling</code>的了解，对<code>NSArray</code>，<code>NSMutableArray</code>，<code>NSDictionary</code>，<code>NSMutableDictionary</code>等类进行<code>Method swizzling</code>，实现方式还是按照上面的例子来做。但是…发现<code>Method swizzling</code>根本不起作用，这是为什么呢？</p><p>这是因为<code>Method swizzling</code>对<code>NSArray</code>这些<strong>类簇</strong>是不起作用的，因为这些类簇类，其实是一种<strong>抽象工厂的设计模式</strong>。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用<code>NSArray</code>的<code>objectAtIndex:</code>方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。</p><p>所以也就是我们对<code>NSArray</code>类进行操作其实只是对父类进行了操作，在<code>NSArray</code>内部会创建其他子类来执行操作，真正执行操作的并不是<code>NSArray</code>自身，所以我们应该对其<strong>“真身”</strong>进行操作。</p><p><strong>下面我们实现了防止NSArray因为调用objectAtIndex:方法，取下标时数组越界导致的崩溃：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"NSArray+SafeArray.h"</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> NSArray (SafeArray)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    [<span class="keyword">super</span> load];</span><br><span class="line">    </span><br><span class="line">    Class <span class="class"><span class="keyword">class</span> = <span class="title">objc_getClass</span></span>(<span class="string">"__NSArrayI"</span>);</span><br><span class="line">    </span><br><span class="line">    SEL fromSelector = <span class="meta">@selector(objectAtIndex:)</span>;</span><br><span class="line">    SEL toSelector = <span class="meta">@selector(safe_objectAtIndex:)</span>;</span><br><span class="line">    </span><br><span class="line">    Method fromMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">fromSelector);</span></span></span><br><span class="line">    Method toMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">toSelector);</span></span></span><br><span class="line">    </span><br><span class="line">    BOOL didAddMethod = class_addMethod(<span class="class"><span class="keyword">class</span>, <span class="type">fromSelector</span>, <span class="type">method_getImplementation</span></span>(toMethod), method_getTypeEncoding(toMethod));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">toSelector</span>, <span class="type">method_getImplementation</span></span>(fromMethod), method_getTypeEncoding(fromMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)safe_objectAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.count<span class="number">-1</span> &lt; index) &#123;</span><br><span class="line">        <span class="meta">@try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [self safe_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@catch</span> (NSException *exception) &#123;</span><br><span class="line">            NSLog(@<span class="string">"------ %s Crash Because Method %s ------\n"</span>, class_getName(self.<span class="keyword">class</span>), __func__);</span><br><span class="line">            NSLog(@<span class="string">"%@"</span>, [exception callStackSymbols]);</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@finally</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [self safe_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><p>我们发现<code>__NSArrayI</code>才是<code>NSArray</code>真正的类<br>下面列举一些常用的类簇的<strong>“真身”</strong>：</p><table><thead><tr><th>类</th><th>“真身”</th></tr></thead><tbody><tr><td>NSArray</td><td>__NSArrayI</td></tr><tr><td>NSMutableArray</td><td>__NSArrayM</td></tr><tr><td>NSDictionary</td><td>__NSDictionaryI</td></tr><tr><td>NSMutableDictionary</td><td>__NSDictionaryM</td></tr></tbody></table><p><strong>下面这个示例是 通过交换NSMutableDictionary的setObject:forKey:方法，让调用这个方法时当参数object或key为空时不会抛出异常导致程序崩溃</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSMutableDictionary+SafeMutableDictionary.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableDictionary</span> (<span class="title">SafeMutableDictionary</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class originalClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"__NSDictionaryM"</span>);</span><br><span class="line">        Class swizzledClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(setObject:forKey:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(safe_setObject:forKey:);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        IMP originalIMP = method_getImplementation(originalMethod);</span><br><span class="line">        IMP swizzledIMP = method_getImplementation(swizzledMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *originalType = method_getTypeEncoding(originalMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *swizzledType = method_getTypeEncoding(swizzledMethod);</span><br><span class="line">        </span><br><span class="line">        class_replaceMethod(originalClass,swizzledSelector,originalIMP,originalType);</span><br><span class="line">        class_replaceMethod(originalClass,originalSelector,swizzledIMP,swizzledType);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)safe_setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>)aKey &#123;</span><br><span class="line">    <span class="keyword">if</span> (anObject &amp;&amp; aKey) &#123;</span><br><span class="line">        [<span class="keyword">self</span> safe_setObject:anObject forKey:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> safe_setObject:anObject forKey:aKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"------ %s Crash Because Method %s ------\n"</span>, class_getName(<span class="keyword">self</span>.class), __func__);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [exception callStackSymbols]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (aKey) &#123;</span><br><span class="line">                [(<span class="built_in">NSMutableDictionary</span> *)<span class="keyword">self</span> removeObjectForKey:aKey];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在Method-swizzling之后如何恢复？"><a href="#在Method-swizzling之后如何恢复？" class="headerlink" title="在Method swizzling之后如何恢复？"></a>在Method swizzling之后如何恢复？</h2><p>首先来看一下使用<code>Method swizzling</code>最核心的其实也只做了两件事情：</p><ul><li><code>class_addMethod</code>添加一个新的方法, 可能是把其它类中实现的方法添加到目标类中, 也可能是把父类实现的方法添加一份在子类中, 可能是添加的实例方法, 也可能是添加的类方法, 总之就是添加了方法.</li><li>交换<code>IMP</code>,交换方法的实现<code>IMP</code>,完成这个步骤除了使用<code>method_exchangeImplementations</code>这个方法外, 也可以是调用了<code>method_setImplementation</code>方法来单独修改某个方法的<code>IMP</code>, 或者是采用在调用<code>class_addMethod</code>方法中设定了<code>IMP</code>而直接就完成了<code>IMP</code>的交换, 总之就是对<code>IMP</code>的交换.</li></ul><p>那我们来分别看一下这两件事情是否都还能恢复:</p><ul><li>对于<code>class_addMethod</code>, 我们首先想到的可能就是有没有对应的<code>remove</code>方法呢, 在Objective-C 1.0的时候有<code>class_removeMethods</code>这个方法, 不过在2.0的时候就已经被禁用了, 也就是苹果并不推荐我们这样做, 想想似乎也是挺有道理的, 本来runtime的接口看着就挺让人心惊胆战的, 又是添加又是删除总觉得会出岔子, 所以只能放弃remove的想法, 反正方法添加在那儿倒也没什么太大的影响.</li><li>针对<code>IMP</code>的交换, 在<code>Method Swizzling</code>时做的交换动作, 如果需要恢复其实要做的动作还是交换回来罢了, 所以是可以做到的, 不过需要怎样做呢? 对于同一个类, 同一个方法, 可能会在不同的地方被多次做<code>Method Swizzling</code>, 所以要回退某一次的<code>Method Swizzling</code>, 我们就需要记录下来这一次交换的时候是哪两个<code>IMP</code>做了交换, 恢复的时候再换回来即可. 另一个问题是如果已经经过多次交换, 我们怎样找到这两个<code>IMP</code>所对应的<code>Method</code>呢, 还好runtime提供了一个<code>class_copyMethodList</code>方法, 可以直接取出<code>Method</code>列表, 然后我们就可以逐个遍历找到<code>IMP</code>所对应的<code>Method</code>了, 下面是对上一个示例添加恢复之后实现的代码逻辑:</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import @interface MySafeDictionary : NSObject</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSLock</span> *kMySafeLock = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> IMP kMySafeOriginalIMP = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> IMP kMySafeSwizzledIMP = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MySafeDictionary</span></span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)swizzlling &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        kMySafeLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    [kMySafeLock lock];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (kMySafeOriginalIMP || kMySafeSwizzledIMP) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        Class originalClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"__NSDictionaryM"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!originalClass) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        Class swizzledClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(setObject:forKey:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(safe_setObject:forKey:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(originalClass, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector);</span><br><span class="line">        <span class="keyword">if</span> (!originalMethod || !swizzledMethod) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        IMP originalIMP = method_getImplementation(originalMethod);</span><br><span class="line">        IMP swizzledIMP = method_getImplementation(swizzledMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *originalType = method_getTypeEncoding(originalMethod);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *swizzledType = method_getTypeEncoding(swizzledMethod);</span><br><span class="line">         </span><br><span class="line">        kMySafeOriginalIMP = originalIMP;</span><br><span class="line">        kMySafeSwizzledIMP = swizzledIMP;</span><br><span class="line">         </span><br><span class="line">        class_replaceMethod(originalClass,swizzledSelector,originalIMP,originalType);</span><br><span class="line">        class_replaceMethod(originalClass,originalSelector,swizzledIMP,swizzledType);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">NO</span>);</span><br><span class="line">     </span><br><span class="line">    [kMySafeLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)restore &#123;</span><br><span class="line">    [kMySafeLock lock];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!kMySafeOriginalIMP || !kMySafeSwizzledIMP) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        Class originalClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"__NSDictionaryM"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!originalClass) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        Method originalMethod = <span class="literal">NULL</span>;</span><br><span class="line">        Method swizzledMethod = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">        Method *methodList = class_copyMethodList(originalClass, &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> idx=<span class="number">0</span>; idx &lt; outCount; idx++) &#123;</span><br><span class="line">            Method aMethod = methodList[idx];</span><br><span class="line">            IMP aIMP = method_getImplementation(aMethod);</span><br><span class="line">            <span class="keyword">if</span> (aIMP == kMySafeSwizzledIMP) &#123;</span><br><span class="line">                originalMethod = aMethod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aIMP == kMySafeOriginalIMP) &#123;</span><br><span class="line">                swizzledMethod = aMethod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尽可能使用exchange,因为它是atomic的</span></span><br><span class="line">        <span class="keyword">if</span> (originalMethod &amp;&amp; swizzledMethod) &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (originalMethod) &#123;</span><br><span class="line">            method_setImplementation(originalMethod, kMySafeOriginalIMP);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (swizzledMethod) &#123;</span><br><span class="line">            method_setImplementation(swizzledMethod, kMySafeSwizzledIMP);</span><br><span class="line">        &#125;</span><br><span class="line">        kMySafeOriginalIMP = <span class="literal">NULL</span>;</span><br><span class="line">        kMySafeSwizzledIMP = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">NO</span>);</span><br><span class="line">     </span><br><span class="line">    [kMySafeLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)safe_setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>)aKey &#123;</span><br><span class="line">    <span class="keyword">if</span> (anObject &amp;&amp; aKey) &#123;</span><br><span class="line">        [<span class="keyword">self</span> safe_setObject:anObject forKey:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aKey) &#123;</span><br><span class="line">        [(<span class="built_in">NSMutableDictionary</span> *)<span class="keyword">self</span> removeObjectForKey:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 这段代码的Method Swizzling和恢复都需要主动调用, 并且相比上面其它的示例, 这段代码还添加如锁机制来加之保护. 这个示例是以不同的类来实现的Method Swizzling和恢复, 如果是Category或者是类方法, 根据之前的示例也需要做相应的调整.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-653301.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;您将了解到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Method swizzling原理&lt;/li&gt;
&lt;li&gt;Method swizzling应用&lt;/li&gt;
&lt;li&gt;Method swizzling类簇&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>runtime系列之（4）@property</title>
    <link href="http://yoursite.com/2018/06/10/runtime%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%884%EF%BC%89@property/"/>
    <id>http://yoursite.com/2018/06/10/runtime系列之（4）@property/</id>
    <published>2018-06-10T13:16:23.000Z</published>
    <updated>2018-06-15T08:43:00.500Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-542410.jpg" alt=""></p><a id="more"></a><h2 id="property修饰符"><a href="#property修饰符" class="headerlink" title="@property修饰符"></a>@property修饰符</h2><ul><li>atomic nonatomic</li><li>readwrite readonly</li><li>retain</li><li>assign</li><li>copy</li><li>strong</li><li>weak</li><li>unsafe_unretained</li><li>autoreleasing</li><li>setter getter</li></ul><p><strong>atomic nonatomic</strong><br><code>atomic</code>（默认参数）：原子性，性能低（一般开发OC中的APP不推荐使用，做金融等要求高安全的时候使用）</p><p>（原子性操作），会被加锁，就是一个操作执行过程不能被中断，要不就执行完，要不就不执行（一个操作不可以在中途被CPU暂停然后调度）。如果一个操作是原子性的，那么在多线程环境下，就不会出现变量被修改等奇怪的问题（保证数据同步）。原子操作就是不可再分的操作，在多线程程序中原子操作是一个非常重要的概念，它常常用来实现一些同步机制，同时也是一些常见的多线程bug的源头。</p><p><code>nonatomic</code>：非原子性，性能高（推荐使用，性能高）</p><p>（非原子性操作）操作是直接从内存中取数值（不考虑其是否被占用）。在多线程环境下可能提高性能，但无法保证数据同步。</p><p><strong>readwrite readonly</strong><br><code>readwrite</code>是编译器的默认选项，便是自动生成<code>getter</code>和<code>setter</code>，如果需要<code>getter</code>和<code>setter</code>不写即可。<br><code>readonly</code>表示只会合成<code>getter</code>而不合成<code>setter</code>。</p><p><strong>assign weak unsafe_unretained</strong><br><code>assign</code>表示对属性只进行简单的赋值操作，不更改所赋值的引用计数，也不改变旧的引用计数，常用于标量类型，如<code>NSInteger</code> <code>NSUInteger</code> <code>CGFloat</code> <code>NSTimerInterval</code>等。</p><p><code>assign</code>也可以修饰对象如<code>NSString</code>等类型对象，上面说过使用<code>assign</code>修饰不会更改所赋的新值的引用计数，也不改变旧值的引用计数，如果当所赋的新值引用计数为0对象被销毁时属性并不知道，编译器不会将该属性置为<code>nil</code>，指针仍旧指向之前被销毁的内存，这时访问该属性会产生野指针错误并崩溃，因此使用<code>assign</code>修饰的类型一定要为标量类型。</p><p>使用<code>weak</code>修饰的时候同样不会增加所赋新值的引用计数，也不会减少旧值的引用计数，但当该值被销毁时，<code>weak</code>修饰的属性会被自动赋值为<code>nil</code>，这样就可以避免野指针错误。</p><p>使用<code>unsafe_unretained</code>修饰时效果与<code>assign</code>相同，不会增加引用计数，当所赋的值被销毁时不会被置为<code>nil</code>可能会发生野指针错误。<code>unsafe_unretained</code>与<code>assign</code>的区别在于，<code>unsafe_unretained</code>只能修饰对象，不能修饰标量类型，而<code>assign</code>两者均可修饰。</p><p><strong>strong weak</strong><br><code>strong</code>表示属性对所赋的值持有强引用表示一种“拥有关系”（owing relationship），会先保留新值即增加新值的引用计数，然后再释放旧值即减少旧值的引用计数。只能修饰对象。如果对一些对象需要保持强引用则使用<code>strong</code>。</p><p><code>weak</code>表示对所赋的值对象持有弱引用表示一种“非拥有关系”(nonowning relationship)，对新值不会增加引用计数，也不会减少旧值的引用计数。所赋的值在引用计数为0被销毁后，<code>weak</code>修饰的属性会被自动置为<code>nil</code>能够有效防止野指针错误。<br><code>weak</code>常用在修饰<code>delegate</code>等防止循环引用的场景。</p><p><strong>copy</strong><br><code>copy</code>修饰的属性会在内存里拷贝一份对象，两个指针指向不同的内存地址。<br>一般用来修饰有对应可变类型子类的对象。<br>如：<code>NSString/NSMutableString</code> <code>NSArray/NSMutableArray</code> <code>NSDictionary/NSMutableDictionary</code>等。<br>为确保这些不可变对象因为可变子类对象影响，需要<code>copy</code>一份备份，如果不使用<code>copy</code>修饰，使用<code>strong</code>或者<code>assign</code>等修饰则会因为多态导致属性值被修改。<br>这里的<code>copy</code>还牵扯到<code>NSCopying</code>和<code>NSMutableCopying</code>协议。</p><p><code>copy</code>还被用来修饰<code>block</code>，在ARC环境下编译器默认会用<code>copy</code>修饰，一般情况下在<code>block</code>需要捕获外界数据时该<code>block</code>就会被分配在堆区，但在MRC环境下由于手动管理引用计数，<code>block</code>一般被分配在栈区，需要<code>copy</code>到堆区来防止野指针错误。有一个栗子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用copy修饰NSMutableString</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableString</span>* name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name = _name;</span><br><span class="line"><span class="keyword">@synthesize</span> age = _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        <span class="built_in">NSMutableString</span> *s = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"Jiaming Chen"</span>];</span><br><span class="line">        <span class="comment">//将可变字符串赋值给p.name</span></span><br><span class="line">        p.name = s;</span><br><span class="line">        <span class="comment">//输出的地址不一致，内容一致</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p %p %@ %@"</span>, p.name, s, p.name, s);</span><br><span class="line">        <span class="comment">//修改p.name，此时抛出异常</span></span><br><span class="line">        [p.name appendString:<span class="string">@" is a good guy."</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的栗子使用<code>copy</code>修饰可变对象，在进行赋值的时候会通过<code>copy</code>方法获取一个不可变对象，因此<code>p.name</code>的地址和<code>s</code>的地址不同，而<code>p.name</code>运行时类型为<code>NSString</code>，调用<code>appendString:</code>方法会抛出异常。</p><p>所以，针对不可变对象使用<code>copy</code>修饰，针对可变对象使用<code>strong</code>修饰。</p><p><strong>retain</strong><br>在ARC环境下使用较少，在MRC下使用效果与<code>strong</code>一致。</p><h2 id="copy题外话"><a href="#copy题外话" class="headerlink" title="copy题外话"></a>copy题外话</h2><p>有时候我们需要<code>copy</code>一个对象，或是<code>mutableCopy</code>一个对象，这时需要遵守<code>NSCopying</code>和<code>NSMutableCopying</code>协议，来实现<code>copyWithZone:</code>和<code>mutableCopyWithZone:</code>两个方法，而不是重写<code>copy</code>和<code>mutableCopy</code>两个方法。</p><p>Foundation框架中的很多数据类型已经帮我们实现了上述两个方法，因此我们可以使用<code>copy</code>方法和<code>mutableCopy</code>方法来复制一个对象，两者的区别在于<code>copy</code>的返回值仍未不可变对象，<code>mutableCopy</code>的返回值为可变对象。</p><table><thead><tr><th>type</th><th>copy</th><th>mutableCopy</th></tr></thead><tbody><tr><td>NS*</td><td>浅拷贝，只拷贝指针，地址相同</td><td>单层深拷贝，拷贝内容，地址不同</td></tr><tr><td>NSMutable*</td><td>单层深拷贝，拷贝内容，地址不同</td><td>单层深拷贝，拷贝内容，地址不同</td></tr></tbody></table><p>对于不可变类型，使用<code>copy</code>方法时是浅拷贝，只拷贝指针，因为内容是不会变化的。使用<code>mutableCopy</code>时由于返回可变对象因此需要一份拷贝，供其他对象使用。对于可变类型，不管是<code>copy</code>还是<code>mutableCopy</code>均会进行深拷贝，所指向指针不同。</p><p>前文介绍<code>copy</code>修饰符的时候讲过，在修饰<code>NSString</code>这样的不可变对象的时候使用<code>copy</code>修饰，但其实当给对象赋一个<code>NSString</code>时仍旧只复制了指针而不是拷贝内容，原因同上。</p><h2 id="与-property相关的问题"><a href="#与-property相关的问题" class="headerlink" title="与@property相关的问题"></a>与@property相关的问题</h2><h3 id="1-property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"><a href="#1-property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？" class="headerlink" title="1. @property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"></a>1. @property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？</h3><p><strong>@property本质是什么？</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>= ivar + getter + setter</span><br></pre></td></tr></table></figure><p>下面解释下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">”属性”（<span class="keyword">property</span>）有两大概念：ivar（实例变量）、存取方法（access <span class="function"><span class="keyword">method</span> = <span class="title">getter</span> + <span class="title">setter</span>）</span></span><br></pre></td></tr></table></figure><p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。</p><p>而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。<br>正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p><blockquote><p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。<br>所以你也可以这么说：<br>@property = getter + setter;</p></blockquote><p>例如下面这个类：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> NSString *firstNamel;</span><br><span class="line"><span class="variable">@property</span> NSString *lastNamel;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>上述代码写出来的类与下面这种写法等效：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="built_in">NSString</span> *)firstName;</span><br><span class="line">- (<span class="keyword">void</span>)setFirstName:(<span class="built_in">NSString</span> *)firstName;</span><br><span class="line">- (<span class="built_in">NSString</span> *)lastName;</span><br><span class="line">- (<span class="keyword">void</span>)setLastName:(<span class="built_in">NSString</span> *)lastName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>ivar、getter、setter是如何生成并添加到这个类中的？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“自动合成”（autosynthesis）</span><br></pre></td></tr></table></figure><p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为<code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过<code>@synthesize</code> 语法来指定实例变量的名字.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> Person</span><br><span class="line"><span class="variable">@synthesize</span> firstName = _myFirstName;</span><br><span class="line"><span class="variable">@synthesize</span> lastName = _myLastName;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>属性是怎么生成的？增加一个属性，底层大致生成五个东西：</p><ol><li><code>OBJC_IVAR_$类名$属性名</code>：该属性的“偏移量“（offset），这个偏移量是”硬编码“（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。</li><li><code>getter</code>和<code>setter</code>方法对应的实现函数</li><li><code>ivar_list</code>：成员变量列表</li><li><code>method_list</code>：方法列表</li><li><code>prop_list</code>：属性列表</li></ol><p>也就是说我们每次在增加一个属性，系统都会在ivar_list中添加一个成员变量的描述，在method_list中增加setter和getter方法的描述，在属性列表中增加一个属性的描述，然后计算该属性在对象中的偏移量，然后给出setter与getter方法对应的实现，在setter方法中从偏移量的位置开始赋值，在getter方法中从偏移量的开始取值，为了能够读取正确字节数，系统对象偏移量的指针类型进行了强转。</p><h3 id="2-property中有哪些属性关键字？（或-property后面可以有哪些修饰符？）"><a href="#2-property中有哪些属性关键字？（或-property后面可以有哪些修饰符？）" class="headerlink" title="2. @property中有哪些属性关键字？（或@property后面可以有哪些修饰符？）"></a>2. @property中有哪些属性关键字？（或@property后面可以有哪些修饰符？）</h3><p>属性可以拥有的特质分为四类：<br>1、原子性 — <code>nonatomic</code>特质<br>2、读写权限 — <code>readwrite</code> <code>readonly</code><br>3、内存管理语义 — <code>assign</code> <code>strong</code> <code>weak</code> <code>unsafe_unretained</code> <code>copy</code><br>4、方法名 — <code>getter=&lt;name&gt;</code> <code>setter=&lt;name&gt;</code></p><p><code>getter=&lt;name&gt;</code>的样子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isOn) <span class="built_in">BOOL</span> on;</span><br></pre></td></tr></table></figure><p>（<code>setter=&lt;name&gt;</code>这种不常用，也不推荐使用）<br>5、不常用的：<code>nonnull</code>，<code>null_resettable</code>，<code>nullable</code></p><h3 id="3-什么情况下使用weak关键字，相比assign有什么不同？"><a href="#3-什么情况下使用weak关键字，相比assign有什么不同？" class="headerlink" title="3. 什么情况下使用weak关键字，相比assign有什么不同？"></a>3. 什么情况下使用weak关键字，相比assign有什么不同？</h3><p>什么情况下使用<code>weak</code>关键字？</p><ol><li>在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用<code>weak</code>来解决，比如：<code>delegate</code>代理属性</li><li>自身已经对它进行一次强引用，没必要再强引用一次，此时也会使用<code>weak</code>，自定义<code>IBOutlet</code>控件属性一般也使用<code>weak</code>；当然，也可以使用<code>strong</code>。</li></ol><p>不同点：</p><ol><li><code>weak</code>此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同<code>assign</code>类似，然而在属性所指的对象遭到销毁时，属性值也会清空(nil out)。<br> 而<code>assign</code>的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或<br> NSlnteger 等)的简单赋值操作。属性所指的对象销毁时，编译器不会将该属性置为<code>nil</code>，指针仍    旧指向之前被销毁的内存，这时访问该属性会产生野指针错误并崩溃，</li><li>assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</li></ol><h3 id="4-怎么用copy关键字？"><a href="#4-怎么用copy关键字？" class="headerlink" title="4. 怎么用copy关键字？"></a>4. 怎么用copy关键字？</h3><ol><li><code>NSString/NSArray/NSDictiony</code>等等经常使用<code>copy</code>关键字，是因为它们有对应的可变类型：<code>NSMutableString/NSMutableArray/NSMutableDictionary</code>;</li><li><code>block</code>也经常使用<code>copy</code>关键字<br> <code>block</code>使用<code>copy</code>是从MRC遗留下来的“传统”，在MRC中，方法内部的<code>block</code>是在栈区的，使用<code>copy</code>可以把它放到堆区。在ARC中写不写都行：对于<code>block</code>使用<code>copy</code>还是<code>strong</code>效果是一样的，但写上<code>copy</code>也无伤大雅，还能时刻提醒我们：编译器自动对<code>block</code>进行了<code>copy</code>操作。如果不写<code>copy</code>，该类的调用者有可能会忘记或者根本不知道“编译器会自动对<code>block</code>进行了<code>copy</code>操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</li></ol><p>下面做解释：<br><code>copy</code>此特质所表达的所属关系与<code>strong</code>类似。然而设置方法并不保留新值，而是将其“拷贝”（copy）。<br>当属性类型为<code>NSString</code>时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个<code>NSMutableString</code>类的实例。这个类是<code>NSString</code>的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这是就要拷贝一份“不可变”（immutable）的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的“（mutable），就应该在设置新值时拷贝一份。</p><blockquote><p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote><h3 id="5-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#5-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="5. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>5. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><ol><li>因为父类指针可以指向子类对象，使用<code>copy</code>的目的是为了让本对象的属性不受外界影响，使用<code>copy</code>无论给我传入是一个可变对象还是不可变对象，我本身持有的就是一个不可变的副本。</li><li>如果我们使用是<code>strong</code>，那么这个属性就有可能指向一个可变对象，如果这个可变对象在外部被修改了，那么会影响该属性。</li></ol><p><code>copy</code>此特质所表达的所属关系与<code>strong</code>类似。然而设置方法并不保留新值，而是将其”拷贝“（copy）。<br><code>copy</code> 此特质所表达的所属关系与<code>strong</code>类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为<code>NSString</code>时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 <code>NSMutableString</code>类的实例。这个类是<code>NSString</code>的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p><p>举例说明：</p><p>定义一个以strong修饰的array：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *marray;</span><br></pre></td></tr></table></figure><p>然后进行下面的操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">self</span>.marray = mutableArray;</span><br><span class="line">    [mutableArray removeAllObjects];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.marray);</span><br><span class="line">    </span><br><span class="line">    [mutableArray addObjectsFromArray:array];</span><br><span class="line">    <span class="keyword">self</span>.marray = [mutableArray <span class="keyword">copy</span>];</span><br><span class="line">    [mutableArray removeAllObjects];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.marray);</span><br></pre></td></tr></table></figure><p>打印结果如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">2018-06-15</span> <span class="selector-tag">15</span><span class="selector-pseudo">:35</span><span class="selector-pseudo">:43.292506+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[49185:2440314]</span> (</span><br><span class="line">)</span><br><span class="line"><span class="selector-tag">2018-06-15</span> <span class="selector-tag">15</span><span class="selector-pseudo">:35</span><span class="selector-pseudo">:43.292805+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[49185:2440314]</span> (</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为了理解这种做法，首先要知道，两种情况：</p><ol><li>对<strong>非集合类对象</strong>的<code>copy</code>与<code>mutableCopy</code>操作</li><li>对<strong>集合类对象</strong>的<code>copy</code>与<code>mutableCopy</code>操作</li></ol><p><strong>1. 对非集合类对象的copy与mutableCopy操作</strong></p><p>在非集合类对象中：对immutable对象进行copy操作，是指针复制，mutableCopy操作时时内容复制；<br>对mutable对象进行copy和mutableCopy都是内容复制。用代码简单表示为：</p><ul><li>[immutableObject copy]    //浅复制</li><li>[immutableObject mutableCopy]//深复制</li><li>[mutableObject copy]    //深复制</li><li>[mutableObject mutableCopy]//深复制</li></ul><p>比如以下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"origin"</span>];<span class="comment">//copy</span></span><br><span class="line"><span class="built_in">NSString</span> *stringCopy = [string <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure><p>查看内存，会发现<code>string</code>，<code>stringCopy</code>内存地址都不一样，说明此时都是做了内容拷贝、深拷贝。即使你进行如下操作：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name"><span class="builtin-name">string</span></span> appendString:@<span class="string">"origion!"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>stringCopy</code>的值也不会因此改变，但是如果不使用<code>copy</code>，<code>stringCopy</code>的值就会被改变。</p><p>集合类对象以此类推。</p><p>所以，</p><blockquote><p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p></blockquote><p><strong>2. 对集合类对象的copy与mutableCopy操作</strong></p><p>集合类对象是指<code>NSArray</code>、<code>NSDictory</code>、<code>NSSet</code>…之类的对象。下面先看集合类<code>immutable</code>对象使用<code>copy</code>和<code>mutableCopy</code>的一个例子：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSArray</span> *array = @[@[@<span class="string">"a"</span>, @<span class="string">"b"</span>], @[@<span class="string">"c"</span>, @<span class="string">"d"</span>]];</span><br><span class="line"><span class="symbol">NSArray</span> *copyArray = [array copy];</span><br><span class="line"><span class="symbol">NSMutableArray</span> *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure><p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObjects:[<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"a"</span>],<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *copyArray = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mCopyArray = [array mutableCopy];</span><br></pre></td></tr></table></figure><p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p><p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">immutableObject copy</span>] <span class="comment">// 浅复制</span></span><br><span class="line">[<span class="meta">immutableObject mutableCopy</span>] <span class="comment">//单层深复制</span></span><br><span class="line">[<span class="meta">mutableObject copy</span>] <span class="comment">//单层深复制</span></span><br><span class="line">[<span class="meta">mutableObject mutableCopy</span>] <span class="comment">//单层深复制</span></span><br></pre></td></tr></table></figure><p>这个代码结论与非集合类的非常相似。</p><p>##总结<br>关于@property的问题，问法比较多，但是万变不离其宗，搞清楚底层原理，迎刃而解！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-542410.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>runtime系列之（3）深入理解OC的消息和消息转发机制</title>
    <link href="http://yoursite.com/2018/06/08/runtime%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%883%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OC%E7%9A%84%E6%B6%88%E6%81%AF%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/06/08/runtime系列之（3）深入理解OC的消息和消息转发机制/</id>
    <published>2018-06-08T12:16:23.000Z</published>
    <updated>2018-06-12T09:54:38.083Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-611835.jpg" alt=""></p><p>您将了解到了<code>runtime</code>是如何通过<code>objc_msgSend</code>在运行时把方法和方法实现进行动态绑定的；<br>也将了解到runtime下动态方法解析和消息转发的机制是怎样的。</p><a id="more"></a><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>本章描述了代码的消息表达式如何转换为对<code>objc_msgSend</code>函数的调用，如何通过名字来指定一个方法，以及如何使用<code>objc_msgSend</code>函数。</p><h3 id="获得方法地址"><a href="#获得方法地址" class="headerlink" title="获得方法地址"></a>获得方法地址</h3><p>避免动态绑定的唯一办法就是取得方法的地址，并且直接象函数调用一样调用它。<br>当一个方法会被连续调用很多次，而且您希望节省每次调用方法都要发送消息的开销时，使用方法地址来调用方法就显得很有效。<br>利用NSObject类中的<code>methodForSelector:</code>方法，您可以获得一个指向方法实现的指针，并可以使用该指针直接调用方法实现。<code>methodForSelector:</code>返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型都在类型识别的考虑范围中。</p><p>下面的例子展示了怎么使用指针来调用<code>setFilled:</code>的方法实现:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[targetmethodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">1000</span>, i++ ) <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure><p>方法指针的第一个参数是接收消息的对象(<code>self</code>)，第二个参数是方法选标(<code>_cmd</code>)。这两个参数在方法中是<strong>隐藏参数</strong>，但使用函数的形式来调用方法时必须显示的给出。<br>使用<code>methodForSelector:</code>来避免动态绑定将减少大部分消息的开销，但是这只有在指定的消息被重复发送很多次时才有意义，例如上面的 for 循环。<br>注意，<code>methodForSelector:</code>是 Cocoa 运行时系统的提供的功能，而不是 Objective-C 语言本身的功 能。</p><h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>在objective-C中，消息时知道运行时才会与方法实现进行绑定的。编译器会把一个消息表达式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[receiver message]</span><br></pre></td></tr></table></figure><p>转换成一个对消息函数<code>objc_msgSend</code>的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字—即方法选标。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receive, selector)</span></span></span><br></pre></td></tr></table></figure><p>同时接收消息中的任意数目的参数:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span>(<span class="params">receive, select, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure><p>该消息函数做了动态绑定所需要的一切：<br>它首先找到选标所对应的方法实线。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实线依赖于消息接收者的类型。<br>然后将消息接受者对象（指向消息接受者对象的指针）以及方法中指定的参数传给找到的方法实现。<br>最后，将方法实现的返回值作为该函数的返回值返回。</p><blockquote><p>注意：objc_msgSend方法看起来好像返回了数据，其实objc_msgSend从不返回数据，而是你的方法在运行时方法实现被调用后才会返回数据。下面详细叙述消息发送的步骤（如下图）:</p></blockquote><p>消息框架：<br><img src="http://p9u62mso1.bkt.clouddn.com/r_runtimeMsg.gif" alt="消息框架"></p><p>这样就能解释<code>objc_msgSend</code>工作原理了，当对象收到消息时，为了匹配消息的接收者和选择子:</p><ol><li>消息函数首先根据对象的<code>isa</code>指针找到该对象所对应的类的方法列表<code>objc_method_list</code>，并从方法列表中寻找该消息对应的方法选标。如果能找到就可以直接跳转到相关的具体实现中去调用。</li><li>如果找不到，将会通过<code>super_class</code>指针沿着继承树向上去搜索，直到继承树根部（通常为NSObject类）。一旦找到了方法选标，<code>objc_msgSend</code>则以消息接收者对象为参数调用，调用该选标对应的方法实现。</li><li>如果到了继承树根部还没有找到，就会进行<strong>消息转发</strong>，还有三次机会来处理。（消息转发在下文有介绍）</li></ol><p>这就是在运行时系统中选择方法实现的方式。在面向对象编程中，一般称作<strong>方法和消息动态绑定的过程</strong>。</p><p>为了加快消息的处理过程，运行时系统通常会将使用过的方法选标和方法实现的地址放入缓存中。每个类<br>都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。消息函数会首先检查消息接收者对象<br>对应的类的缓存(理论上，如果一个方法被使用过一次，那么它很可能被再次使用)。如果在缓存中已经<br>有了需要的方法选标，则消息仅仅比函数调用慢一点点。如果程序运行了足够长的时间，几乎每个消息都<br>能在缓存中找到方法实现。程序运行时，缓存也将随着新的消息的增加而增加。</p><h3 id="使用隐藏的参数"><a href="#使用隐藏的参数" class="headerlink" title="使用隐藏的参数"></a>使用隐藏的参数</h3><p>疑问：<br>我们经常用到关键字<code>self</code>，但是<code>self</code>是如何获取当前方法的对象呢？</p><p>其实，这也是<code>runtime</code>系统的作用，<code>self</code>是在方法运行时被动态传入的。</p><p>当<code>objc_msgSend</code>找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，她还将传递两个<strong>隐藏参数</strong>：</p><ul><li>接收消息的对象（<code>self</code>所指向的内容，当前方法的对象指针）</li><li>方法选择器（<code>_cmd</code>指向的内容，当前方法的<code>SEL</code>指针）</li></ul><p>这些参数帮助方法实现获得了消息表达式的信息。它们被认为是“隐藏”的是因为它们并没有在定义方法的源代码中声明，而是在代码编译时插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p><p>这两个参数中，<code>self</code>更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p><p>这时我们可能会想到另一个关键字<code>super</code>，实际上<code>super</code>关键字接收到消息时，编译器会创建一个<code>objc_super</code>结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span> id receiver; Class <span class="class"><span class="keyword">class</span>;</span>&#125;</span><br></pre></td></tr></table></figure><p>这个结构体指明了消息应该被传递给特定的父类。<code>receiver</code>仍然是<code>self</code>本身，当我们想通过<code>[super class]</code>获取父类时，编译器其实是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给<code>objc_msgSendSuper</code>函数。只有在NSObject类中才能找到<code>class</code>方法，然后<code>class</code>方法底层被转换为<code>object_getClass()</code>，接着底层编译器将代码转换为<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。因此你会发现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这句话并不能获取父类的类型，只能获取当前类的类型名</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p><strong>消息转发机制基本分为三个步骤：</strong><br>1、动态方法解析<br>2、备用接收者<br>3、完整转发</p><p>整个消息转发流程如下图所示：</p><p><img src="http://p9u62mso1.bkt.clouddn.com/s_msgSend.png" alt=""></p><h3 id="1、所属类动态方法解析"><a href="#1、所属类动态方法解析" class="headerlink" title="1、所属类动态方法解析"></a>1、所属类动态方法解析</h3><p>首先，如果沿着继承树没有搜索到相关方法则会向接受者所属的类进行一次请求，调用所属类的类方法 <code>+resolveInstanceMethod:(实例方法)</code> 或者 <code>+resolveClassMethod:(类方法)</code>。在这个方法中，我们有机会为该未知消息新增一个”处理方法“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="selector-tag">BOOL</span>)<span class="selector-tag">resolveInstanceMethod</span><span class="selector-pseudo">:(SEL)sel</span>;</span><br><span class="line">+ (<span class="selector-tag">BOOL</span>)<span class="selector-tag">resolveClassMethod</span><span class="selector-pseudo">:(SEL)sel</span>;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"resolveInstanceMethod: %@"</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(appendString:)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicAdditonMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"resolveClassMethod: %@"</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dynamicAdditonMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dynamicAdditonMethodIMP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// viewController.m</span></span><br><span class="line"><span class="keyword">id</span> *p = [[Person alloc] init];</span><br><span class="line">[p appendString:<span class="string">@""</span>];</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-06-12</span> 14<span class="selector-pseudo">:38</span><span class="selector-pseudo">:54.461050+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[12036:607027]</span> <span class="selector-tag">resolveInstanceMethod</span>: <span class="selector-tag">appendString</span>:</span><br><span class="line">2018<span class="selector-tag">-06-12</span> 14<span class="selector-pseudo">:38</span><span class="selector-pseudo">:54.461230+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[12036:607027]</span> <span class="selector-tag">dynamicAdditonMethodIMP</span></span><br></pre></td></tr></table></figure><p>首先创建了一个Person的实例对象，一定要用<code>id</code>类型来声明，否则会在编译器就报错，因为找不到相关函数的声明（这里是appendString:）。<code>id</code>类型由于可以指向任何类型的对象，因此编译时能够找到NSString类的相关方法声明就不会报错。</p><p>由于Person类没有声明和定义<code>appendString:</code>方法，所以运行时应该会报<code>unrecognized selector</code>错误，但是并没有，因为我们重写了类方法<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>，当找不到相关实例方法的时候就会调用该类方法去询问是否可以动态添加，如果返回<code>YES</code>就会再次执行相关方法，如何给一个类动态添加一个方法，那就是调用<code>runtime</code>库中的<code>class_addMethod</code>方法，该方法原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是需要添加方法的类；<br>第二个参数是一个<code>selector</code>，也就是实例方法的名字；<br>第三个参数是一个<code>IMP</code>类型的变量也是函数实现，需要传入一个C函数，这个函数至少两个参数，一个是<code>id self</code> 一个是<code>SEL _cmd</code>；<br>第四个参数是函数类型，更多含义见：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encodings</a>；</p><h3 id="2、备用接收者"><a href="#2、备用接收者" class="headerlink" title="2、备用接收者"></a>2、备用接收者</h3><p>动态方法解析无法处理消息时，则会走备用接收者。这个<strong>备用接收者只能是一个新的对象</strong>，不能是<code>self</code>本身，否则就会出现无线循环。如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p><p><strong>Person类声明两个方法：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="string">Person :</span> NSObject</span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line">+ (Person *)hi;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><p><strong>实现在Person.m中实现新的接收对象_helper和forwardingTargetForSelector:方法：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    RuntimeMethodHelper *_helper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="comment">// 将消息交给_helper来处理</span></span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"hello"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> _helper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RuntimeMethodHelper类需要实现转发的方法：</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"RuntimeMethodHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeMethodHelper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>最后在viewController.m中调用：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id p = <span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[p hello]</span>;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-06-12</span> 16<span class="selector-pseudo">:54</span><span class="selector-pseudo">:26.113808+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[13842:768645]</span> <span class="selector-tag">forwardingTargetForSelector</span></span><br><span class="line">2018<span class="selector-tag">-06-12</span> 16<span class="selector-pseudo">:54</span><span class="selector-pseudo">:26.114031+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[13842:768645]</span> &lt;<span class="selector-tag">RuntimeMethodHelper</span>: 0<span class="selector-tag">x60400000e270</span>&gt;, 0<span class="selector-tag">x10ed5f93b</span></span><br></pre></td></tr></table></figure><h3 id="3、消息重定向"><a href="#3、消息重定向" class="headerlink" title="3、消息重定向"></a>3、消息重定向</h3><p>如果动态方法解析和备用接收者都没有处理这个消息，就只剩最后一次机会，那就是消息重定向。这个时候<code>runtime</code>会将未知消息的所有细节都封装为<code>NSInvocation</code>对象，然后调用下述方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>forwardInvocation:<span class="params">(NSInvocation *)</span>anInvocation;</span><br></pre></td></tr></table></figure><p><code>forwardInvocation:</code>消息给这个问题提供了一个更特别的，动态的解决方案：当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过<code>forwardInvocation:</code>消息通知该对象。每个对象都从 NSObject类中继承了<code>forwardInvocation:</code>方法。然而，NSObject 中的方法实现只是简单地调用了 <code>doesNotRecognizeSelector:</code>。通过实现您自己的<code>forwardInvocation:</code>方法，您可以在该方法实现中将消息转发给其它对象。</p><p>要转发消息给其他对象时，<code>forwardInvocation:</code>方法所必须做的有：</p><ul><li>决定将消息转发给谁</li><li>并且，将消息和原来的参数一块转发出去</li></ul><blockquote><p>注意：forward意思是“转寄”，forwardingTargetForSelector:和forwardInvocation:都是把消息转发给一个新的接收对象。</p></blockquote><p>这里消息可以通过<code>invokeWithTarget:</code>方法来转发：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation &#123;</span><br><span class="line">    NSLog(@<span class="string">"forwardInvocation"</span>);</span><br><span class="line">    <span class="keyword">if</span> ([RuntimeMethodHelper <span class="string">instancesRespondToSelector:</span>anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([RuntimeMethodHelper <span class="string">instancesRespondToSelector:</span>aSelector]) &#123;</span><br><span class="line">            signature = [RuntimeMethodHelper <span class="string">instanceMethodSignatureForSelector:</span>aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-06-12</span> 17<span class="selector-pseudo">:21</span><span class="selector-pseudo">:22.255362+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[14454:801341]</span> <span class="selector-tag">forwardInvocation</span></span><br><span class="line">2018<span class="selector-tag">-06-12</span> 17<span class="selector-pseudo">:21</span><span class="selector-pseudo">:22.255588+0800</span> <span class="selector-tag">getIP</span><span class="selector-attr">[14454:801341]</span> &lt;<span class="selector-tag">RuntimeMethodHelper</span>: 0<span class="selector-tag">x604000016fd0</span>&gt;, 0<span class="selector-tag">x10c80f8e9</span></span><br></pre></td></tr></table></figure><p>转发消息后的返回值将返回给原来的消息发送者。你可以返回任何类型的返回值，包括id，结构体，浮点数等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们了解到了<code>runtime</code>是如何通过<code>objc_msgSend</code>在运行时把方法和方法实现进行动态绑定的；也了解到如果沿继承树找不到<code>IMP</code>，如何进行动态方法解析和消息转发的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-611835.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;您将了解到了&lt;code&gt;runtime&lt;/code&gt;是如何通过&lt;code&gt;objc_msgSend&lt;/code&gt;在运行时把方法和方法实现进行动态绑定的；&lt;br&gt;也将了解到runtime下动态方法解析和消息转发的机制是怎样的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>runtime系列之（2）从runtime开始理解面向对象的类到面向过程的结构体</title>
    <link href="http://yoursite.com/2018/06/05/runtime%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%882%EF%BC%89%E4%BB%8Eruntime%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%88%B0%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/05/runtime系列之（2）从runtime开始理解面向对象的类到面向过程的结/</id>
    <published>2018-06-05T12:16:23.000Z</published>
    <updated>2018-06-11T03:57:07.679Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-630247.jpg" alt=""></p><p>本篇将看到runtime是如何将面向对象的类转变为面向过程的结构体的，深入理解instance、class object、metaclass的关系。</p><a id="more"></a><h3 id="从理解面向对象的类到面向过程的结构体开始"><a href="#从理解面向对象的类到面向过程的结构体开始" class="headerlink" title="从理解面向对象的类到面向过程的结构体开始"></a>从理解面向对象的类到面向过程的结构体开始</h3><p>我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体，本文正是通过<code>runtime</code>源码分析来讲解<code>runtime</code>是如何将面向对象的类转变为面向过程的结构体，探究OC对类的处理本质。</p><h3 id="深入代码理解instance、class-object、metaclass"><a href="#深入代码理解instance、class-object、metaclass" class="headerlink" title="深入代码理解instance、class object、metaclass"></a>深入代码理解instance、class object、metaclass</h3><p>面向对象编程中，最重要的概念就是类，下面我们就从代码入手，看看OC是如何实现类的。</p><p>前面一直在说runtime将面向对象的类转变为面向过程的结构体，那这个结构体到底是什么样子的？打开<code>#import&lt;objc/objc.h&gt;</code>文件，可以发现以下几行代码：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// Represents an<span class="built_in"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an<span class="built_in"> instance </span>of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>通过注释和代码不难发现，我们创建的一个对象或示例其实就是一个<code>struct objc_object</code>结构体，而我们常用的<code>id</code>也就是这个结构体的指针。有如下代码：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都成立</span></span><br><span class="line">id <span class="keyword">str</span> = [[NSString <span class="keyword">alloc</span>] init]<span class="comment">;</span></span><br><span class="line">NSString *<span class="keyword">str</span> = [[NSString <span class="keyword">alloc</span>] init]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>通过上述代码我们可以看出，我们创建的<code>NSString类</code>的实例<code>str</code>其实就是一个<code>struct objc_object</code>结构体指针，所以不管是<code>Foundation框架</code>中的类或是自定义的类，我们创建的类的实例最终获取的都是一个结构体指针，这个结构体只有一个成员变量就是<code>Class</code>类型的<code>isa</code>指针，<code>Class</code>是结构体指针，指向<code>struct objc_class</code>，那这个结构体又是什么呢？这里先透漏一句话<code>str is a NSString</code>，再加上<code>Class</code>这个指针的名字，不难猜测，这里<code>Class</code>就是代表<code>NSString</code>这个类。</p><p>接下来详细讲解<code>objc_class</code>这个结构体，现在再看另一个例子，有时我们也会通过下述方法来创建一个实例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSString</span> *str = [[<span class="symbol">NSString</span> alloc] initWithString: @<span class="string">"Hello World"</span>];</span><br><span class="line"><span class="symbol">Class</span> c = [str class];</span><br><span class="line"><span class="symbol">NSString</span> *str2 = [[c alloc] initWithString: @<span class="string">"Hello World"</span>];</span><br></pre></td></tr></table></figure><p>可能你已经发现，通过实例对象调用的<code>class</code>方法，能够获取到一个<code>Class</code>类型的变量，可以通过这个<code>Class</code>来创建相应的实例对象。</p><p>实际上，OC中的类也是一个对象，成为<code>类对象</code>，上述方法中通过<code>[str class]</code>方法获取到的就是<code>NSString类</code>的<code>类对象</code>，接着我们就可以通过这个<code>类对象</code>来创建实例对象，那这个<code>类对象</code>又是什么东西呢？打开<code>#import&lt;objc/runtime.h&gt;</code>文件，我们可以找到结构体<code>struct objc_class</code>的定义，该结构体定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件objc/runtime.h中有如下定义:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">  Class isa OBJC_ISA_AVAILABILITY; <span class="comment">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">  Class super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></span><br><span class="line">  <span class="keyword">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">  <span class="keyword">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">  <span class="keyword">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法定义的链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 协议链表</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; OBJC2_UNAVAILABLE;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  文件objc/objc.h文件中有如下定义</span><br><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure><p><code>struct objc_class</code>结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？没错，<code>类对象</code>就是一个结构体<code>struct objc_class</code>，这个结构体存放的数据称为<code>元数据(metadata)</code>，该结构体的第一个成员变量也是<code>isa</code>指针，这就说明<code>Class</code>本身其实也是一个对象，因此我们称之为<code>类对象</code>，类对象在编译期产生用于创建实例对象，是单例。</p><p><code>类对象</code>中的<code>元数据</code>存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从<code>isa</code>指针指向的结构体创建，类对象的<code>isa</code>指针指向的我们称之为<code>元类(metaclass)</code>，<code>元类</code>中保存了创建类对象以及类方法所需要的所有信息，因此整个结构应该如下图所示：</p><p><img src="http://p9u62mso1.bkt.clouddn.com/r_runtimeIsa.png" alt=""></p><p>通过上图我们可以清晰的看出来一个实例对象也就是<code>struct objc_object</code>结构体它的<code>isa</code>指针指向<code>类对象</code>，<code>类对象</code>的<code>isa</code>指针指向了<code>元类</code>，<code>类对象</code>的<code>super_class</code>指针指向了父类的<code>类对象</code>，而<code>元类</code>的<code>super_class</code>指针指向了父类的<code>元类</code>，那<code>元类</code>的<code>isa</code>指针又指向了什么？为了更清晰的表达直接借用大神的图。</p><p><img src="http://p9u62mso1.bkt.clouddn.com/r_runtimeIsaAll.png" alt=""></p><p>通过上图我们可以看出整个体系构成了一个自闭环，如果是从<code>NSObject</code>中继承而来的，上图中的<code>Root class</code>就是<code>NSObject</code>。至此，整个<code>实例</code>、<code>类对象</code>、<code>元类</code>的概念也就讲清楚了，接下来我们在代码中看看这些概念该怎么应用。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个Person类继承自NSObject</span></span><br><span class="line"></span><br><span class="line">Person *p = [[Person alloc] init]<span class="comment">;</span></span><br><span class="line"><span class="keyword">Class</span> c1 = [p <span class="keyword">class</span>]<span class="comment">;</span></span><br><span class="line"><span class="keyword">Class</span> c2 = [Person <span class="keyword">class</span>]<span class="comment">;</span></span><br><span class="line"><span class="comment">//输出 1</span></span><br><span class="line">NSLog(@<span class="string">"%d"</span>, c1 == c2)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>c1</code>是通过一个实例对象获取的<code>Class</code>，实例对象可以获取到其他<code>类对象</code>，类名作为消息的接受者时代表的是<code>类对象</code>，因此<code>类对象</code>获取<code>Class</code>得到的是其本身，同时也印证了<code>类对象</code>是一个单例的想法。</p><p>那么如果我们想获取<code>isa</code>指针的指向对象呢？</p><p>介绍两个函数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">OBJC_EXPORT</span> <span class="selector-tag">BOOL</span></span><br><span class="line"><span class="selector-tag">class_isMetaClass</span>(<span class="selector-tag">Class</span> _<span class="selector-tag">Nullable</span> <span class="selector-tag">cls</span>) </span><br><span class="line">    <span class="selector-tag">OBJC_AVAILABLE</span>(10<span class="selector-class">.5</span>, 2<span class="selector-class">.0</span>, 9<span class="selector-class">.0</span>, 1<span class="selector-class">.0</span>, 2<span class="selector-class">.0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="selector-tag">OBJC_EXPORT</span> <span class="selector-tag">Class</span> _<span class="selector-tag">Nullable</span></span><br><span class="line"><span class="selector-tag">object_getClass</span>(<span class="selector-tag">id</span> _<span class="selector-tag">Nullable</span> <span class="selector-tag">obj</span>) </span><br><span class="line">    <span class="selector-tag">OBJC_AVAILABLE</span>(10<span class="selector-class">.5</span>, 2<span class="selector-class">.0</span>, 9<span class="selector-class">.0</span>, 1<span class="selector-class">.0</span>, 2<span class="selector-class">.0</span>);</span><br></pre></td></tr></table></figure><p><code>class_isMetaClass</code>用于判断<code>Class</code>对象是否为<code>元类</code>，<code>object_getClass</code>用于获取对象的<code>isa</code>指针指向的对象。</p><p>再看如下代码：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"><span class="comment">//输出1</span></span><br><span class="line">NSLog(@<span class="string">"%d"</span>, [p <span class="keyword">class</span>] == <span class="keyword">object</span><span class="number">_</span>getClass(p));</span><br><span class="line"><span class="comment">//输出0</span></span><br><span class="line">NSLog(@<span class="string">"%d"</span>, <span class="keyword">class</span><span class="number">_</span>isMetaClass(<span class="keyword">object</span><span class="number">_</span>getClass(p)));</span><br><span class="line"><span class="comment">//输出1</span></span><br><span class="line">NSLog(@<span class="string">"%d"</span>, <span class="keyword">class</span><span class="number">_</span>isMetaClass(<span class="keyword">object</span><span class="number">_</span>getClass([Person <span class="keyword">class</span>])));</span><br><span class="line"><span class="comment">//输出0</span></span><br><span class="line">NSLog(@<span class="string">"%d"</span>, <span class="keyword">object</span><span class="number">_</span>getClass(p) == <span class="keyword">object</span><span class="number">_</span>getClass([Person <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure><p>通过代码可以看出，一个实例对象通过<code>class</code>方法获取的<code>Class</code>就是它的<code>isa</code>指针指向的<code>类对象</code>，而<code>类对象</code>不是<code>元类</code>，<code>类对象</code>的<code>isa</code>指针指向的对象是<code>元类</code>。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>到这里，我们清楚的了解了OC中的类和实例是如何映射到C语言结构体的，实例对象是一个结构体，这个结构体只有一个成员变量，指向构造它的那个类对象，这个类对象中存储了一切实例对象需要的信息包括实例变量、实例方法等，而类对象是通过元类创建的，元类中保存了类变量和类方法，这就完美的解释了整个类和实例是如何映射到结构体的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-630247.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇将看到runtime是如何将面向对象的类转变为面向过程的结构体的，深入理解instance、class object、metaclass的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>runtime系列之（1）runtime初探</title>
    <link href="http://yoursite.com/2018/06/01/runtime%E7%B3%BB%E5%88%97%E4%B9%8B%EF%BC%881%EF%BC%89runtime%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2018/06/01/runtime系列之（1）runtime初探/</id>
    <published>2018-06-01T14:46:40.000Z</published>
    <updated>2018-06-11T03:44:38.222Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-652286.jpg" alt=""></p><p>您将了解到：</p><ul><li>什么是runtime</li><li>与runtime系统发生交互的三种方式</li><li>一些runtime的术语的数据结构<a id="more"></a></li></ul><h3 id="什么是runtime"><a href="#什么是runtime" class="headerlink" title="什么是runtime"></a>什么是runtime</h3><p>我们都知道高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由<code>runtime</code>来实现的。</p><p>Objective-C是基于C的，它为C添加了面向对象的特性。它将很多静态语言在编译和链接时期做的事放到了<code>runtime</code>运行时来处理，可以说<code>runtime</code>是我们Objective-C幕后工作者。</p><ul><li><p><code>runtime</code>（简称运行时），是一套纯C（C和汇编写的）的API。而OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。</p></li><li><p>对于C语言，方法的调用会在编译的时候就决定好调用哪个方法。</p></li><li><p>OC的方法调用成为消息发送，属于动态调用过程。在编译的时候并不能决定真正调用哪个方法，只有在真正运行的时候才会根据方法的名称找到对应的方法实现来调用。</p></li><li><p>事实证明：在编译阶段，OC可以调用任何方法，即使这个方法并未实现，只要声明过就不会报错，只有运行的时候才会报错，这是因为OC是运行时动态调用的。而C语言调用未实现的方法就会报错。</p></li></ul><h3 id="与runtime系统发生交互的三种方式"><a href="#与runtime系统发生交互的三种方式" class="headerlink" title="与runtime系统发生交互的三种方式"></a>与runtime系统发生交互的三种方式</h3><p><code>runtime</code>是一个共享动态库，由一系列的C函数和结构体构成。和<code>runtime</code>系统发生交互的方式有三种，一般都是用前两种：</p><ol><li><strong>通过Objective-C源代码</strong><ul><li>多数情况我们只需要编写OC代码即可，runtime系统自动在幕后搞定一切。</li></ul></li><li><p><strong>通过Foundation框架的NSObject类定义的方法</strong><br> Cocoa 程序中绝大部分类都是NSObject类的子类，所以都继承了NSObject的行为。(<code>NSProxy</code>类时个例外，它是个抽象超类)</p><p> 一些情况下，NSObject 类仅仅定义了完成某件事情的模板，并没有提供所需要的代码。例如<code>-description</code>方法，该方法返回类内容的字符串表示，该方法主要用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址，NSObject 的子类可以重新实现。</p><p> 还有一些NSObject的方法可以从runtime系统中获取信息，允许对象进行自我检查。例如：</p><ul><li><code>-class</code>方法返回对象的类；</li><li><code>-isKindOfClass:</code>和<code>-isMemberOfClass:</code>方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；</li><li><code>-respondsToSelector:</code>检查对象能否响应指定的消息；</li><li><code>-conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；</li><li><code>-methodForSelector:</code>返回指定方法实现的地址；</li></ul></li><li><p><strong>通过对runtime库函数的直接调用</strong><br> 使用时引入<code>#import &lt;objc/runtime.h&gt;</code>和<code>#import &lt;objc/message.h&gt;</code>头文件，一些基础方法都定义在这两个文件中。</p></li></ol><h3 id="一些runtime的术语的数据结构"><a href="#一些runtime的术语的数据结构" class="headerlink" title="一些runtime的术语的数据结构"></a>一些runtime的术语的数据结构</h3><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>它是selector在Objc中表示（swift中是Selector类）。selector是方法选择器，selector对方法名进行包装，以便找到对应的方法实现。它的数据结构是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p></blockquote><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id是一个参数类型，它是指向某个类的实例的指针。定义如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an<span class="built_in"> instance </span>of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>以上定义，看到<code>objc_object</code>结构体包含一个<code>isa</code>指针，根据<code>isa</code>指针就可以找到对象所属的类。</p><blockquote><p>注意：<br><code>isa</code> 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 <code>-class</code> 方法。</p></blockquote><p>PS: KVO 的实现机理就是将被观察对象的 <code>isa</code> 指针指向一个中间类而不是真实类型，详见:</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p><code>Class</code>其实是指向<code>objc_class</code>结构体的指针。<code>objc_class</code>的数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">  Class isa OBJC_ISA_AVAILABILITY; <span class="comment">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">  Class super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></span><br><span class="line">  <span class="keyword">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">  <span class="keyword">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">  <span class="keyword">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法定义的链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 协议链表</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>从<code>objc_class</code>可以看到，一个运行时类中关联了它的<code>父类</code>、<code>类名</code>、<code>成员变量</code>、<code>方法</code>、<code>缓存</code>以及<code>附属的协议</code>。其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> <span class="title">ivar_list</span>[1]                            <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> * _<span class="title">Nullable</span> <span class="title">obsolete</span>             <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> <span class="title">method_list</span>[1]                        <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，我们可以动态修改<code>*methodList</code>的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。这里可以参考下美团技术团队的文章：<a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">美团技术团队–深入理解Objective-C:Category</a></p><p><code>objc_ivar_list</code>结构体用来存储成员变量的列表，而<code>objc_ivar</code>则是存储了单个成员变量的信息；同理，<code>objc_method_list</code>结构体存储着方法数组的列表，而单个方法的信息则由<code>objc_method</code>结构体存储。</p><p>值得注意的是，<code>objc_class</code>中也有一个<code>isa</code>指针，这说明<code>Objc类</code>本身也是一个对象。为了处理类和对象的关系，<code>runtime</code>库创建了一种叫做<code>Meta Class（元类）</code>的东西，类对象所属的类就叫做<code>元类</code>。<code>Meta Class</code>表述了类对象本身所具备的元数据。</p><p>我们所熟悉的类方法，就源自于<code>Meta Class</code>。我们可以立即为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p><p>当你发出一个类似<code>[NSObject alloc](类方法)</code>的消息时，实际上，这个消息被发送给了一个<code>类对象(Class Object)</code>，这个类对象必须是一个元类的实例，而这个元类同时也是也是一个<code>根元类(Root Meta Class)</code>的实例。所有元类的<code>isa</code>指针最终都指向<code>根元类</code>。</p><p>所以当<code>[NSObject alloc]</code>这条消息发送给类对象的时候，运行时代码<code>objc_msgSend()</code>会去它的元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。</p><p><img src="http://p9u62mso1.bkt.clouddn.com/r_runtimeIsaAll.png" alt=""></p><p>上图实线是<code>super_class</code>指针，虚线是<code>isa</code>指针。而根元类的父类是NSObject，<code>isa</code>指向了自己。而NSObject没有父类。最后<code>objc_class</code>中还有一个<code>objc_cache</code>，缓存，它的左右很重要，后面会提到。</p><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line">struct objc_method <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p><code>objc_method</code>存储了方法名，方法类型和方法实线：</p><ul><li>方法名类型为<code>SEL</code></li><li>方法类型<code>method_types</code>是个<code>char</code>指针，存储方法的参数类型和返回值类型</li><li><code>method_imp</code>指向了方法的实现，本质是一个函数指针</li></ul><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p><code>Ivar</code>是表示成员变量的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> *<span class="title">Ivar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_type                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>ivar_offset</code>是基地址偏移字节</p><h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code>在<code>objc.h</code>中的定义是：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*<span class="type">IMP</span>)(void /* id, <span class="type">SEL</span>, ... */ );</span><br></pre></td></tr></table></figure><p>它就是一个函数指针，这是由编译器生成的。当你发起一个<code>ObjC</code>消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而<code>IMP</code>这个函数指针就是指向了这个方法的实现。</p><p>如果得到了执行某个实例某个方法的入口，我们可以绕开消息传递阶段，直接执行方法，这在下面的<code>Cache</code>中会提到。</p><p>你会发现<code>IMP</code>指向的方法与<code>objc_msgSend</code>函数类型相同，参数都包含<code>id</code>和<code>SEL</code>类型。每个方法名都对应一个<code>SEL</code>类型的方法选择器，而每个实例对象中的<code>SEL</code>对应方法实线总是唯一的，通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实线地址。</p><p>而一个确定的方法也只有唯一的一组<code>id</code>和<code>SEL</code>参数。</p><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>Cache定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">Cache</span>                             <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method _Nullable buckets[<span class="number">1</span>]                              OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Cache为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在isa指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在Cache中查找。</p><p>runtime系统会把被调用的方法存到Cache中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中CPU绕过主存先访问Cache一样。</p><h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_property</span> *<span class="title">objc_property_t</span>;</span></span><br></pre></td></tr></table></figure><p>可以通过<code>class_copyPropertyList</code>和<code>protocol_copyPropertyList</code>方法获取类和协议中的属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="keyword">objc_property_t</span> *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br></pre></td></tr></table></figure><blockquote><p>注意：返回的是属性列表，列表中每个元素都是一个<code>objc_property_t</code>指针</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 姓名 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** age */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** weight */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>以上是一个Person类，有三个属性。让我们用上述方法获取类的运行时属性。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned int outCount = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">objc_property_t *properties = class_copyPropertyList([Person class], <span class="symbol">&amp;outCount</span>)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">for (<span class="name">NSInteger</span> i = <span class="number">0</span><span class="comment">; i &lt; outCount; ++i) &#123;</span></span><br><span class="line">   NSString *name = @(property_getName(properties[i]));</span><br><span class="line">   NSString *attributes = @(<span class="name">property_getAttributes</span>(<span class="name">properties</span>[i]))<span class="comment">;</span></span><br><span class="line">   NSLog(@<span class="string">"%@ ------- %@"</span>, name, attributes)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name ------- <span class="built_in">T</span>@<span class="string">"NSString"</span>,C,<span class="built_in">N</span>,V_name</span><br><span class="line">age ------- TQ,<span class="built_in">N</span>,V_age</span><br><span class="line">weight ------- Td,<span class="built_in">N</span>,V_weight</span><br></pre></td></tr></table></figure><p><code>property_getName</code>用来查找属性的名称，返回c字符串。<code>property_getAttributes</code>函数挖掘属性的真实名称和@encode类型，返回c字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">objc_property_t</span> class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="keyword">objc_property_t</span> protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span><br></pre></td></tr></table></figure><p><code>class_getProperty</code>和<code>protocol_getProperty</code>通过给出属性名在类和协议中获得属性的引用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一些runtime术语讲完了，我们队结构体<code>struct objc_class</code>有了了解，下一篇，我们将学习runtime如何将面向对象的类转变为面向过程的结构体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-652286.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;您将了解到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是runtime&lt;/li&gt;
&lt;li&gt;与runtime系统发生交互的三种方式&lt;/li&gt;
&lt;li&gt;一些runtime的术语的数据结构
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码工作流分析</title>
    <link href="http://yoursite.com/2018/05/28/SDWebImage%E6%BA%90%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/28/SDWebImage源码工作流分析/</id>
    <published>2018-05-28T14:46:40.000Z</published>
    <updated>2018-06-05T08:05:06.307Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-652298.jpg" alt=""></p><p><strong>本篇将了解到：</strong></p><ul><li>SDWebImage是如何工作的，各工具类之间是如何协调处理的</li><li>SDWebImage是如何异步下载图片及处理线程安全问题的</li><li>SDWebImage是如何异步缓存并自动管理缓存有效性的</li></ul><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>目的<br>SDWebImage提供了UIImageView、UIButton、MKAnnotationView的图片下载分类，只要一行代码就可以实现图片异步下载和缓存功能。</li><li>特性<ul><li>提供UIImageView、UIButton、MKAnnotationView的分类，用来显示网络图片，以及缓存管理</li><li>异步下载图片</li><li>异步缓存（内存+磁盘），并且自动管理缓存有效性</li><li>后台图片解压缩</li><li>同一个URL不会重复下载</li><li>自动识别无效URL，不会反复重试</li><li>不阻塞主线程</li><li>高性能</li><li>使用GCD和ARC</li><li>支持多图片格式</li><li>支持动图<ul><li>4.0之前动图效果并不是太好</li><li>4.0之后基于FLAnimatedImage加载动图</li></ul></li></ul></li></ul><p><img src="http://p9u62mso1.bkt.clouddn.com/s_SDClassDiagram.png" alt="SDWebImage所有类关系图解"></p><p><img src="http://p9u62mso1.bkt.clouddn.com/s_SDSequenceDiagram.png" alt="SDWebImage工作流图解"></p><p>上面两张图是SDWebImage<a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">原文</a>给出的，现在看不懂没关系，下面分步解析之后再回来看。</p><h2 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a>核心逻辑：</h2><ol><li><p>入口UIImageView+WebCache调用方法<code>sd_setImageWithURL:placeholderImage:options:progress:completed:</code>，这个方法中调用的是UIView+WebCache提供的方法<code>sd_internalSetImageWithURL:placeholderImage:options:operationKey:setImageBlock:progress:completed:</code></p></li><li><p>必须先删除该控件之前的下载任务，<code>sd_cancelImageLoadOperationWithKey</code>(4.0之前是sd_cancelCurrentImageLoad)原因是当你网络不快的情况下，例如你一个屏幕能展示三个cell，第一个cell由于网络问题不能立刻下完，那么用户就滑动了tableview，第一个cell进去复用池，第五个出来的cell从复用池子拿，由于之前的下载还在，本来是应该显示第五个图片，但是SDWebImage的默认做法是立马把下载好的图片给UIImageView，所以这时候会图片数据错乱，BUG</p></li><li><p>有placeHolder先展示，然后启用SDWebImageManager单例<code>loadImageWithURL:options:progress:completed:</code>来处理图片下载</p></li><li><p>先判断url的合法性，再创建SDwebImageCombinedOperation的cache任务对象，再查看url是否之前下载失败过，最后如果url为nil，则直接返回操作对象完成回调，如果都正常，那么就调用SDWebImageManager中的管理缓存类SDImageCache单例的方法<code>queryDiskCacheForKey:done:</code>查看是否有缓存</p></li><li><p>SDImageCache内存缓存用的是NSCache，Disk缓存用的是NSFileManager的文件写入操作，那么查看缓存的时候是先去内存查找，这里的key都是经过MD5之后的字串，找到直接回调，没找到继续去磁盘查找，<em>开异步串行队列去找，避免卡死主线程</em>，启用autoreleasepool避免内存暴涨，查到了缓存到内存，然后回调</p></li><li><p>如果都没找到，就调用SDWebImageManager中的管理下载类SDWebImageDownloader单例<code>downloadImageWithURL:options:progress:completed:completedBlock</code>处理下载</p></li><li><p>下载前调用<code>addProgressCallback:completedBlock:forURL:createCallback:</code>来保证统一url只会生成一个网络下载对象，多余的都只会用URLCallbacks存储传入的进度Block或者CompleteBlock，因此下载结果返回的时候会进行遍历回调</p></li><li><p>下载用NSOperation和NSOperationQueue来进行，SDWebImage派生了一个SDWebImageDownloaderOperation负责图片的下载任务，调用<code>initWithRequest:inSession:options:progress:completed:cancelled:</code></p></li><li><p>把返回的SDWebImageDownloaderOperation对象add到NSOperationQueue，FIFO队列就正常，如果是LIFO队列，就需要设置依赖，这也是GCD和NSOperation的区别，也是NSOperation的优点，让上一次的任务依赖于本次任务<code>[wself.lastAddedOperationaddDependency:operation]</code></p></li><li><p>下载任务开始是用NSURLSession了，不用NSURLConnetion了，由于SD是自定义的NSOperation内部需要重写start方法，在该方法里面配置Session，当taskResume的时候，根据设置的代理就能取到不同的回调参数</p><ul><li>didReceiveResponse能获取到响应的所有参数规格，例如总size</li><li>didReceiveData是一步步获取data，压缩解码回调progressBlock</li><li>didCompleteWithError全部完成回调，图片解码，回调completeBlock</li></ul></li><li><p>图片的解码是在SDWebImageDecoder里面完成的，缩放操作是在SDWebImageCompat内完成的，代理方法里面本身就已经是异步了，而且解码操作加入了autoreleasepool减少内存峰值</p></li><li><p>当在SDWebImageDownloaderOperation中NSURLSession完成下载之后或者中途回调到SDWebImageDownloader中，然后再回调到SDWebImageManager，在Manager中二级缓存image，然后继续回调出去到UIImage+WebCache中，最后把Image回调出去，在调用的控件中展示出来</p></li><li><p>SDImageCache初始化的时候注册了几个通知，当内存警告的时候，程序进入后台或者程序杀死的时候根据策略清理缓存<br>内存警告：自动清除NSCache内存缓存<br>进入后台和程序杀死：清理过期的文件（默认一周）,然后有个缓存期望值，对比已有文件的大小，先根据文件最后编辑时间升序排，把大于期望值大小的文件全部杀掉</p></li></ol><p><img src="http://p9u62mso1.bkt.clouddn.com/s_sdFlow.jpeg" alt="下载图片运行图"></p><h3 id="第一步-UIImageView-WebCache"><a href="#第一步-UIImageView-WebCache" class="headerlink" title="第一步 UIImageView+WebCache"></a>第一步 UIImageView+WebCache</h3><p>外部接口，提供给使用者直接调用，这些接口方法最终会调用UIView+WebCache里面的<code>-sd_internalSetImageWithURL:placeholderImage:options:operationKey:setImageBlock:progress:completed:</code>，任务就是从这个方法开始处理的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">          </span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">                   </span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><h3 id="第二步-UIView-WebCache"><a href="#第二步-UIView-WebCache" class="headerlink" title="第二步 UIView+WebCache"></a>第二步 UIView+WebCache</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> sd_internalSetImageWithURL:url placeholderImage:placeholder options:options operationKey:operationKey setImageBlock:setImageBlock progress:progressBlock completed:completedBlock context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的sd_setImageWithURL方法，最终都会进入这个方法进行图片的加载</span></span><br><span class="line"><span class="comment">// url 加载的图片</span></span><br><span class="line"><span class="comment">// placeholder 占位图</span></span><br><span class="line"><span class="comment">// options 下载图片的各种花式设置 一般使用的是SDWebImageRetryFailed | SDWebImageLowPriority</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)context &#123;</span><br><span class="line">    <span class="comment">// 根据参数operationKey取消当前类所对应的下载Operation对象，如果operationKey为nil key取NSStringFromClass([self class])</span></span><br><span class="line">    <span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="comment">// 取消当前的下载操作，如果不取消，那么当tableView滑动的时候，当前cell的imageView会一直去下载图片，然后优先显示下载完成的图片，直接错乱</span></span><br><span class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">    <span class="comment">// 利用关联对象给当前self实例绑定url key=imageURLKey value=url</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    <span class="comment">//这里就用到了我们开篇讲的位运算，利用&amp;与运算判断调用者是否需要设置占位图，需要则set</span></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</span><br><span class="line">            dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</span><br><span class="line">            dispatch_group_enter(group);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断下载链接url是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">// check if activityView is enabled or not</span></span><br><span class="line">        <span class="comment">// 判断之前是否利用关联对象给self设置了显示菊花加载，如果有则add</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> sd_showActivityIndicatorView]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> sd_addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reset the progress</span></span><br><span class="line">        <span class="keyword">self</span>.sd_imageProgress.totalUnitCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.sd_imageProgress.completedUnitCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键类 SDWebImageManager 来处理图片下载</span></span><br><span class="line">        <span class="comment">// 下载有三层 1当前mananger调用下载 2从缓存中获取，hit失败调用SDWebImageDownloader对象调用下载 3.SDWebImageDownloaderOperation最终继承</span></span><br><span class="line">        SDWebImageManager *manager;</span><br><span class="line">        <span class="keyword">if</span> ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">            manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">        SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">NSURL</span> * _Nullable targetURL) &#123;</span><br><span class="line">            wself.sd_imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">            wself.sd_imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">            <span class="keyword">if</span> (progressBlock) &#123;</span><br><span class="line">                progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// NSOperation的对象NSURLSession的方法去下载图片，代理里面操作</span></span><br><span class="line">        <span class="comment">// 调用SDWebImageManager的loadImageWithURL方法去加载图片，返回值是SDWebImageCombinedOperation</span></span><br><span class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">            <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="comment">// 在这里移除菊花</span></span><br><span class="line">            [sself sd_removeActivityIndicator];</span><br><span class="line">            <span class="comment">// if the progress not been updated, mark it to complete state</span></span><br><span class="line">            <span class="keyword">if</span> (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == <span class="number">0</span> &amp;&amp; sself.sd_imageProgress.completedUnitCount == <span class="number">0</span>) &#123;</span><br><span class="line">                sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">                sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">BOOL</span> shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">            <span class="comment">//是否不显示图片两个条件满足其一即可 1&gt;调用者手动主动配置，哪怕image不为nil 2&gt;没有图片并且不delaye占位图情况</span></span><br><span class="line">            <span class="comment">// 设置了SDWebImageAvoidAutoSetImage默认不会将UIImage添加进UIImageView对象里，而放置在completBlock里面交由调用方自己处理，做个滤镜或者淡入淡出什么的。</span></span><br><span class="line">            <span class="built_in">BOOL</span> shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果设置了不自动显示图片，则回调让调用者手动添加显示图片 程序return</span></span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set</span></span><br><span class="line">            <span class="comment">// OR</span></span><br><span class="line">            <span class="comment">// case 1b: we got no image and the SDWebImageDelayPlaceholder is not set</span></span><br><span class="line">            <span class="keyword">if</span> (shouldNotSetImage) &#123;<span class="comment">//如果设置了不自动显示图片，则回调让调用者手动添加显示图片 程序return</span></span><br><span class="line"></span><br><span class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIImage</span> *targetImage = <span class="literal">nil</span>;</span><br><span class="line">            <span class="built_in">NSData</span> *targetData = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span></span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                <span class="comment">// case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span></span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check whether we should use the image transition</span></span><br><span class="line">            SDWebImageTransition *transition = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">                transition = sself.sd_imageTransition;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</span><br><span class="line">                dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</span><br><span class="line">                dispatch_group_enter(group);</span><br><span class="line">                dispatch_main_async_safe(^&#123;</span><br><span class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// ensure completion block is called after custom setImage process finish</span></span><br><span class="line">                dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch_main_async_safe(^&#123;</span><br><span class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">// 保存本次operation，如果发生多次图片请求可以用来取消</span></span><br><span class="line">        <span class="comment">// 先取消当前UIImageView正在下载的任务，然后保存operations</span></span><br><span class="line">        <span class="comment">// 也就是说当动态绑定的字典里面的key value对应一个图片下载 单个图片value数组就是0，不然就是多个，下载完就会根据key移除</span></span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="comment">//移除菊花 抛出url为nil的回调</span></span><br><span class="line">            [<span class="keyword">self</span> sd_removeActivityIndicator];</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小知识点：<br>这里首先会调用<code>sd_cancelImageLoadOperationWithKey</code>(4.0之前是sd_cancelCurrentImageLoad)方法，删除该控件之前的下载任务，因为SDWebImage的默认做法是立马把下载好的图片给UIImageView，所以这时候如果图片还没下载下来，用户滑动了屏幕导致其他控件又发送了图片请求会图片数据错乱的问题。</p><h3 id="第三步-SDWebImageManager"><a href="#第三步-SDWebImageManager" class="headerlink" title="第三步 SDWebImageManager"></a>第三步 SDWebImageManager</h3><p><em>承上启下的核心管理类</em>，有两个得力手下：</p><ul><li><p>SDImageCache 专门管理缓存</p><ul><li>NSCache负责内存缓存，用法与NSDictionary基本一样</li><li><p>磁盘缓存用NSFileManager读写文件的方式</p><blockquote><p>   注：</p><pre><code>1. NSCache具有自动删除的功能，以减少系统内存，还能设置内存临界值2. NSCache是线程安全的，不需要加线程锁3. 键对象不会像NSMutableDictionary中那样被复制。(键不需要实现NSCopying协议)</code></pre></blockquote></li></ul></li><li><p>SDWebImageDownloader 专门负责图片的下载，图片的下载都是放在NSOperationQueue中完成的</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从imageCache中寻找图片</span></span><br><span class="line"><span class="comment">//每次向SDWebImageCache索取图片的时候，会先根据图片URL对应的key值先检查内存中是否有对应的图片，如果有则直接返回；如果没有则在ioQueue中去硬盘中查找，其中文件名是是根据URL生成的MD5值，找到之后先将图片缓存在内存中，然后在把图片返回</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// First check the in-memory cache...</span></span><br><span class="line">    <span class="comment">// 1. 先去内存中查找</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="built_in">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    <span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在内存没找到</span></span><br><span class="line">    <span class="comment">// 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调</span></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="keyword">void</span>(^queryDiskBlock)(<span class="keyword">void</span>) =  ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="comment">// do not call the completion if cancelled</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建自动释放池，内存即时释放</span></span><br><span class="line">        <span class="comment">// 如果你的应用程序或者线程是要长期运行的并且有可能产生大量autoreleased对象, 你应该使用autorelease pool blocks</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// 从磁盘缓存中拿，拿到根据字段存入内存</span></span><br><span class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// the image is from in-memory cache</span></span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</span><br><span class="line">                <span class="comment">// decode image data only if in-memory cache missed</span></span><br><span class="line">                diskImage = [<span class="keyword">self</span> diskImageForKey:key data:diskData options:options];</span><br><span class="line">                <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    <span class="comment">// 像素</span></span><br><span class="line">                    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    <span class="comment">// 缓存到NSCache中</span></span><br><span class="line">                    [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小知识点：<br>这里开了异步串行队列去Disk中查找，保证不阻塞主线程，而且开了autoreleasepool以降低内存暴涨问题，能得到及时释放。如果能从磁盘缓存中取到，首先缓存到内存中然后再回调。<br>如果内存和磁盘中都找不到图片，就会让SDWebImageManager的另一个帮手SDWebImageDownloader去下载图片。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载图片最终实现方法</span></span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)<span class="string">loadImageWithURL:</span>(nullable NSURL *)url</span><br><span class="line"><span class="symbol">                                     options:</span>(SDWebImageOptions)options</span><br><span class="line"><span class="symbol">                                    progress:</span>(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line"><span class="symbol">                                   completed:</span>(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></span><br><span class="line">    <span class="comment">//completedBlock为nil，则触发断言，程序crash</span></span><br><span class="line">    NSAssert(completedBlock != nil, @<span class="string">"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won't</span></span><br><span class="line">    <span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></span><br><span class="line">    <span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></span><br><span class="line">    <span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装下载操作的对象</span></span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation <span class="keyword">new</span>];</span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">// 信号量dispatch_semaphore_wait，可使总信号量减1，当信号量为0时就会一直等待（阻塞线程）</span></span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs <span class="string">containsObject:</span>url];</span><br><span class="line">        <span class="comment">// 信号量dispatch_semaphore_signal，发送一个信号量，让信号总量加1</span></span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果url为nil，或者没有设置失败url重新下载的配置（SDWebImageRetryFailed）且该url已经下载失败过了，那么返回失败的回调</span></span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self <span class="string">callCompletionBlockForOperation:</span>operation <span class="string">completion:</span>completedBlock <span class="string">error:</span>[NSError <span class="string">errorWithDomain:</span>NSURLErrorDomain <span class="string">code:</span>NSURLErrorFileDoesNotExist <span class="string">userInfo:</span>nil] <span class="string">url:</span>url];</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建互斥锁，添加operation到数组中</span></span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations <span class="string">addObject:</span>operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    NSString *key = [self <span class="string">cacheKeyForURL:</span>url];</span><br><span class="line">    </span><br><span class="line">    SDImageCacheOptions cacheOptions = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    <span class="comment">// 使用缓存对象，根据key去寻找查找</span></span><br><span class="line">    operation.cacheOperation = [self.imageCache <span class="string">queryCacheOperationForKey:</span>key <span class="string">options:</span>cacheOptions <span class="string">done:</span>^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        <span class="comment">// 如果当前操作被取消，则remove且return</span></span><br><span class="line">        <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check whether we should download image from network</span></span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldDownloadImageForURL:</span>)] || [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldDownloadImageForURL:</span>url]);</span><br><span class="line">        <span class="keyword">if</span> (shouldDownload) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span><br><span class="line">                <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span><br><span class="line">                [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// download if no image or requested to refresh anyway, and download allowed by delegate</span></span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// force progressive off if image already cached but forced refreshing</span></span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span></span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            <span class="comment">// 调用SDWebImageDownloader的downloadImageWithURL:方法</span></span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader <span class="string">downloadImageWithURL:</span>url <span class="string">options:</span>downloaderOptions <span class="string">progress:</span>progressBlock <span class="string">completed:</span>^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                <span class="keyword">if</span> (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing if the operation was cancelled</span></span><br><span class="line">                    <span class="comment">// See #699 for more details</span></span><br><span class="line">                    <span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">error:</span>error <span class="string">url:</span>url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    <span class="comment">// Check whether we should block failed url</span></span><br><span class="line">                    <span class="keyword">if</span> ([self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldBlockFailedURL:</span><span class="string">withError:</span>)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldBlockFailedURL:</span>url <span class="string">withError:</span>error];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">addObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">removeObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 是否需要缓存到磁盘</span></span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// We've done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</span></span><br><span class="line">                    <span class="keyword">if</span> (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self <span class="string">scaledImageForKey:</span>key <span class="string">image:</span>downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></span><br><span class="line">                    <span class="comment">// 图片下载成功并且判断是否需要转换图片</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                            <span class="comment">// 根据代理获取转换后的图片</span></span><br><span class="line">                            UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];</span><br><span class="line">                            <span class="comment">// 如果转换图片存在且下载图片操作已完成，则在缓存对象中存储图片</span></span><br><span class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];</span><br><span class="line">                                NSData *cacheData;</span><br><span class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></span><br><span class="line">                                <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                &#125;</span><br><span class="line">                                [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>transformedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;<span class="comment">//下载完成且有image则缓存图片</span></span><br><span class="line">                            <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                    [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>downloadedData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>downloadedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果下载和缓存都完成了则删除操作队列中的operation</span></span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    [self <span class="string">safelyRemoveOperationFromRunning:</span>strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">            <span class="comment">// 缓存中有图片且线程没有倍取消，则返回有图片的completedBlock</span></span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Image not in cache and download disallowed by delegate</span></span><br><span class="line">            <span class="comment">// 图片没有在缓存中且代理方法不允许下载则回调失败</span></span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>nil <span class="string">data:</span>nil <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四步-SDWebImageDownloader"><a href="#第四步-SDWebImageDownloader" class="headerlink" title="第四步 SDWebImageDownloader"></a>第四步 SDWebImageDownloader</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给指定url下载图片</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在下面的block中创建operation</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">        <span class="comment">// 设置下载时间</span></span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">            timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></span><br><span class="line">        <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</span><br><span class="line">        <span class="comment">// 创建request 设置请求缓存策略 下载时间</span></span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line">        </span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        <span class="comment">// HTTPShouldUsePipelining设置为YES, 则允许不必等到response, 就可以再次请求. 这个会很大的提高网络请求的效率,但是也可能会出问题</span></span><br><span class="line">        <span class="comment">// 因为客户端无法正确的匹配请求与响应, 所以这依赖于服务器必须保证,响应的顺序与客户端请求的顺序一致.如果服务器不能保证这一点, 那可能导致响应和请求混乱.</span></span><br><span class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重头戏 在这里创建operation对象</span></span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下载优先级</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置下载的顺序是队列还是栈</span></span><br><span class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：<br>通过<code>addProgressCallback: completedBlock: forURL: createCallback:</code>来确保同一url只会下载一次</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装callbackBlocks，URLOperations和token</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(<span class="keyword">void</span>))createCallback &#123;</span><br><span class="line">    <span class="comment">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成URLOperations字典 下载url作为key value是具体的下载operation 方便下载cancel等操作</span></span><br><span class="line">    LOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [<span class="keyword">self</span>.URLOperations objectForKey:url];</span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __<span class="keyword">strong</span> <span class="keyword">typeof</span>(wself) sself = wself;</span><br><span class="line">            <span class="keyword">if</span> (!sself) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        [<span class="keyword">self</span>.URLOperations setObject:operation forKey:url];</span><br><span class="line">        <span class="comment">// Add operation to operation queue only after all configuration done according to Apple's doc.</span></span><br><span class="line">        <span class="comment">// `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span></span><br><span class="line">        [<span class="keyword">self</span>.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(<span class="keyword">self</span>.operationsLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将进度progressBlock和下载结束completedBlock封装成字典SDCallbacksDictionary，装入数组callbackBlocks，</span></span><br><span class="line">    <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    <span class="comment">//这里生成token标识，这个token说白了就是为了在SDWebImageManager中调用[self.imageDownloader cancel:subOperationToken];来做取消的</span></span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五步-SDWebImageDownloaderOperation"><a href="#第五步-SDWebImageDownloaderOperation" class="headerlink" title="第五步 SDWebImageDownloaderOperation"></a>第五步 SDWebImageDownloaderOperation</h3><p>SDWebImageDownloaderOperation继承自NSOperation，是具体的执行图片下载的单位。负责生成NSURLSessionTask进行图片请求，支持下载取消和后台下载，在下载中及时汇报下载进度，在下载成功后，对图片进行解码，缩放和压缩等操作。</p><p><img src="http://p9u62mso1.bkt.clouddn.com/s_s_SDDown.png" alt="SDWebImage加载图片总结"></p><p>具体的下载流程用文字来描述：</p><ol><li>首先生成继承在NSOperation的SDWebImageDownloaderOperation，配置operation。</li><li>将operation添加到NSOperationQueue下载队列，添加到下载队列会触发operation的star方法。</li><li>如果发现operation的isCancelled为YES，说明已经被取消，则finished=YES结束下载。</li><li>创建NSURLSessionTask执行resume开始下载。</li><li>当收到服务端的响应时根据code判断请求状态，如果是正常状态则发送正在接受response的通知以及下载进度。如果是404或者其他状态则cancel下载操作</li><li>在didReceiveData每次收到服务器的返回response时，给可变data追加当前下载的data，并汇报下载进度</li><li>在didCompleteWithError下载结束时，如果下载成功进行图片data解码，图片的缩放或者压缩操作，发送下载结束通知。下载失败执行失败回调。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>问题 1：图片刷新问题：SDWebImage 在进行缓存时忽略了所有服务器返回的 caching control 设置，并且在缓存时没有做时间限制，这也就意味着图片 URL 必须是静态的了，要求服务器上一个 URL 对应的图片内容不允许更新。但是如果存储图片的服务器不由自己控制，也就是说 图片内容更新了，URL 却没有更新，这种情况怎么办？</li></ol><ul><li>解决方案：在调用 sd_setImageWithURL: placeholderImage: options:方法时设置 options 参数为 SDWebImageRefreshCached，这样虽然会降低性能，但是下载图片时会照顾到服务器返回的 caching control。</li></ul><ol start="2"><li>问题 2：在加载图片时，如何添加默认的 progress indicator ？</li></ol><ul><li><p>解决方案：在调用 -sd_setImageWithURL:方法之前，先调用下面的方法：</p><p>  [imageView sd_setShowActivityIndicatorView:YES];</p><p>  [imageView sd_setIndicatorStyle:UIActivityIndicatorViewStyleGray];</p></li></ul><p>参考：<br><a href="http://www.cocoachina.com/ios/20171218/21566.html" target="_blank" rel="noopener">SDWebImage源码解析一</a><br><a href="http://www.cocoachina.com/ios/20171219/21582.html" target="_blank" rel="noopener">SDWebImage源码解析二</a><br><a href="https://blog.csdn.net/deft_mkjing/article/details/52900586" target="_blank" rel="noopener">SDWebImage详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-652298.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇将了解到：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDWebImage是如何工作的，各工具类之间是如何协调处理的&lt;/li&gt;
&lt;li&gt;SDWebImage是如何异步下载图片及处理线程安全问题的&lt;/li&gt;
&lt;li&gt;SDWebImage是如何异步缓存并自动管理缓存有效性的&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="SDWebImage" scheme="http://yoursite.com/tags/SDWebImage/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程之NSOperation、NSOperationQueue详解</title>
    <link href="http://yoursite.com/2018/05/24/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BNSOperation%E3%80%81NSOperationQueue%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/24/iOS多线程之NSOperation、NSOperationQueue详解/</id>
    <published>2018-05-24T12:33:42.000Z</published>
    <updated>2018-06-05T07:37:39.541Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-648123.jpg" alt=""></p><p>本文用来介绍iOS多线程中的NSOperation、NSOperationQueue的相关知识及使用方法。<br>通过本文，您将了解到：<br><strong>NSOperation、NSOperationQueue简介、操作和操作队列、使用步骤和基本使用方法、控制串行/并发执行、NSOperation操作依赖和优先级、线程间的通信、线程同步和线程安全，以及NSOperation、NSOperationQueue常用属性和方法归纳。</strong></p><a id="more"></a><h2 id="1-NSOperation、NSOperationQueue简介"><a href="#1-NSOperation、NSOperationQueue简介" class="headerlink" title="1. NSOperation、NSOperationQueue简介"></a>1. NSOperation、NSOperationQueue简介</h2><p>NSOperation、NSOperationQueue是苹果提供给我们的一套多线程解决方案。实际上NSOperation、NSOperationQueue是基于GCD更高一层的封装，完全面向对象。但是比GCD更简单易用、代码可读性也更高。</p><p><strong>为什么要使用NSOperation、NSOperationQueue?</strong></p><ol><li>可添加完成的代码块，在操作完成之后执行</li><li>添加操作之间的依赖关系，方便的控制执行顺序</li><li>设定操作执行的优先级</li><li>可以很方便的取消一个操作的执行</li><li>使用KVO观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled</li></ol><h2 id="2-NSOperation、NSOperationQueue操作和操作队列"><a href="#2-NSOperation、NSOperationQueue操作和操作队列" class="headerlink" title="2. NSOperation、NSOperationQueue操作和操作队列"></a>2. NSOperation、NSOperationQueue操作和操作队列</h2><p>既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的<code>任务（操作）</code>和<code>队列（操作队列）</code>的概念。</p><ul><li><p><strong>操作（Operation）：</strong></p><ul><li>执行操作的意思，换句话说就是你在线程中执行的那段代码。</li><li>在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。</li></ul></li><li><p><strong>操作队列（Operation Queues）：</strong></p><ul><li>这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</li><li>操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。</li><li>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</li></ul></li></ul><h2 id="3-NSOperation、NSOperationQueue-使用步骤"><a href="#3-NSOperation、NSOperationQueue-使用步骤" class="headerlink" title="3. NSOperation、NSOperationQueue 使用步骤"></a>3. NSOperation、NSOperationQueue 使用步骤</h2><p>NSOperation需要配合NSOperationQueue来实现多线程。因为默认情况下，NSOperation单独使用时系统同步执行操作，配合NSOperationQueue能更好的实现异步执行。</p><p>NSOperation实现多线程的使用步骤分为三步：</p><ol><li>创建操作：先将需要执行的操作封装到一个NSOperation对象中</li><li>创建队列：创建NSOperationQueue对象</li><li>将操作加入到队列中：将NSOperation对象添加到NSOperationQueue对象中</li></ol><p>之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。</p><h2 id="4-NSOperation、NSOperationQueue基本使用"><a href="#4-NSOperation、NSOperationQueue基本使用" class="headerlink" title="4. NSOperation、NSOperationQueue基本使用"></a>4. NSOperation、NSOperationQueue基本使用</h2><h3 id="4-1-创建操作"><a href="#4-1-创建操作" class="headerlink" title="4.1 创建操作"></a>4.1 创建操作</h3><p>NSOperation是个抽象类，不能用来封装操作。我们只能是用它的子类来封装操作。我们有三种方式来封装操作。</p><ol><li>使用子类NSInvocationOperation</li><li>使用子类NSBlockOperation</li><li>自定义继承自NSOperation的子类，通过实现内部相应的方法来封装操作</li></ol><p>在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作，下面我们学习一下操作的三种创建方式。</p><h4 id="4-1-1-使用子类NSInvocationOperation"><a href="#4-1-1-使用子类NSInvocationOperation" class="headerlink" title="4.1.1 使用子类NSInvocationOperation"></a>4.1.1 使用子类NSInvocationOperation</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用子类 NSInvocationOperation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)useInvocationOperation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建 NSInvocationOperation 对象</span></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task1) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用 start 方法开始执行操作</span></span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)task1 &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-24</span> <span class="number">14</span>:<span class="number">20</span>:<span class="number">59.367361</span>+<span class="number">0800</span> test[<span class="number">6371:138119</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000260280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">14</span>:<span class="number">21</span>:<span class="number">01.368783</span>+<span class="number">0800</span> test[<span class="number">6371:138119</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000260280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看到：在没有使用NSOperationQueue、在主线程中单独使用子类NSInvocationOperation执行一个操作的情况下，操作是在主线程执行的，并没有开启新线程。</p><p>如果是在其他线程中执行操作，则打印结果为其他线程。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在其他线程使用子类 NSInvocationOperation</span></span><br><span class="line">[NSThread <span class="string">detachNewThreadSelector:</span><span class="meta">@selector</span>(useInvocationOperation) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-24</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">42.406393</span>+<span class="number">0800</span> test[<span class="number">6509:146542</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">00000277300</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">44.409801</span>+<span class="number">0800</span> test[<span class="number">6509:146542</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">00000277300</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-使用子类NSBlockOperation"><a href="#4-1-2-使用子类NSBlockOperation" class="headerlink" title="4.1.2 使用子类NSBlockOperation"></a>4.1.2 使用子类NSBlockOperation</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用子类 NSBlockOperation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)useBlockOperation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建 NSBlockOperation 对象</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用 start 方法开始执行操作</span></span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">04</span>:<span class="number">53.603988</span>+<span class="number">0800</span> test[<span class="number">7767:222327</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00006e400</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">04</span>:<span class="number">55.604878</span>+<span class="number">0800</span> test[<span class="number">7767:222327</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00006e400</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看到：在没有使用NSOperationQueue、在主线程中单独使用NSBlockOperation执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</p><blockquote><p>注意：和上边<code>NSInvocationOperation</code>使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。</p></blockquote><p>但是，NSBlockOperation还提供了一个方法<code>addExecutionBlock:</code>，通过<code>addExecutionBlock:</code>就可以为NSBlockOperation添加额外的操作。这些操作（包括blockOperationWithBlock中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。</p><p>如果添加多操作的话，<code>blockOperationWithBlock:</code>中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到<code>blockOperationWithBlock:</code>中的操作一定会在当前线程中执行。（可以用<code>addExecutionBlock:</code>多添加几个操作试试）。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用子类 NSBlockOperation</span></span><br><span class="line"><span class="comment"> * 调用方法 AddExecutionBlock:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)useBlockOperationAddExecutionBlock &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建 NSBlockOperation 对象</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.添加额外的操作</span></span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"4---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"5---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"6---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"7---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"8---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"9---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"10---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"11---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"12---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 3.调用 start 方法开始执行操作</span></span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">12.815707</span>+<span class="number">0800</span> test[<span class="number">8360:253503</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b380</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">12.815707</span>+<span class="number">0800</span> test[<span class="number">8360:253501</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">40002688c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">13.815373</span>+<span class="number">0800</span> test[<span class="number">8360:253500</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b340</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">13.815386</span>+<span class="number">0800</span> test[<span class="number">8360:253436</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x600000068ec0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">13.816409</span>+<span class="number">0800</span> test[<span class="number">8360:253503</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b380</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">13.816410</span>+<span class="number">0800</span> test[<span class="number">8360:253501</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">40002688c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">14.816860</span>+<span class="number">0800</span> test[<span class="number">8360:253501</span>] <span class="number">6</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">40002688c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">15.816932</span>+<span class="number">0800</span> test[<span class="number">8360:253500</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b340</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">15.816994</span>+<span class="number">0800</span> test[<span class="number">8360:253503</span>] <span class="number">5</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b380</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">15.817005</span>+<span class="number">0800</span> test[<span class="number">8360:253436</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x600000068ec0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">15.817349</span>+<span class="number">0800</span> test[<span class="number">8360:253501</span>] <span class="number">6</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">40002688c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">16.818352</span>+<span class="number">0800</span> test[<span class="number">8360:253436</span>] <span class="number">8</span>---&lt;NSThread: <span class="number">0</span>x600000068ec0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">16.818352</span>+<span class="number">0800</span> test[<span class="number">8360:253500</span>] <span class="number">7</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b340</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">17.817353</span>+<span class="number">0800</span> test[<span class="number">8360:253503</span>] <span class="number">5</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b380</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">17.817703</span>+<span class="number">0800</span> test[<span class="number">8360:253501</span>] <span class="number">9</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">40002688c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">17.819481</span>+<span class="number">0800</span> test[<span class="number">8360:253500</span>] <span class="number">7</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b340</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">17.819481</span>+<span class="number">0800</span> test[<span class="number">8360:253436</span>] <span class="number">8</span>---&lt;NSThread: <span class="number">0</span>x600000068ec0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44:18.819172</span>+<span class="number">0800</span> test[<span class="number">8360:253503</span>] <span class="number">10</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b380</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">18.820352</span>+<span class="number">0800</span> test[<span class="number">8360:253500</span>] <span class="number">12</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b340</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19.818892</span>+<span class="number">0800</span> test[<span class="number">8360:253501</span>] <span class="number">9</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">40002688c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19.820372</span>+<span class="number">0800</span> test[<span class="number">8360:253503</span>] <span class="number">10</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b380</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19.821269</span>+<span class="number">0800</span> test[<span class="number">8360:253436</span>] <span class="number">11</span>---&lt;NSThread: <span class="number">0</span>x600000068ec0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19.821381</span>+<span class="number">0800</span> test[<span class="number">8360:253500</span>] <span class="number">12</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b340</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">21.822326</span>+<span class="number">0800</span> test[<span class="number">8360:253436</span>] <span class="number">11</span>---&lt;NSThread: <span class="number">0</span>x600000068ec0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看出：使用子类<code>NSBlockOperation</code>，并调用方法<code>addExecutionBlock:</code>的情况下，<code>blockOperationWithBlock:</code>方法中的操作和<code>addExecutionBlock:</code>中的操作是<strong>在不同的线程中异步执行</strong>的。而且，这次执行结果中<code>blockOperationWithBlock:</code>方法中的操作也不是在当前线程（主线程）中执行的。从而印证了<code>blockOperationWithBlock:</code>中的操作也可能会在其他线程（非当前线程）中执行。</p><p>一般情况下，如果一个NSBlockOperation对象封装了多个操作。NSBlockOperation是否开启新线程，取决于操作的个数。如果添加的操作的个数足够多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p><h4 id="4-1-3-使用自定义继承自NSOperation的子类"><a href="#4-1-3-使用自定义继承自NSOperation的子类" class="headerlink" title="4.1.3 使用自定义继承自NSOperation的子类"></a>4.1.3 使用自定义继承自NSOperation的子类</h4><p>如果使用子类<code>NSInvocationOperation</code>、<code>NSBlockOperation</code>不能满足日常需求，我们可以使用自定义继承自NSOperation的子类。可以通过重写<code>main</code>或者<code>star</code>方法来定义自己的NSOperation对象。<br>重写main方法比较简单，我们不需要管理操作的状态属性<code>isExecuting</code>和<code>isFinished</code>。当<code>main</code>执行完返回的时候，这个操作就结束了。</p><p>先定义一个继承自NSOperation的子类，重写<code>main</code>方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YSCOperation.h 文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YSCOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// YSCOperation.m 文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YSCOperation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YSCOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后使用的时候导入头文件YSCOperation.h。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用自定义继承自 NSOperation 的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)useCustomOperation &#123;</span><br><span class="line">    <span class="comment">// 1.创建 YSCOperation 对象</span></span><br><span class="line">    YSCOperation *op = [[YSCOperation alloc] init];</span><br><span class="line">    <span class="comment">// 2.调用 start 方法开始执行操作</span></span><br><span class="line">    [<span class="meta">op start</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19.821381</span>+<span class="number">0800</span> test[<span class="number">8360:253500</span>] <span class="number">12</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027b340</span>&gt;&#123;number = <span class="number">5</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-24</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">21.822326</span>+<span class="number">0800</span> test[<span class="number">8360:253436</span>] <span class="number">11</span>---&lt;NSThread: <span class="number">0</span>x600000068ec0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看出：在没有使用NSOperationQueue、在主线程单独使用自定义继承在NSoperation的子类的情况下，是在主线程执行操作，并没有开启新线程。</p><p>下边我们来讲讲NSOperationQueue的创建</p><h3 id="4-2-创建队列"><a href="#4-2-创建队列" class="headerlink" title="4.2 创建队列"></a>4.2 创建队列</h3><p>NSOperationQueue一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。</p><ul><li>主队列<ul><li>凡是添加到主队列中的操作，都会放到主线程中执行。</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主队列获取方法</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure><ul><li>自定义队列（非主队列）<ul><li>添加到这种队列中的操作，就会自动放到子线程中执行。</li><li>同事包含了：串行、并发功能</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义队列创建方法</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br></pre></td></tr></table></figure><h3 id="4-3-将操作加入到主队列"><a href="#4-3-将操作加入到主队列" class="headerlink" title="4.3 将操作加入到主队列"></a>4.3 将操作加入到主队列</h3><p>上边我们说到NSOperation需要配合NSOperationQueue来实现多线程。</p><p>那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</p><ol><li><ul><li>(void)addOperation:(NSOperation *)op;<ul><li>需要先创建操作，再将创建好的操作加入到创建好的队列中去。</li></ul></li></ul></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 addOperationWithBlock: 将操作加入到操作队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addOperationWithBlockToQueue &#123;</span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.使用 addOperationWithBlock: 添加操作到队列中</span></span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:51.179870</span>+<span class="number">0800</span> test[<span class="number">1341:30827</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x604000463ec0&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:51.179925</span>+<span class="number">0800</span> test[<span class="number">1341:30826</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000463f00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:51.179931</span>+<span class="number">0800</span> test[<span class="number">1341:30835</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000274740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:51.180024</span>+<span class="number">0800</span> test[<span class="number">1341:30825</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000463e80</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:53.185475</span>+<span class="number">0800</span> test[<span class="number">1341:30826</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000463f00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:53.185480</span>+<span class="number">0800</span> test[<span class="number">1341:30827</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x604000463ec0&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:53.185475</span>+<span class="number">0800</span> test[<span class="number">1341:30835</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000274740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">19:53.185578</span>+<span class="number">0800</span> test[<span class="number">1341:30825</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000463e80</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>可以看出：使用<code>addOperationWithBlock:</code>将操作加入到操作队列后能够开启新线程，进行并发执行。</p><h2 id="5-NSOperationQueue控制串行执行、并发执行"><a href="#5-NSOperationQueue控制串行执行、并发执行" class="headerlink" title="5. NSOperationQueue控制串行执行、并发执行"></a>5. NSOperationQueue控制串行执行、并发执行</h2><p>之前我们说过，NSOperationQueue创建的自定义队列同事具有串行。并发功能，上面我们演示了并发功能，那么他的串行功能是如何实现的呢？</p><p>这里有个关键属性<code>maxConcurrentOperationCount</code>控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。并且一个操作也并非只能在一个线程中运行。</p><ul><li>最大并发操作数：<code>maxConcurrentOperationCount</code><ul><li><code>maxConcurrentOperationCount</code>默认情况下为<em>-1</em>，表示不进行限制，可进行并发执行。</li><li><code>maxConcurrentOperationCount</code>为<em>1</em>时，队列为串行队列。只能串行执行。</li><li><code>maxConcurrentOperationCount</code><em>大于1</em>时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为<code>min{自己设定的值, 系统设定的默认最大值};</code></li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 MaxConcurrentOperationCount（最大并发操作数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setMaxConcurrentOperationCount &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置最大并发操作数</span></span><br><span class="line">    queue.maxConcurrentOperationCount = <span class="number">1</span>; <span class="comment">// 串行队列</span></span><br><span class="line"><span class="comment">// queue.maxConcurrentOperationCount = 2; // 并发队列</span></span><br><span class="line"><span class="comment">// queue.maxConcurrentOperationCount = 8; // 并发队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.添加操作</span></span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"4---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大操作并发数为1时输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">43.406467</span>+<span class="number">0800</span> test[<span class="number">2376:62463</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002740c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">45.411312</span>+<span class="number">0800</span> test[<span class="number">2376:62463</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002740c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50:47.414252</span>+<span class="number">0800</span> test[<span class="number">2376:62460</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002757c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50:49.415113</span>+<span class="number">0800</span> test[<span class="number">2376:62460</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002757c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">51.420317</span>+<span class="number">0800</span> test[<span class="number">2376:62463</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002740c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50:53.421105</span>+<span class="number">0800</span> test[<span class="number">2376:62463</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002740c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50:55.422231</span>+<span class="number">0800</span> test[<span class="number">2376:62460</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002757c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">57.425648</span>+<span class="number">0800</span> test[<span class="number">2376:62460</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00002757c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>最大并发操作数为2时输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">10.540363</span>+<span class="number">0800</span> test[<span class="number">2407:65980</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x604000271ec0&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">10.540361</span>+<span class="number">0800</span> test[<span class="number">2407:65981</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027f440</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">12.543560</span>+<span class="number">0800</span> test[<span class="number">2407:65981</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x600<span class="number">00027f440</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">12.543578</span>+<span class="number">0800</span> test[<span class="number">2407:65980</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x604000271ec0&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53:14.546254</span>+<span class="number">0800</span> test[<span class="number">2407:65982</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000271a00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53:14.546254</span>+<span class="number">0800</span> test[<span class="number">2407:65983</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00004692c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">16.550397</span>+<span class="number">0800</span> test[<span class="number">2407:65982</span>] <span class="number">4</span>---&lt;NSThread: <span class="number">0</span>x6<span class="number">04000271a00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">16.550420</span>+<span class="number">0800</span> test[<span class="number">2407:65983</span>] <span class="number">3</span>---&lt;NSThread: <span class="number">0</span>x60<span class="number">00004692c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程量是由系统决定的，不需要我们来管理。</li></ul><p>这样看来，是比GCD简单了许多！</p><h2 id="6-NSOperation操作依赖"><a href="#6-NSOperation操作依赖" class="headerlink" title="6. NSOperation操作依赖"></a>6. NSOperation操作依赖</h2><p>NSOperation、NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation提供了3个接口供我们管理和查看依赖。</p><ul><li><code>- (void)addDependency:(NSOperation *)op;</code>添加依赖，使当前操作依赖于操作op的完成；</li><li><code>- (void)removeDependency:(NSOperation *)op;</code>移除依赖，取消当前操作对象对操作op的依赖；</li><li><code>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code>在当前操作开始执行之前完成执行的所有操作对象数组；</li></ul><p>当然我们常用到的还是添加依赖操作。现在考虑这样的需求，比如说有A、B两个操作，其中A操作执行完，B操作才能执行。</p><p>如果使用依赖来处理的话，那么久需要让操作B依赖于操作A。具体代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作依赖</span></span><br><span class="line"><span class="comment"> * 使用方法：addDependency:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)addDependency &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建操作</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.添加依赖</span></span><br><span class="line">    [op2 addDependency:op1]; <span class="comment">// 让op2 依赖于 op1，则先执行op1，在执行op2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.添加操作到队列中</span></span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-28</span> <span class="number">11</span>:<span class="number">41</span>:<span class="number">15.838781</span>+<span class="number">0800</span> test[<span class="number">2933:116467</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x<span class="number">60000027d200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">11</span>:<span class="number">41</span>:<span class="number">17.842654</span>+<span class="number">0800</span> test[<span class="number">2933:116467</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x<span class="number">60000027d200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">11</span>:<span class="number">41:19.848179</span>+<span class="number">0800</span> test[<span class="number">2933:116468</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x60000027bd80&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">11</span>:<span class="number">41</span>:<span class="number">21.849031</span>+<span class="number">0800</span> test[<span class="number">2933:116468</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x60000027bd80&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到：通过添加操作依赖，无论运行几次，其结果都是op1先执行，op2后执行。</li></ul><h2 id="7-NSOperation优先级"><a href="#7-NSOperation优先级" class="headerlink" title="7. NSOperation优先级"></a>7. NSOperation优先级</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>NSOperationQueuePriority queuePriority;</span><br></pre></td></tr></table></figure><p>NSOperation提供了<code>queuePriority</code>（优先级）属性，<code>queuePriority</code>属性适用于<em>同一操作队列中</em>的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是<code>NSOperationQueuePriorityNormal</code>。但是我们可以通过<code>setQueuePriority:</code>方法来改变当前操作在同一队列中的执行优先级。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 优先级的取值</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">NSOperationQueuePriority</span>) &#123;</span><br><span class="line">    <span class="type">NSOperationQueuePriorityVeryLow</span> = -8L,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityLow</span> = -4L,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityNormal</span> = 0,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityHigh</span> = 4,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityVeryHigh</span> = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的<strong>开始执行顺序</strong>（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p><p><strong>那么，什么样的操作才是进入就绪状态的操作呢？</strong></p><ul><li>当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。</li></ul><p>举个例子：现在有4个优先级都是NSOperationQueuePriorityNormal(默认级别)的操作：op1、op2、op3、op4。其中op3依赖于op2，op2依赖于op1，即优先级：op1 &gt; op2 &gt; op3 。现在讲这4个操作添加到队列中并发执行。</p><ul><li>因为op1和op4都没有需要依赖的操作，所以在op1，op4执行之前，就是出于准备就绪状态的操作。</li><li>而op3和op2都有依赖的操作（op3依赖于op2，op2依赖于op1），所以op3和op2都不是准备就绪状态下的操作。</li></ul><p>理解了进入就绪状态的操作，那么我们就理解了<code>queuePriority</code>属性的作用对象。</p><ul><li><code>queuePriority</code>属性决定了<strong>进入准备就绪状态下的操作</strong>之间的开始执行顺序。并且，优先级不能取代依赖关系。</li><li>如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。</li><li>如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。</li></ul><h2 id="8-NSOperation、NSOperationQueue线程间的通信"><a href="#8-NSOperation、NSOperationQueue线程间的通信" class="headerlink" title="8.NSOperation、NSOperationQueue线程间的通信"></a>8.NSOperation、NSOperationQueue线程间的通信</h2><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么久用到了线程之间的通讯。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)communication &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.添加操作</span></span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 异步进行耗时操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="comment">// 进行一些 UI 刷新等操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018-05-28</span> <span class="number">14</span>:<span class="number">45:18.184142</span>+<span class="number">0800</span> test[<span class="number">3570:202499</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x60400027cc80&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">14</span>:<span class="number">45:20.189357</span>+<span class="number">0800</span> test[<span class="number">3570:202499</span>] <span class="number">1</span>---&lt;NSThread: <span class="number">0</span>x60400027cc80&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">14</span>:<span class="number">45:22.190944</span>+<span class="number">0800</span> test[<span class="number">3570:202450</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x604000075ac0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-05-28</span> <span class="number">14</span>:<span class="number">45:24.191504</span>+<span class="number">0800</span> test[<span class="number">3570:202450</span>] <span class="number">2</span>---&lt;NSThread: <span class="number">0</span>x604000075ac0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看到：通过线程间的通信，现在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。</p><h2 id="9-NSOperation、NSOperationQueue线程同步和线程安全"><a href="#9-NSOperation、NSOperationQueue线程同步和线程安全" class="headerlink" title="9. NSOperation、NSOperationQueue线程同步和线程安全"></a>9. NSOperation、NSOperationQueue线程同步和线程安全</h2><ul><li><p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></li><li><p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p></li></ul><p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p><p>下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。<br>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p><h3 id="9-1-NSOperation、NSOperationQueue非线程安全"><a href="#9-1-NSOperation、NSOperationQueue非线程安全" class="headerlink" title="9.1 NSOperation、NSOperationQueue非线程安全"></a>9.1 NSOperation、NSOperationQueue非线程安全</h3><p>先来看看不考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非线程安全：不使用 NSLock</span></span><br><span class="line"><span class="comment"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusNotSave &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建 queue1,queue1 代表北京火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue1 = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.创建 queue2,queue2 代表上海火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue2 = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.创建卖票操作 op1</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.创建卖票操作 op2</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.添加操作，开始卖票</span></span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售卖火车票(非线程安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketNotSafe &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还有票，继续售卖</span></span><br><span class="line">            <span class="keyword">self</span>.ticketSurplusCount--;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数:%ld 窗口:%@"</span>, (<span class="keyword">long</span>)<span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread]]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:00.910264<span class="string">+0800</span> test[4059:270790] currentThread---&lt;NSThread: 0x604000078040&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:00.911024<span class="string">+0800</span> test[4059:270854] 剩余票数:48 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:00.911059<span class="string">+0800</span> test[4059:270856] 剩余票数:49 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.113769<span class="string">+0800</span> test[4059:270854] 剩余票数:47 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.113769<span class="string">+0800</span> test[4059:270856] 剩余票数:47 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.315197<span class="string">+0800</span> test[4059:270854] 剩余票数:46 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.315245<span class="string">+0800</span> test[4059:270856] 剩余票数:45 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.516986<span class="string">+0800</span> test[4059:270856] 剩余票数:44 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.516986<span class="string">+0800</span> test[4059:270854] 剩余票数:44 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.720397<span class="string">+0800</span> test[4059:270854] 剩余票数:43 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.720438<span class="string">+0800</span> test[4059:270856] 剩余票数:42 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.923211<span class="string">+0800</span> test[4059:270856] 剩余票数:41 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:01.923234<span class="string">+0800</span> test[4059:270854] 剩余票数:40 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:02.127978<span class="string">+0800</span> test[4059:270856] 剩余票数:39 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:05.783073<span class="string">+0800</span> test[4059:270856] 剩余票数:9 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:05.783073<span class="string">+0800</span> test[4059:270854] 剩余票数:9 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:05.986099<span class="string">+0800</span> test[4059:270856] 剩余票数:8 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:05.986118<span class="string">+0800</span> test[4059:270854] 剩余票数:7 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.190088<span class="string">+0800</span> test[4059:270856] 剩余票数:6 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.190117<span class="string">+0800</span> test[4059:270854] 剩余票数:5 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.394938<span class="string">+0800</span> test[4059:270854] 剩余票数:4 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.394961<span class="string">+0800</span> test[4059:270856] 剩余票数:4 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.596928<span class="string">+0800</span> test[4059:270854] 剩余票数:3 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.597015<span class="string">+0800</span> test[4059:270856] 剩余票数:3 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.800513<span class="string">+0800</span> test[4059:270856] 剩余票数:2 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:06.800513<span class="string">+0800</span> test[4059:270854] 剩余票数:1 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:07.004409<span class="string">+0800</span> test[4059:270854] 剩余票数:0 窗口:&lt;NSThread: 0x600000468500&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:07.004409<span class="string">+0800</span> test[4059:270856] 剩余票数:0 窗口:&lt;NSThread: 0x604000274940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:07.206585<span class="string">+0800</span> test[4059:270854] 所有火车票均已售完</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:52:07.206626<span class="string">+0800</span> test[4059:270856] 所有火车票均已售完</span><br></pre></td></tr></table></figure><p>可以看到：在不考虑线程安全，不适用NSLock情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p><h3 id="9-2-NSOperation、NSOperationQueue线程安全"><a href="#9-2-NSOperation、NSOperationQueue线程安全" class="headerlink" title="9.2 NSOperation、NSOperationQueue线程安全"></a>9.2 NSOperation、NSOperationQueue线程安全</h3><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/get等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。</p><p>考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全：使用 NSLock 加锁</span></span><br><span class="line"><span class="comment"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusSave &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];  <span class="comment">// 初始化 NSLock 对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建 queue1,queue1 代表北京火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue1 = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.创建 queue2,queue2 代表上海火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue2 = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.创建卖票操作 op1</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.创建卖票操作 op2</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.添加操作，开始卖票</span></span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售卖火车票(线程安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketSafe &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        [<span class="keyword">self</span>.lock lock];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还有票，继续售卖</span></span><br><span class="line">            <span class="keyword">self</span>.ticketSurplusCount--;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数:%ld 窗口:%@"</span>, (<span class="keyword">long</span>)<span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread]]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:07.278045<span class="string">+0800</span> test[4089:273593] currentThread---&lt;NSThread: 0x600000067b80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:07.278940<span class="string">+0800</span> test[4089:273667] 剩余票数:49 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:07.483256<span class="string">+0800</span> test[4089:273665] 剩余票数:48 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:07.685471<span class="string">+0800</span> test[4089:273667] 剩余票数:47 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:07.887504<span class="string">+0800</span> test[4089:273665] 剩余票数:46 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:08.087948<span class="string">+0800</span> test[4089:273667] 剩余票数:45 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:08.292016<span class="string">+0800</span> test[4089:273665] 剩余票数:44 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:08.493725<span class="string">+0800</span> test[4089:273667] 剩余票数:43 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:08.698786<span class="string">+0800</span> test[4089:273665] 剩余票数:42 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:08.901019<span class="string">+0800</span> test[4089:273667] 剩余票数:41 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:09.104019<span class="string">+0800</span> test[4089:273665] 剩余票数:40 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:09.305152<span class="string">+0800</span> test[4089:273667] 剩余票数:39 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:09.510415<span class="string">+0800</span> test[4089:273665] 剩余票数:38 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:15.215177<span class="string">+0800</span> test[4089:273665] 剩余票数:10 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:15.420174<span class="string">+0800</span> test[4089:273667] 剩余票数:9 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:15.624998<span class="string">+0800</span> test[4089:273665] 剩余票数:8 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:15.828335<span class="string">+0800</span> test[4089:273667] 剩余票数:7 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:16.033039<span class="string">+0800</span> test[4089:273665] 剩余票数:6 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:16.237666<span class="string">+0800</span> test[4089:273667] 剩余票数:5 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:16.438533<span class="string">+0800</span> test[4089:273665] 剩余票数:4 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:16.643922<span class="string">+0800</span> test[4089:273667] 剩余票数:3 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:16.848878<span class="string">+0800</span> test[4089:273665] 剩余票数:2 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:17.053019<span class="string">+0800</span> test[4089:273667] 剩余票数:1 窗口:&lt;NSThread: 0x60000026da00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:17.257527<span class="string">+0800</span> test[4089:273665] 剩余票数:0 窗口:&lt;NSThread: 0x6000002674c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:17.462667<span class="string">+0800</span> test[4089:273667] 所有火车票均已售完</span><br><span class="line">2018<span class="string">-05</span><span class="string">-28</span> 15:54:17.462668<span class="string">+0800</span> test[4089:273665] 所有火车票均已售完</span><br></pre></td></tr></table></figure><h2 id="10-NSOperation、NSOperationQueue常用属性和方法归纳"><a href="#10-NSOperation、NSOperationQueue常用属性和方法归纳" class="headerlink" title="10. NSOperation、NSOperationQueue常用属性和方法归纳"></a>10. NSOperation、NSOperationQueue常用属性和方法归纳</h2><h3 id="10-1-NSOperation的常用属性和方法"><a href="#10-1-NSOperation的常用属性和方法" class="headerlink" title="10.1 NSOperation的常用属性和方法"></a>10.1 NSOperation的常用属性和方法</h3><ol><li><p>取消操作方法</p><ul><li><code>- (void)cancel;</code>可以取消操作，实质上是标记isCancelled状态。</li></ul></li><li><p>判断操作状态方法</p><ul><li><code>- (BOOL)isFinished;</code>判断操作是否已经结束。</li><li><code>- (BOOL)isCancelled;</code>判断操作是否已经标记为取消。</li><li><code>- (BOOL)isExecuting;</code>判断操作是否正在运行。</li><li><code>- (BOOL)isReady;</code>判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li></ul></li><li><p>操作同步</p><ul><li><code>- (void)waitUntilFinished;</code>阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</li><li><code>- (void)setCompletionBlock:(void(^)(void))block;</code> <code>completionBlock</code>会在当前操作执行完毕时执行completionBlock。</li><li><code>- (void)addDependency:(NSOperation *)op;</code>添加依赖，使当前操作依赖于操作op的完成。</li><li><code>- (void)removeDependency:(NSOperation *)op;</code>移除依赖，取消当前操作对操作op的依赖。</li><li><code>@property(readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</code>在当前操作开始执行之前完成执行的所有操作对象数组。</li></ul></li></ol><h3 id="10-2-NSOperationQueue的常用属性和方法"><a href="#10-2-NSOperationQueue的常用属性和方法" class="headerlink" title="10.2 NSOperationQueue的常用属性和方法"></a>10.2 NSOperationQueue的常用属性和方法</h3><ol><li><p>取消/暂停/恢复操作</p><ul><li><code>- (void)cancelAllOperations;</code>可以取消队列的所有操作</li><li><code>- (BOOL)isSuspended;</code>判断队列是否处于暂停状态。YES为暂停状态，NO为恢复状态。</li><li><code>- (void)setSuspended:(BOOL)b;</code>可设置操作的暂停和恢复，YES代表暂停队列，NO代表恢复队列。</li></ul></li><li><p>操作同步</p><ul><li><code>- (void)waitUntilAllOperationsAreFinished;</code>阻塞当前线程，直到队列中的操作全部执行完毕。</li></ul></li><li><p>添加/获取操作</p><ul><li><code>- (void)addOperationWithBlock:(void(^)(void))block;</code>向队列中添加一个NSBlockOperation类型操作对象。</li><li><code>- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;</code>向队列中添加操作数组，wait标志是否阻塞当前线程直到所有操作结束。</li><li><code>- (NSArray *)operations;</code>当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li><li><code>- (NSUInteger)operationCount;</code>当前队列中的操作数。</li></ul></li><li><p>获取队列</p><ul><li><code>+ (id)currentQueue;</code>获取当前队列，如果当前线程不是在NSOperationQueue上运行则返回nil。</li><li><code>+ (id)mainQueue;</code>获取主队列。</li></ul></li></ol><blockquote><p>注意：</p></blockquote><blockquote><ol><li>这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。</li><li>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</li></ol></blockquote><p>本文系转载，如有侵权，告知我删除。感谢原文:<a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" target="_blank" rel="noopener">iOS多线程：『NSOperation、NSOperationQueue』详尽总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-648123.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文用来介绍iOS多线程中的NSOperation、NSOperationQueue的相关知识及使用方法。&lt;br&gt;通过本文，您将了解到：&lt;br&gt;&lt;strong&gt;NSOperation、NSOperationQueue简介、操作和操作队列、使用步骤和基本使用方法、控制串行/并发执行、NSOperation操作依赖和优先级、线程间的通信、线程同步和线程安全，以及NSOperation、NSOperationQueue常用属性和方法归纳。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="NSOperationQueue" scheme="http://yoursite.com/tags/NSOperationQueue/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程之GCD</title>
    <link href="http://yoursite.com/2018/05/18/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD/"/>
    <id>http://yoursite.com/2018/05/18/iOS多线程之GCD/</id>
    <published>2018-05-17T17:18:30.000Z</published>
    <updated>2018-06-05T06:32:42.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660834.jpg" alt=""></p><blockquote><p>本文用来介绍 iOS 多线程中 GCD的相关知识以及使用方法。通过本文，您将了解到：</p><ol><li>GCD 简介</li><li>GCD 任务和队列</li><li>GCD 的使用步骤</li><li>GCD 的基本使用（6种不同组合区别）</li><li>GCD 线程间的通信</li><li>GCD 的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore</li></ol></blockquote><a id="more"></a><h3 id="1-GCD简介"><a href="#1-GCD简介" class="headerlink" title="1. GCD简介"></a>1. GCD简介</h3><p>什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念</p><blockquote><p>引自百度百科<br>Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p></blockquote><p><strong>为什么要用 GCD 呢？</strong></p><p>因为 GCD 有很多好处啊，具体如下：</p><ul><li>GCD 可用于多核的并行运算</li><li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li><li>既然 GCD 有这么多的好处，那么下面我们就来系统的学习一下 GCD 的使用方法。</li></ul><h3 id="2-GCD任务和队列"><a href="#2-GCD任务和队列" class="headerlink" title="2. GCD任务和队列"></a>2. GCD任务和队列</h3><p>学习 GCD 之前，先来了解 GCD 中两个核心概念：<strong>任务</strong>和<strong>队列</strong>。</p><p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：<strong>同步执行（sync）</strong>和<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力</strong>。</p><ul><li><strong>同步执行（sync）</strong>：<ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul></li><li><strong>异步执行（async）</strong>：<ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul></li></ul><p>举个简单例子：你要打电话给小明和小白。<br>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。<br>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p><blockquote><p>注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p></blockquote><p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：<br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-DispatchQueue.png" alt="image"><br>在 GCD 中有两种队列：<strong>串行队列和并发队列</strong>。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：<strong>执行顺序不同，以及开启线程数不同</strong>。</p><ul><li><strong>串行队列（Serial Dispatch Queue）</strong>：<ul><li>每次只有一个任务被执行。让任务一个接着一个地执行。一个任务执行完毕后，再执行下一个任务。</li><li>只开启一个新线程（或者不开启新线程，在当前线程执行任务）。</li></ul></li><li><strong>并发队列（Concurrent Dispatch Queue）</strong>：<ul><li>可以让多个任务并发（同时）执行。</li><li>可以开启多个线程，并且同时执行任务。<blockquote><p>注意：并发队列的并发功能只有在异步（dispatch_async）函数下才有效。</p></blockquote></li></ul></li></ul><p>两者具体区别如下两图所示。<br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-SerialDispatchQueue.png" alt="image"><br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-ConcurrentDispatchQueue.png" alt="image"></p><h3 id="3-GCD的使用步骤"><a href="#3-GCD的使用步骤" class="headerlink" title="3. GCD的使用步骤"></a>3. GCD的使用步骤</h3><p>GCD 的使用步骤其实很简单，只有两步。</p><blockquote><ol><li>创建一个队列（串行队列或并发队列）</li><li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li></ol></blockquote><p>下边来看看队列的创建方法/获取方法，以及任务的创建方法。</p><h4 id="3-1-队列的创建方法-获取方法"><a href="#3-1-队列的创建方法-获取方法" class="headerlink" title="3.1 队列的创建方法/获取方法"></a>3.1 队列的创建方法/获取方法</h4><p>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列的创建方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><ul><li>对于串行队列，GCD 提供了的一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。<ul><li>所有放在主队列中的任务，都会放到主线程中执行。</li><li>可使用<code>dispatch_get_main_queue()</code>获得主队列。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主队列的获取方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><ul><li>对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue）。<ul><li>可以使用dispatch_get_global_queue来获取。需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局并发队列的获取方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-任务的创建方法"><a href="#3-2-任务的创建方法" class="headerlink" title="3.2 任务的创建方法"></a>3.2 任务的创建方法</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法<code>dispatch_async</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步执行任务创建方法</span></span><br><span class="line"><span class="selector-tag">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放同步执行任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 异步执行任务创建方法</span></span><br><span class="line"><span class="selector-tag">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放异步执行任务代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p><blockquote><ol><li>同步执行 + 并发队列</li><li>异步执行 + 并发队列</li><li>同步执行 + 串行队列</li><li>异步执行 + 串行队列</li></ol></blockquote><p>实际上，刚才还说了两种特殊队列：<strong>全局并发队列、主队列</strong>。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p><blockquote><ol><li>同步执行 + 主队列</li><li>异步执行 + 主队列</li></ol></blockquote><p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。</p><table><thead><tr><th>区别</th><th>并发队列</th><th>串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步(sync)</td><td>没有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td><td>主线程调用：死锁卡住不执行 其他线程调用：没有开启新线程，串行执行任务</td></tr><tr><td>异步(async)</td><td>有开启新线程，并发执行任务</td><td>有开启新线程(1条)，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr></tbody></table><h3 id="4-GCD的基本使用"><a href="#4-GCD的基本使用" class="headerlink" title="4. GCD的基本使用"></a>4. GCD的基本使用</h3><p>先来讲讲并发队列的两种执行方式。</p><h4 id="4-1-同步执行-并发队列"><a href="#4-1-同步执行-并发队列" class="headerlink" title="4.1 同步执行 + 并发队列"></a>4.1 同步执行 + 并发队列</h4><ul><li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">55.095932</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">55.096086</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] syncConcurrent—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">57.097589</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34:59.099100</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35</span>:<span class="number">01.099843</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:03.101171</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:05.101750</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:07.102414</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:07.102575</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] syncConcurrent—end</span><br></pre></td></tr></table></figure><p>从同步执行 + 并发队列中可看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（同步执行不具备开启新线程的能力）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行的（同步任务需要等待队列的任务执行结束）。</li><li>任务按顺序执行的。按顺序执行的原因：虽然并发队列可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（同步任务需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li></ul><h4 id="4-2-异步执行-并发队列"><a href="#4-2-异步执行-并发队列" class="headerlink" title="4.2 异步执行 + 并发队列"></a>4.2 异步执行 + 并发队列</h4><ul><li>可以开启多个线程，任务交替（同时）执行</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：可以开启多个线程，任务交替（同时）执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769269</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769496</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] asyncConcurrent—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769725</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] asyncConcurrent—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774442</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005566</span>] <span class="number">2</span>—&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774440</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005567</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774440</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005565</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779286</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005567</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779302</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005565</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779286</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005566</span>] <span class="number">2</span>—&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在异步执行 + 并发队列中可以看出：</p><ul><li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，可以继续执行任务）。</li></ul><p><strong>接下来再来讲讲串行队列的两种执行方式</strong>。</p><h5 id="4-3-同步执行-串行队列"><a href="#4-3-同步执行-串行队列" class="headerlink" title="4.3 同步执行 + 串行队列"></a>4.3 同步执行 + 串行队列</h5><ul><li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">37.876811</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">37.876998</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] syncSerial—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">39.878316</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">41.879829</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">43.880660</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">45.881265</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">47.882257</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">49.883008</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39:49.883253</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] syncSerial—end</span><br></pre></td></tr></table></figure><p>在同步执行 + 串行队列可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行不具备开启新线程的能力）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><h4 id="4-4-异步执行-串行队列"><a href="#4-4-异步执行-串行队列" class="headerlink" title="4.4 异步执行 + 串行队列"></a>4.4 异步执行 + 串行队列</h4><ul><li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">17.029999</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:17.030212</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] asyncSerial—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">17.030364</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] asyncSerial—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">19.035379</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:21.037140</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:23.042220</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">25.042971</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">27.047690</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">3</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">29.052327</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">3</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在异步执行 + 串行队列可以看到：</p><ul><li>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><p>下边讲讲刚才我们提到过的特殊队列：<strong>主队列</strong>。</p><ul><li>主队列：GCD自带的一种特殊的串行队列<ul><li>所有放在主队列中的任务，都会放到主线程中执行</li><li>可使用dispatch_get_main_queue()获得主队列</li></ul></li></ul><p><strong>我们再来看看主队列的两种组合方式。</strong></p><h4 id="4-5-同步执行-主队列"><a href="#4-5-同步执行-主队列" class="headerlink" title="4.5 同步执行 + 主队列"></a>4.5 同步执行 + 主队列</h4><ul><li>同步执行 + 主队列在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</li></ul><h5 id="4-5-1-在主线程中调用同步执行-主队列"><a href="#4-5-1-在主线程中调用同步执行-主队列" class="headerlink" title="4.5.1 在主线程中调用同步执行 + 主队列"></a>4.5.1 在主线程中调用同步执行 + 主队列</h5><ul><li>互相等待卡住不可行</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点(主线程调用)：互等卡主不执行。</span></span><br><span class="line"><span class="comment"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncMain &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">36.842892</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20041</span>:<span class="number">5030982</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">36.843050</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20041</span>:<span class="number">5030982</span>] syncMain—begin</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>在<code>同步执行 + 主队列</code>可以惊奇的发现：</p><ul><li>在主线程中使用<code>同步执行 + 主队列</code>，追加到主线程的任务1、任务2、任务3都不再执行了，而且<code>syncMain---end</code>也没有打印，在XCode 9上还会报崩溃。这是为什么呢？</li></ul><p>这是因为我们在主线程中执行<code>syncMain</code>方法，相当于把<code>syncMain</code>任务放到了主线程的队列中。而<code>同步执行</code>会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把<code>任务1</code>追加到主队列中，<code>任务1</code>就在等待主线程处理完<code>syncMain</code>任务。而<code>syncMain</code>任务需要等待<code>任务1</code>执行完毕，才能接着执行。</p><p>那么，现在的情况就是<code>syncMain</code>任务和<code>任务1</code>都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p><p><strong>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</strong></p><h5 id="4-5-2-在其他线程中调用同步执行-主队列"><a href="#4-5-2-在其他线程中调用同步执行-主队列" class="headerlink" title="4.5.2 在其他线程中调用同步执行 + 主队列"></a>4.5.2 在其他线程中调用同步执行 + 主队列</h5><ul><li>不会开启新线程，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行 selector 任务</span></span><br><span class="line">[NSThread <span class="string">detachNewThreadSelector:</span><span class="meta">@selector</span>(syncMain) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">19.377321</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] currentThread—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">19.377494</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] syncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">21.384716</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">23.386091</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">25.387687</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">27.388648</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">29.390459</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">31.391965</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">31.392513</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] syncMain—end</span><br></pre></td></tr></table></figure><p>在其他线程中使用<code>同步执行 + 主队列</code>可看到：</p><ul><li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><p><strong>为什么现在就不会卡住了呢？</strong></p><p>因为<code>syncMain</code> 任务放到了其他线程里，而<code>任务1</code>、<code>任务2</code>、<code>任务3</code>都在追加到主队列中，这三个任务都会在主线程中执行。<code>syncMain</code>任务在其他线程中执行到追加<code>任务1</code>到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的<code>任务1</code>，等<code>任务1</code>执行完毕，再接着执行<code>任务2</code>、<code>任务3</code>。所以这里不会卡住线程。</p><h3 id="4-6-异步执行-主队列"><a href="#4-6-异步执行-主队列" class="headerlink" title="4.6 异步执行 + 主队列"></a>4.6 异步执行 + 主队列</h3><ul><li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncMain &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.981505</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.981935</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] asyncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.982352</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] asyncMain—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">51.991096</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">53.991959</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">55.992937</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">57.993649</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">59.994928</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">01.995589</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>在<code>异步执行 + 主队列</code>可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（因为主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。<br>弄懂了难理解、绕来绕去的<strong>队列+任务</strong>之后，我们来学习一个简单的东西：<strong>5. GCD 线程间的通信。</strong></li></ul><h3 id="5-GCD-线程间的通信"><a href="#5-GCD-线程间的通信" class="headerlink" title="5. GCD 线程间的通信"></a>5. GCD 线程间的通信</h3><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)communication &#123;</span><br><span class="line">    <span class="comment">// 获取全局并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">// 获取主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue(); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 异步追加任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            <span class="comment">// 追加在主线程中执行的任务</span></span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">03.462394</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5053282</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">05.465912</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5053282</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">07.466657</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5052953</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li></ul><h3 id="6-GCD的其他方法"><a href="#6-GCD的其他方法" class="headerlink" title="6. GCD的其他方法"></a>6. GCD的其他方法</h3><h4 id="6-1-GCD-栅栏方法：dispatch-barrier-async"><a href="#6-1-GCD-栅栏方法：dispatch-barrier-async" class="headerlink" title="6.1 GCD 栅栏方法：dispatch_barrier_async"></a>6.1 GCD 栅栏方法：dispatch_barrier_async</h4><ul><li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于<code>栅栏</code>一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到<code>dispatch_barrier_async</code>方法在两个操作组间形成栅栏。</li></ul><p><code>dispatch_barrier_async</code>函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在<code>dispatch_barrier_async</code>函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-barrier.png" alt="image"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栅栏方法 dispatch_barrier_async</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)barrier &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务 barrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"barrier---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);<span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务4</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"4---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">18.297745</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">1</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">18.297745</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48:20.301139</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">1</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48:20.301139</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">22.306290</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] barrier—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">24.311655</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] barrier—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">26.316943</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">4</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">26.316956</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">28.320660</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">4</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">28.320649</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在<code>dispatch_barrier_async</code>执行结果中可以看出：</p><ul><li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li></ul><h4 id="6-2-GCD-延时执行方法：dispatch-after"><a href="#6-2-GCD-延时执行方法：dispatch-after" class="headerlink" title="6.2 GCD 延时执行方法：dispatch_after"></a>6.2 GCD 延时执行方法：dispatch_after</h4><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的<code>dispatch_after</code>函数来实现。</p><p><strong>需要注意的是</strong>:<code>dispatch_after</code>函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code>函数是很有效的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时执行方法 dispatch_after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)after &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 2.0秒后异步追加任务代码到主队列，并开始执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"after---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">08.713784</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">08.713962</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] asyncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">10.714283</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] after—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看出：在打印 <code>asyncMain---begin</code> 之后大约 <strong>2.0</strong> 秒的时间，打印了 <code>after---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}</code></p><p>本文系转载，如有侵权，告知我删除。感谢原文：<br><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程GCD详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660834.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文用来介绍 iOS 多线程中 GCD的相关知识以及使用方法。通过本文，您将了解到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCD 简介&lt;/li&gt;
&lt;li&gt;GCD 任务和队列&lt;/li&gt;
&lt;li&gt;GCD 的使用步骤&lt;/li&gt;
&lt;li&gt;GCD 的基本使用（6种不同组合区别）&lt;/li&gt;
&lt;li&gt;GCD 线程间的通信&lt;/li&gt;
&lt;li&gt;GCD 的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="GCD" scheme="http://yoursite.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程之pthread、NSThread</title>
    <link href="http://yoursite.com/2018/05/15/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bpthread%E3%80%81NSThread/"/>
    <id>http://yoursite.com/2018/05/15/iOS多线程之pthread、NSThread/</id>
    <published>2018-05-15T14:32:42.000Z</published>
    <updated>2018-06-05T06:35:51.456Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660819.jpg" alt=""></p><blockquote><p>本文用来介绍 iOS 多线程中，pthread、NSThread 的使用方法及实现。<br>第一部分：pthread 的使用、其他相关方法。<br>第二部分：NSThread 的使用、线程相关用法、线程状态控制方法、线程之间的通信、线程安全和线程同步，以及线程的状态转换相关知识。</p></blockquote><a id="more"></a><h2 id="1-pthread"><a href="#1-pthread" class="headerlink" title="1. pthread"></a>1. pthread</h2><h3 id="1-1-pthread简介"><a href="#1-1-pthread简介" class="headerlink" title="1.1 pthread简介"></a>1.1 pthread简介</h3><p>pthread 是一套通用的多线程的 API，可以在Unix / Linux / Windows 等系统跨平台使用，使用 C 语言编写，需要程序员自己管理线程的生命周期，使用难度较大，我们在 iOS 开发中几乎不使用 pthread，但是还是来可以了解一下的。</p><h3 id="1-2-pthread使用方法"><a href="#1-2-pthread使用方法" class="headerlink" title="1.2 pthread使用方法"></a>1.2 pthread使用方法</h3><ol><li>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></li><li>其次要创建线程，并开启线程执行任务</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程: 定义一个pthread_t类型变量</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="comment">// 2. 开启线程: 执行任务</span></span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 3. 设置子线程的状态设置为 detached，该线程运行结束后会自动释放所有资源</span></span><br><span class="line">pthread_detach(thread);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">run</span><span class="params">(<span class="keyword">void</span> *param)</span>    <span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>pthread_create(&amp;thread, NULL, run, NULL);</code> 中各项参数含义：<ul><li>第一个参数<code>&amp;thread</code>是线程对象，指向线程标识符的指针</li><li>第二个是线程属性，可赋值<code>NULL</code></li><li>第三个<code>run</code>表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li><li>第四个是运行函数的参数，可赋值<code>NULL</code></li></ul></li></ul><h3 id="1-3-pthread-其他相关方法"><a href="#1-3-pthread-其他相关方法" class="headerlink" title="1.3 pthread 其他相关方法"></a>1.3 pthread 其他相关方法</h3><ul><li><code>pthread_create()</code> 创建一个线程</li><li><code>pthread_exit()</code> 终止当前线程</li><li><code>pthread_cancel()</code> 中断另外一个线程的运行</li><li><code>pthread_join()</code> 阻塞当前的线程，直到另外一个线程运行结束</li><li><code>pthread_attr_init()</code> 初始化线程的属性</li><li><code>pthread_attr_setdetachstate()</code> 设置脱离状态的属性（决定这个线程在终止时是否可以被结合）</li><li><code>pthread_attr_getdetachstate()</code> 获取脱离状态的属性</li><li><code>pthread_attr_destroy()</code> 删除线程的属性</li><li><code>pthread_kill()</code> 向线程发送一个信号</li></ul><h2 id="2-NSThread"><a href="#2-NSThread" class="headerlink" title="2. NSThread"></a>2. NSThread</h2><p>NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用<code>[NSThread currentThread]</code>来显示当前的进程信息。</p><h3 id="2-1-创建、启动线程"><a href="#2-1-创建、启动线程" class="headerlink" title="2.1 创建、启动线程"></a>2.1 创建、启动线程</h3><ul><li>先创建线程，再启动线程</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 2. 启动线程</span></span><br><span class="line">[thread start];    <span class="comment">// 线程一启动，就会在线程thread中执行self的run方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建线程后自动启动线程</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程后自动启动线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>隐式创建并启动线程</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程后自动启动线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-线程相关用法"><a href="#2-2-线程相关用法" class="headerlink" title="2.2 线程相关用法"></a>2.2 线程相关用法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得主线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为主线程(对象方法)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为主线程(类方法)</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *current = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的名字——setter方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的名字——getter方法</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure><h3 id="2-3-线程状态控制方法"><a href="#2-3-线程状态控制方法" class="headerlink" title="2.3 线程状态控制方法"></a>2.3 线程状态控制方法</h3><ul><li>启动线程方法</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start;</span><br><span class="line"><span class="comment">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span></span><br></pre></td></tr></table></figure><ul><li>阻塞（暂停）线程方法</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="string">sleepUntilDate:</span>(NSDate *)date;</span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">sleepForTimeInterval:</span>(NSTimeInterval)ti;</span><br><span class="line"><span class="comment">// 线程进入阻塞状态</span></span><br></pre></td></tr></table></figure><ul><li>强制停止线程</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)<span class="keyword">exit</span>;</span><br><span class="line"><span class="regexp">//</span> 线程进入死亡状态</span><br></pre></td></tr></table></figure><h3 id="2-4-线程之间的通信"><a href="#2-4-线程之间的通信" class="headerlink" title="2.4 线程之间的通信"></a>2.4 线程之间的通信</h3><p>在开发中，我们经常会在子线程中进行耗时操作，操作结束后再回到主线程去刷新UI。这就涉及到了子线程和主线程之间的通信。先来了解一下官方关于NSThread的线程间通信的方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在主线程上执行操作</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait;</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait modes:<span class="params">(NSArray&lt;NSString *&gt; *)</span>array;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">// 在指定线程上执行操作</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector onThread:<span class="params">(NSThread *)</span>thr withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait modes:<span class="params">(NSArray *)</span>array NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector onThread:<span class="params">(NSThread *)</span>thr withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line"></span><br><span class="line">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object1 withObject:<span class="params">(id)</span>object2;</span><br></pre></td></tr></table></figure><p>我们通过一个经典的下载图片的DEMO来展示线程间的通信。具体步骤如下：</p><ol><li>开启一个子线程，在子线程中下载图片</li><li>回到主线程刷新UI，将图片展示在UIImageView中</li></ol><p>DEMO代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个线程下载图片</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImageOnSubThread &#123;</span><br><span class="line"><span class="comment">// 在创建的子线程中调用downloadImage下载图片</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(downloadImage) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下载图片，下载完之后回到主线程进行 UI 刷新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImage &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取图片 imageUrl</span></span><br><span class="line"><span class="built_in">NSURL</span> *imageUrl = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-icon.jpg"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 imageUrl 中读取数据(下载图片) -- 耗时操作</span></span><br><span class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</span><br><span class="line"><span class="comment">// 通过二进制 data 创建 image</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 回到主线程进行图片赋值和界面刷新</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(refreshOnMainThread:) withObject:image waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 回到主线程进行图片赋值和界面刷新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)refreshOnMainThread:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值图片到imageview</span></span><br><span class="line"><span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-线程安全与线程同步"><a href="#2-5-线程安全与线程同步" class="headerlink" title="2.5 线程安全与线程同步"></a>2.5 线程安全与线程同步</h3><p><strong>线程安全：</strong>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行的结果和单线程运行的结果是一样的，而且其他的变量的值也和预期是一样的，就是线程安全的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；<br>若有多个线程同时执行写操作（更改变量），一般都要考虑线程同步，否则的话就可能影响线程安全。</p><p><strong>线程同步：</strong>可以理解为线程A和线程B一块儿配合，A执行到一定的程度是要依靠线程B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。</p><p>举个简单的例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清楚（操作冲突）。等一个人说完（一个线程结束操作），另一个再说，（两一个线程再开始操作）。</p><p>下面，我们将模拟火车篇售卖的方式，实现NSThread线程安全和解决线程同步的问题。</p><p><strong>场景：</strong>总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同事售卖火车票，卖完为止。</p><h4 id="2-5-1-NSThread非线程安全"><a href="#2-5-1-NSThread非线程安全" class="headerlink" title="2.5.1 NSThread非线程安全"></a>2.5.1 NSThread非线程安全</h4><p>先看看不考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusNotSave &#123;</span><br><span class="line"><span class="comment">// 1. 设置剩余火车票为 50</span></span><br><span class="line"><span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置北京火车票售卖窗口的线程</span></span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow1 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow1.name = <span class="string">@"北京火车票售票窗口"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置上海火车票售卖窗口的线程</span></span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow2 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow2.name = <span class="string">@"上海火车票售票窗口"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 开始售卖火车票</span></span><br><span class="line">[<span class="keyword">self</span>.ticketSaleWindow1 start];</span><br><span class="line">[<span class="keyword">self</span>.ticketSaleWindow2 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 售卖火车票(非线程安全)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketNotSafe &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果还有票，继续售卖</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.ticketSurplusCount --;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>,<span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread].name]);</span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//如果已卖完，关闭售票窗口</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后部分结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.428108+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：48 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.428112+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：49 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.631715+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：47 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.631715+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：46 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.833247+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：45 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.833289+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：45 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.038194+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：44 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.038223+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：43 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.239316+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：42 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.239318+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：42 窗口：北京火车票售票窗口</span><br></pre></td></tr></table></figure><p>可以看到在不考虑线程安全的情况下，得到的票数是错乱的，这样显示不符合我们的需求，所以我们需要考虑线程安全的问题。</p><h4 id="2-5-2-NSThread线程安全"><a href="#2-5-2-NSThread线程安全" class="headerlink" title="2.5.2 NSThread线程安全"></a>2.5.2 NSThread线程安全</h4><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS实现线程加锁有很多种方式：@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。<br>为了简单起见，这里不对各种锁的解决方案和性能做分析，只用最简单的@synchronized来保证线程安全，从而解决线程同步的问题。</p><p>考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusNotSave &#123;</span><br><span class="line">    <span class="comment">// 1. 设置剩余火车票为 50</span></span><br><span class="line">    <span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 设置北京火车票售卖窗口的线程</span></span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow1 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span>     selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow1.name = <span class="string">@"北京火车票售票窗口"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置上海火车票售卖窗口的线程</span></span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow2 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span>     selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow2.name = <span class="string">@"上海火车票售票窗口"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 开始售卖火车票</span></span><br><span class="line">    [<span class="keyword">self</span>.ticketSaleWindow1 start];</span><br><span class="line">    [<span class="keyword">self</span>.ticketSaleWindow2 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售卖火车票(非线程安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketNotSafe &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还有票，继续售卖</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.ticketSurplusCount --;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>,<span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread].name]);</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果已卖完，关闭售票窗口</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:20.789485+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：49 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:20.993775+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：48 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.196806+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：47 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.401549+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：46 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.606336+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：45 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.809718+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：44 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.015090+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：43 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.219827+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：42 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.423403+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：41 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.625025+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：40 窗口：上海火车票售票窗口</span><br></pre></td></tr></table></figure><p>可以看出，在考虑了线程安全的情况下，加锁之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p><h3 id="2-6-线程的状态转换"><a href="#2-6-线程的状态转换" class="headerlink" title="2.6 线程的状态转换"></a>2.6 线程的状态转换</h3><p>当我们新建一条线程<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</code>，在内存中的表现为：</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange.png" alt=""></p><p>当调用<code>[thread start];</code>后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示：</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange1.png" alt=""></p><p>当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange2.png" alt=""></p><p><strong>下边我们来看看当前线程的状态转换：</strong></p><ul><li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li><li>如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。</li><li>如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。</li></ul><p>只看文字可能不太好理解，具体当前线程对象的状态变化如下图所示。</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange3.png" alt=""></p><p>本文系转载，如有侵权，告知我删除。感谢原文：<a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660819.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文用来介绍 iOS 多线程中，pthread、NSThread 的使用方法及实现。&lt;br&gt;第一部分：pthread 的使用、其他相关方法。&lt;br&gt;第二部分：NSThread 的使用、线程相关用法、线程状态控制方法、线程之间的通信、线程安全和线程同步，以及线程的状态转换相关知识。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="NSThread" scheme="http://yoursite.com/tags/NSThread/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程之RunLoop</title>
    <link href="http://yoursite.com/2018/05/10/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BRunLoop/"/>
    <id>http://yoursite.com/2018/05/10/iOS多线程之RunLoop/</id>
    <published>2018-05-10T14:32:42.000Z</published>
    <updated>2018-06-05T06:46:24.008Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-659241.jpg" alt=""></p><p><strong>本篇包括以下内容：</strong></p><ul><li>RunLoop简介</li><li>RunLoop相关类</li><li>RunLoop原理</li><li>RunLoop实战应用</li></ul><a id="more"></a><h2 id="1-RunLoop简介"><a href="#1-RunLoop简介" class="headerlink" title="1. RunLoop简介"></a>1. RunLoop简介</h2><h3 id="1-1-什么是RunLoop？"><a href="#1-1-什么是RunLoop？" class="headerlink" title="1.1 什么是RunLoop？"></a>1.1 什么是RunLoop？</h3><p>可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。哈哈，我更愿意翻译为『跑圈』。直观理解就像是不停的跑圈。</p><p>RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。</p><h3 id="1-2-RunLoop和线程"><a href="#1-2-RunLoop和线程" class="headerlink" title="1.2 RunLoop和线程"></a>1.2 RunLoop和线程</h3><p>RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。</p><p>一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。<br>我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。<br>RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。<br>主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。</p><h3 id="1-3-默认情况下主线程的RunLoop原理"><a href="#1-3-默认情况下主线程的RunLoop原理" class="headerlink" title="1.3 默认情况下主线程的RunLoop原理"></a>1.3 默认情况下主线程的RunLoop原理</h3><p>我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中UIApplicationMain函数内部帮我们开启了主线程的RunLoop，<code>UIApplicationMain</code>内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;        </span><br><span class="line">    BOOL <span class="built_in">running</span> = YES;</span><br><span class="line">    <span class="built_in">do</span> &#123;</span><br><span class="line">        <span class="comment">// 执行各种任务，处理各种事件</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="built_in">while</span> (<span class="built_in">running</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。</p><p>下图是苹果官方给出的RunLoop模型图。</p><p><img src="https://upload-images.jianshu.io/upload_images/1877784-6ab632fc118e31f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。</p><h2 id="2-RunLoop相关类"><a href="#2-RunLoop相关类" class="headerlink" title="2. RunLoop相关类"></a>2. RunLoop相关类</h2><p>下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。</p><ul><li>CFRunLoopRef：代表RunLoop的对象</li><li>CFRunLoopModeRef：RunLoop的运行模式</li><li>CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源</li><li>CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源</li><li>CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变</li></ul><p>下边详细讲解下几种类的具体含义和关系。</p><p>先来看一张表示这5个类的关系图（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>）。<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt=""></p><p>接着来讲解这5个类的相互关系（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>），这篇文章总结的特别好，就拿来参考一下，有兴趣的朋友可以去看看，写的很好。</p><p>一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。</p><ul><li>每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。</li><li>如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。</li><li>这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响。</li></ul><p><strong>下边我们来详细讲解下这五个类：</strong></p><h3 id="2-1-CFRunLoopRef"><a href="#2-1-CFRunLoopRef" class="headerlink" title="2.1 CFRunLoopRef"></a>2.1 CFRunLoopRef</h3><p>CFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：</p><ul><li>Core Foundation<ul><li>CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</li><li>CFRunLoopGetMain(); // 获得主线程的RunLoop对象</li></ul></li></ul><p>当然，在Foundation框架下获取RunLoop对象类的方法如下：</p><ul><li>Foundation<ul><li>[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</li><li>[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</li></ul></li></ul><h3 id="2-2-CFRunLoopModeRef"><a href="#2-2-CFRunLoopModeRef" class="headerlink" title="2.2 CFRunLoopModeRef"></a>2.2 CFRunLoopModeRef</h3><p>系统默认定义了多种运行模式（CFRunLoopModeRef），如下：</p><ol><li><strong>kCFRunLoopDefaultMode</strong>：App的默认运行模式，通常主线程是在这个运行模式下运行</li><li><strong>UITrackingRunLoopMode</strong>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li><li>UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li><li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li><li><strong>kCFRunLoopCommonModes</strong>：伪模式，不是一种真正的运行模式（后边会用到）</li></ol><p>其中<strong>kCFRunLoopDefaultMode</strong>、<strong>UITrackingRunLoopMode</strong>、<strong>kCFRunLoopCommonModes</strong>是我们开发中需要用到的模式，具体使用方法我们在 <strong>2.3 CFRunLoopTimerRef</strong> 中结合CFRunLoopTimerRef来演示说明。</p><h3 id="2-3-CFRunLoopTimerRef"><a href="#2-3-CFRunLoopTimerRef" class="headerlink" title="2.3 CFRunLoopTimerRef"></a>2.3 CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer（哈哈，这个理解就简单了吧）。</p><p>下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法，从而加深理解。</p><ol><li>首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。</li><li>在ViewController.m文件中加入以下代码，来演示。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个定时器，约定两秒之后调用self的run方法</span></span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。</li><li>但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。</li></ol><p>这是因为：</p><ul><li>当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。</li><li>而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。</li><li>但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。</li></ul><p>你可以试着将上述代码中的<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>语句换为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</code>，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。</p><p>那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？</p><p>当然可以，这就用到了我们之前说过的<strong>伪模式（kCFRunLoopCommonModes）</strong>，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。</p><p>那么哪些模式被标记上了Common Modes呢？</p><p><strong>NSDefaultRunLoopMode</strong> 和 <strong>UITrackingRunLoopMode</strong>。</p><p>所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。</p><p>具体做法就是讲添加语句改为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p><p>既然讲到了NSTimer，这里顺便讲下NSTimer中的<code>scheduledTimerWithTimeInterval</code>方法和RunLoop的关系。添加下面的代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">2.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(run) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br></pre></td></tr></table></figure><p>这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">2.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(run) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure><h3 id="2-4-CFRunLoopSourceRef"><a href="#2-4-CFRunLoopSourceRef" class="headerlink" title="2.4 CFRunLoopSourceRef"></a>2.4 CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。</p><ul><li><p>第一种按照官方文档来分类（就像RunLoop模型图中那样）：</p><ul><li>Port-Based Sources（基于端口）</li><li>Custom Input Sources（自定义）</li><li>Cocoa Perform Selector Sources</li></ul></li><li><p>第二种按照函数调用栈来分类：</p><ul><li>Source0 ：非基于Port</li><li>Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件</li></ul></li></ul><p>这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。</p><p>下边我们举个例子大致来了解一下函数调用栈和Source。</p><ol><li>在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。</li><li>然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/1877784-f801715c95de19f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>然后运行程序，并点击按钮。</li><li>然后在项目中单击下图红色部分。<br><img src="https://upload-images.jianshu.io/upload_images/1877784-970c15ff611d4d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>可以看到如下图所示的就是点击事件产生的函数调用栈。<br><img src="https://upload-images.jianshu.io/upload_images/1877784-c014e77adce248c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p>所以，点击事件是这样来的：</p><ol><li><p>首先启动程序，调用16行的main函数，main函数调用15行的UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。</p></li><li><p>同时我们可以看到11行中有Source0，也就是说我们点击函数是属于Source0函数的，点击事件就是在Source0中处理的。</p></li><li><p>而至于Source1，则是用来接收、分发系统事件，然后在分发到Source0中处理的。</p></li></ol><h3 id="2-5-CFRunLoopObserverRef"><a href="#2-5-CFRunLoopObserverRef" class="headerlink" title="2.5 CFRunLoopObserverRef"></a>2.5 CFRunLoopObserverRef</h3><p>CFRunLoopObserver是观察者，用来监听RunLoop的状态改变。</p><p>CFRunLoopObserver可以监听的状态改变有以下几种：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),               <span class="comment">// 即将进入Loop：1</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),        <span class="comment">// 即将处理Timer：2    </span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),       <span class="comment">// 即将处理Source：4</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),       <span class="comment">// 即将进入休眠：32</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),        <span class="comment">// 即将从休眠中唤醒：64</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),                <span class="comment">// 即将从Loop中退出：128</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U       <span class="comment">// 监听全部状态改变  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下边我们通过代码来监听下RunLoop中的状态改变。</p><ol><li>在viewController.m中添加如下代码。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建观察者</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"监听到RunLoop发生改变---%zd"</span>,activity);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者到当前RunLoop中</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放observer，最后添加完需要释放掉</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后运行，看下打印结果:</li></ol><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.694917<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.695057<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.695230<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.695338<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696426<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696564<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696686<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696784<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696904<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-32</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713356<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-64</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713527<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713655<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713759<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-32</span></span><br></pre></td></tr></table></figure><p>可以看到RunLoop状态在不断的变化，最终变成了状态32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。</p><h2 id="3-RunLoop原理"><a href="#3-RunLoop原理" class="headerlink" title="3.RunLoop原理"></a>3.RunLoop原理</h2><p>好了，五个类都讲解完了，下边开始放大招了。这下我们就可以来理解RunLoop的运行逻辑了。</p><p>下边上一张之前提到的文章中博主提供的运行逻辑图<br><img src="https://upload-images.jianshu.io/upload_images/1877784-94c6cdb3a7864593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这张图对于我们理解RunLoop来说太有帮助了，下边我们可以来说下官方文档给我们的RunLoop逻辑。</p><p>在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。</p><p>具体顺序如下：</p><ol><li>通知观察者RunLoop已经启动</li><li>通知观察者即将要开始的定时器</li><li>通知观察者任何即将要启动的非基于端口的源</li><li>启动任何准备好的非基于端口的源</li><li>如果基于端口的源准备好并处于等待状态，立即启动，并进入步骤9</li><li>通知观察者线程进入休眠状态</li><li>将线程置于休眠直到任一下面的时间发生：<ul><li>某一事件到达基于端口的源</li><li>定时器启动</li><li>RunLoop设置的时间已经超时</li><li>RunLoop被显示唤醒</li></ul></li><li>通知观察者线程即将被唤醒</li><li>处理未处理的事件<ul><li>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2</li><li>如果输入源启动，传递相应的消息</li><li>如果RunLoop被显示唤醒且事件还没超时，重启RunLoop。进入步骤2</li></ul></li><li>通知观察者RunLoop结束</li></ol><h2 id="4-RunLoop实战应用"><a href="#4-RunLoop实战应用" class="headerlink" title="4. RunLoop实战应用"></a>4. RunLoop实战应用</h2><p>下面讲一下RunLoop的几种应用。</p><h3 id="4-1-NSTimer的使用"><a href="#4-1-NSTimer的使用" class="headerlink" title="4.1 NSTimer的使用"></a>4.1 NSTimer的使用</h3><p>NSTimer的使用方法在讲解CFRunLoopTimerRef类的时候详细讲解过，具体参考上边 <strong>2.3 CFRunLoopTimerRef</strong>。</p><h3 id="4-2-ImageView推迟显示"><a href="#4-2-ImageView推迟显示" class="headerlink" title="4.2 ImageView推迟显示"></a>4.2 ImageView推迟显示</h3><p>有时候，我们会遇到这种情况：<br>当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。</p><p>怎么解决这个问题呢？</p><p>这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：</p><ol><li><strong>监听UIScrollView的滚动</strong></li></ol><p>因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。</p><ol start="2"><li><strong>利用PerformSelector设置当前线程的RunLoop的运行模式</strong></li></ol><p>利用performSelector方法为UIImageView调用setImage:方法，并利用inModes将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.imageView <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">setImage:</span>) <span class="string">withObject:</span>[UIImage <span class="string">imageNamed:</span>@<span class="string">"tupian"</span>] <span class="string">afterDelay:</span><span class="number">4.0</span> <span class="string">inModes:</span>NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure><p>下面用Demo演示一下：</p><ol><li>在项目中的Main.storyboard中添加一个UIImageView，并添加属性，并简单添加一下约束（不然无法显示）如下图所示</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1877784-8253c4b57f1b674e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="2"><li>在项目中拖入一张图片，如下图</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1877784-b4777f945878a0b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="3"><li>然后我们在touchesBegan方法中添加下面的代码</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet&lt;UITouch *&gt; *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self.imageView <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">setImage:</span>) <span class="string">withObject:</span>[UIImage <span class="string">imageNamed:</span>@<span class="string">"tupian"</span>] <span class="string">afterDelay:</span><span class="number">4.0</span> <span class="string">inModes:</span>@[NSDefaultRunLoopMode]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行程序，点击一下屏幕，然后拖动UIText View，拖动4秒以上，发现过了4秒之后，UIImageView还没有显示图片，当我们松开的时候，则显示图片，效果如下：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1877784-13880540c8c89552.gif?imageMogr2/auto-orient/strip" alt=""></p><p>这样我们就实现了在拖动完之后，在延迟显示UIImageView.</p><h3 id="4-3-后台常驻线程（很常用）"><a href="#4-3-后台常驻线程（很常用）" class="headerlink" title="4.3 后台常驻线程（很常用）"></a>4.3 后台常驻线程（很常用）</h3><p>我们在开发应用程序的时候，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好让这条线程永远常驻内存。</p><p>那么怎么做呢？</p><p>添加一条用于常驻内存强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。</p><p>具体实现过程如下：</p><ol><li>在项目的viewController.m中添加一条强引用的thread线程属性，如下：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"viewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">viewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在viewDidLoad中创建线程self.thread，使线程启动并执行run1方法</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，并调用run1方法执行任务</span></span><br><span class="line">    <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run1) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 开启线程</span></span><br><span class="line">    [<span class="keyword">self</span>.thread start];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里写任务</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----run1-----"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"未开启RunLoop"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行之后发现打印了 <em>—-run1—-</em>，而 <em>未开启RunLoop</em> 则未打印。</li></ol><p>这时，我们就开启了一条常驻线程，下面我们来试着添加其他任务，除了之前创建的时候调用了run1方法，我们另外在点击的时候调用run2方法</p><p>那么，我们在touchesBegan中调用PerformSelector，从而实现在点击屏幕的时候调用run2方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 利用performSelector，在self.thread的线程中调用run2方法执行任务</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run2) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----run2------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过运行测试，除了之前打印的<em>—-run1—-</em>，每当我们点击屏幕，都能调用<em>—-run2—-</em>。<br>这样我们就实现了常驻线程的需求。</p><p>本文系转载，如有侵权，告知我删除。 感谢原文：<a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">彻底学会多线程之『RunLoop』</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-659241.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇包括以下内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RunLoop简介&lt;/li&gt;
&lt;li&gt;RunLoop相关类&lt;/li&gt;
&lt;li&gt;RunLoop原理&lt;/li&gt;
&lt;li&gt;RunLoop实战应用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="RunLoop" scheme="http://yoursite.com/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>追忆</title>
    <link href="http://yoursite.com/2017/06/09/%E8%BF%BD%E5%BF%86/"/>
    <id>http://yoursite.com/2017/06/09/追忆/</id>
    <published>2017-06-09T09:52:21.000Z</published>
    <updated>2018-06-07T10:03:02.483Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660821.jpg" alt=""></p><p><del>一首歌，一个故事，一个人，一个世界</del></p><a id="more"></a><p>突然听到一首歌<br>想起是你曾经很喜欢的歌<br>“你说过牵了手就算约定”<br>“但亲爱的那并不是爱情”</p><p>虽然这么多年过去了<br>虽然好几年没联系了<br>但关于你的一切都在遇到熟悉的东西时不自然的想起</p><p>把你送我的东西整理起来<br>当年没勇气带在身边<br>但后来朋友告诉我把东西弄丢了<br>我的内心几乎是崩溃的<br>仿佛感觉我的青春被焚烧了一般<br>感觉自己永远都不会再拥有青春</p><p>现在<br>我们成了永远的陌路人<br>但我们一起走过的青春岁月<br>我会一直记得<br>那是生命中最美好的部分</p><p>其实<br>我一直想告诉你<br>男人是需要成长的<br>如果当年我有你那样成熟的高度<br>且不那么懦弱的面对一些现实问题<br>也许…<br>罢了…<br>如果就是如果<br>也许也只能是也许<br>现在想起那句一个男人在最无用的时候<br>遇到想要保护一生的女人<br>奈何奈何</p><p>现在我成长了<br>我不在渴求那样的爱情<br>我也从不觉得年近而立就得恋爱结婚<br>一个人的日子有点孤单<br>但也自在快乐</p><p>现在我没有你的消息<br>你不需要我的消息<br>但我永远祝福你过的比我好<br>祝福你一定要幸福</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=36841953&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660821.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;一首歌，一个故事，一个人，一个世界&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="流金岁月" scheme="http://yoursite.com/categories/%E6%B5%81%E9%87%91%E5%B2%81%E6%9C%88/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>swift入门项目实战之遇坑出坑</title>
    <link href="http://yoursite.com/2017/05/27/swift%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E9%81%87%E5%9D%91%E5%87%BA%E5%9D%91/"/>
    <id>http://yoursite.com/2017/05/27/swift入门项目实战之遇坑出坑/</id>
    <published>2017-05-27T07:10:22.000Z</published>
    <updated>2018-06-05T06:55:54.314Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-658274.jpg" alt=""></p><p>本篇主要是关于</p><ol><li>初学swift时，练手的一个demo</li><li>遇到的一点坑及如何解决的</li></ol><p>有兴趣的朋友可以看看<a href="https://github.com/SPIREJ/XSLC_Swift" target="_blank" rel="noopener">demo</a></p><a id="more"></a><p><strong>环境：swift版本3.0</strong></p><ul><li>首页：<ul><li>首页主要由banner、collectionView、tableView 组成</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-8dd445ec88ad80c9.gif?imageMogr2/auto-orient/strip" alt="首页"></p><ul><li>理财页<ul><li>理财列表页、计划详情页以及键盘等</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-54ba71800d8ad53a.gif?imageMogr2/auto-orient/strip" alt="理财"></p><ul><li>我的页<ul><li>collectionView 、webView</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-dc48d734c996f772.gif?imageMogr2/auto-orient/strip" alt="我的"></p><ul><li>初学者，UI就这么多，就说说遇到的两个坑吧~<h5 id="第一个坑，使用pod建立工程时终端出错"><a href="#第一个坑，使用pod建立工程时终端出错" class="headerlink" title="第一个坑，使用pod建立工程时终端出错"></a>第一个坑，使用pod建立工程时终端出错</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod[!] Unable <span class="built_in">to</span> <span class="built_in">add</span> <span class="keyword">a</span> source <span class="keyword">with</span> url `<span class="keyword">https</span>://github.com/CocoaPods/Specs.git` named `master`.You can</span><br><span class="line"> <span class="keyword">try</span> adding <span class="keyword">it</span> manually <span class="keyword">in</span> `~/.cocoapods/repos` <span class="keyword">or</span> via `pod repo <span class="built_in">add</span>`.</span><br></pre></td></tr></table></figure></li></ul><p>解决方案：终端输入以下命令<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add <span class="keyword">master</span> <span class="title">https</span>://github.com/CocoaPods/Specs.git</span><br></pre></td></tr></table></figure></p><p>然后提示执行<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="built_in">setup</span></span><br></pre></td></tr></table></figure></p><p>如果出现<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod[!] The `master` repo is <span class="literal">not</span> <span class="literal">a</span> git repo.</span><br></pre></td></tr></table></figure></p><p>进入/users/你的用户名/.cocoapods/repos，删除master文件夹然后执行，如我这么进入<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.cocoapods/repos/</span></span><br></pre></td></tr></table></figure></p><p>master文件夹是个目录，删除时需要连下面的分支一起删掉<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~<span class="regexp">/.cocoapods/</span>repos<span class="regexp">/master</span></span><br></pre></td></tr></table></figure></p><p>删除master之后，再<code>pod setup</code>,之后配置好你的<code>Podfile</code>,最后<code>pod install</code>就成功的建立了 同名的<code>.xcworkspace</code>工程了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pod setup</span><br><span class="line"><span class="meta">#</span><span class="bash">先 <span class="built_in">cd</span> 到你工程的目录</span></span><br><span class="line">pod init</span><br><span class="line">open -a Xcode Podfile</span><br><span class="line"><span class="meta">#</span><span class="bash">添加你需要的三方库</span></span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p><ul><li>还有以下情况：<br>如果是安装多个Xcdoe，还需要选择Xcode的路径,后面是你自己的Xcode路径，显示Xcode包内容可查看<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sudo</span> xcode-<span class="keyword">select </span>-<span class="keyword">switch </span>/Applications/Xcode.app/</span><br></pre></td></tr></table></figure></li></ul><p>在终端里输入下方命令可以知道Xcode的路径：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span> -p</span><br></pre></td></tr></table></figure></p><h5 id="第二个坑，加载基于XIB创建的自定义控件时报错"><a href="#第二个坑，加载基于XIB创建的自定义控件时报错" class="headerlink" title="第二个坑，加载基于XIB创建的自定义控件时报错"></a>第二个坑，加载基于XIB创建的自定义控件时报错</h5><ul><li><p>我像写OC的基于XIB自定义控件一样,创建一个基于<code>UIView</code>的新类<code>XSCustomView</code><br><img src="http://upload-images.jianshu.io/upload_images/1276164-1b14c0c6d09230a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建基于UIView的新类XSCustomView"></p></li><li><p>创建一个同名的<code>XIB</code>文件<br><img src="http://upload-images.jianshu.io/upload_images/1276164-5cf6d8adcca145fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建一个同名的XIB文件"></p></li><li><p>像OC一样给文件指定类<br><img src="http://upload-images.jianshu.io/upload_images/1276164-c8a1c91da6af44f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="像OC一样给文件连线"></p></li><li><p>然后加载View就会出错</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="keyword">error</span>: init(coder:) has not been implemented: <span class="keyword">file</span> </span><br><span class="line">/路径/XXX.swift, <span class="keyword">line</span> 43</span><br><span class="line">(lldb)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 解决办法，查了好久资料，找到解决办法</span><br><span class="line">swift指定类与OC略有不同，swift需要的是<span class="symbol">`File'</span>s Owner`归属于咱们定义的哪个类,而下面的<span class="keyword">View</span>是不需要指定类的</span><br><span class="line">![解决问题](http:<span class="comment">//upload-images.jianshu.io/upload_images/1276164-f09189b3807fa34b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">- 最后咱们从XIB加载<span class="keyword">View</span>即可，如在custom.swift文件里有如下代码</span><br></pre></td></tr></table></figure></li></ul><p>class XSCustomView: UIView {</p><pre><code>var contentView:UIView!override func awakeFromNib() {    super.awakeFromNib()}override init(frame: CGRect) {    super.init(frame: frame)    contentView = loadFromNib()    addSubview(contentView)}func loadFromNib() -&gt; UIView {    return Bundle.main.loadNibNamed(&quot;XSCustomView&quot;, owner: nil, options: nil)?.first as! UIView}override func layoutSubviews() {    contentView.frame = bounds}required init?(coder aDecoder: NSCoder) {    super.init(coder: aDecoder)    fatalError(&quot;init(coder:) has not been implemented&quot;)}</code></pre><p>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-658274.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇主要是关于&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初学swift时，练手的一个demo&lt;/li&gt;
&lt;li&gt;遇到的一点坑及如何解决的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有兴趣的朋友可以看看&lt;a href=&quot;https://github.com/SPIREJ/XSLC_Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何在swift中实现oc中的分类</title>
    <link href="http://yoursite.com/2017/05/22/%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E5%AE%9E%E7%8E%B0oc%E4%B8%AD%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/05/22/如何在swift中实现oc中的分类/</id>
    <published>2017-05-22T09:02:24.000Z</published>
    <updated>2018-06-05T06:59:59.178Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-654521.jpg" alt=""></p><p>如何在swift中实现oc的<code>category</code>？<br>示例:<br>1、对<code>UIView</code>的扩展<br>2、对<code>UIColor</code>的扩展</p><a id="more"></a><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>在oc中为了增强已有类的功能，我们经常使用<code>分类</code>。使用分类，我们可以在不破坏原有类的结构的前提下，对原有类进行模块化的扩展。</p><p>但是在swift中没有分类这种写法了。相对应的是swift中只有扩展(<code>Extensions</code>)。</p><p>下面是swift中扩展(<code>Extensions</code>)的说明:<br>扩展就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（<code>functionality</code>）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（<code>categories</code>）类似。（不过与 Objective-C 不同的是，Swift 的扩展没有名字。）</p><h4 id="2-对UIView的扩展"><a href="#2-对UIView的扩展" class="headerlink" title="2.对UIView的扩展"></a>2.对UIView的扩展</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">extension UIView &#123;</span><br><span class="line">    <span class="comment">// .x</span></span><br><span class="line">    public <span class="selector-tag">var</span> x: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.x</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.origin</span><span class="selector-class">.x</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .y</span></span><br><span class="line">    public <span class="selector-tag">var</span> y: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.y</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.origin</span><span class="selector-class">.y</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .maxX</span></span><br><span class="line">    public <span class="selector-tag">var</span> maxX: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.maxX</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .maxY</span></span><br><span class="line">    public <span class="selector-tag">var</span> maxY: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.maxY</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .centerX</span></span><br><span class="line">    public <span class="selector-tag">var</span> centerX: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.center</span><span class="selector-class">.x</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self<span class="selector-class">.center</span> = CGPoint(x: newValue, y: self<span class="selector-class">.center</span><span class="selector-class">.y</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .centerY</span></span><br><span class="line">    public <span class="selector-tag">var</span> centerY: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.center</span><span class="selector-class">.y</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self<span class="selector-class">.center</span> = CGPoint(x: self<span class="selector-class">.center</span><span class="selector-class">.x</span>, y: newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .width</span></span><br><span class="line">    public <span class="selector-tag">var</span> <span class="attribute">width</span>: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.width</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.size</span><span class="selector-class">.width</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .height</span></span><br><span class="line">    public <span class="selector-tag">var</span> <span class="attribute">height</span>: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.height</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.size</span><span class="selector-class">.height</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="selector-tag">label</span> = UILabel()</span><br><span class="line">        <span class="selector-tag">label</span>.x</span><br><span class="line">        <span class="selector-tag">label</span>.<span class="attribute">width</span></span><br><span class="line">        <span class="selector-tag">label</span>.centerX</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="3-对UIColor的扩展"><a href="#3-对UIColor的扩展" class="headerlink" title="3.对UIColor的扩展"></a>3.对UIColor的扩展</h4><p>十六进制颜色转换为rgb</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">colorWithHex</span><span class="params">(rgb:Int, alpha: CGFloat)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>(red: ((<span class="type">CGFloat</span>)((rgb &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span>, green: ((<span class="type">CGFloat</span>)((rgb &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span>, blue: ((<span class="type">CGFloat</span>)(rgb &amp; <span class="number">0xFF</span>)) / <span class="number">255.0</span>, alpha: alpha)        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">UIColor</span><span class="selector-class">.clear</span><span class="selector-class">.colorWithHex</span>(<span class="selector-tag">rgb</span>: 0<span class="selector-tag">x2588dd</span>, <span class="selector-tag">alpha</span>: 1<span class="selector-class">.0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-654521.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如何在swift中实现oc的&lt;code&gt;category&lt;/code&gt;？&lt;br&gt;示例:&lt;br&gt;1、对&lt;code&gt;UIView&lt;/code&gt;的扩展&lt;br&gt;2、对&lt;code&gt;UIColor&lt;/code&gt;的扩展&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>归期不遇</title>
    <link href="http://yoursite.com/2017/03/20/%E5%BD%92%E6%9C%9F%E4%B8%8D%E9%81%87/"/>
    <id>http://yoursite.com/2017/03/20/归期不遇/</id>
    <published>2017-03-20T14:46:40.000Z</published>
    <updated>2018-06-07T10:03:38.999Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-657580.png" alt=""></p><a id="more"></a><h4 id="临时出发"><a href="#临时出发" class="headerlink" title="临时出发"></a>临时出发</h4><p>此刻我坐在从北京开往西安的火车上，由于临时出发没买到卧铺只有硬座将就一下，说“将就”可能对我来说还太牵强了，想起以前站过的火车，想起当年逃票的光辉历史，想起为了省点钱不买卧铺的日子，想起去武汉站13小时的信念……此刻，我觉得人活着还是不能缺了信念的。</p><h4 id="信念是什么？"><a href="#信念是什么？" class="headerlink" title="信念是什么？"></a>信念是什么？</h4><p>但是，关于信念到底是一种什么东西我又摸不清的，可能在我这就是一个你真心爱的人，一个你觉得舒适的城，一份你不讨厌的工作，一个可以实现的目标或者是你应尽的义务，比如作为子女应该像父母无私无怨养育你一样亲近父母，善待朋友，真诚待人不虚伪不造作。一个人真正有信念的时候，那时候他是强大的，拥有强大的内心力量和精神力量。</p><h4 id="向左向右？"><a href="#向左向右？" class="headerlink" title="向左向右？"></a>向左向右？</h4><p>有朋友面临毕业再为工作犯愁，大多数人都是这么走过来的，我觉得毕业的时候分几类人，其他的外界条件就都不考虑了，一类人完全明确自己想要做什么不担心做不好，一类人想做这个也想做那个但是担心自己做不做得好，还有一类人不知道自己想要做什么也觉得自己做不好。很不幸当年我就是属于最后一类，后来我发现大多数人毕业的时候都有焦虑症，我把这统称为“毕业综合症”。这绝对不是病，我们要离开一个熟悉的环境熟悉的人去探知不确定的未来，有焦虑有排斥有不舍，这种不舍在将来的几年内会更浓烈呢。总之，再没开始探险之前，未知的前方总是充满传奇的色彩和迷样的精彩，所以在向左还是向右的十字路口，不要害怕迈出哪一步是错误的还是正确的，因为不管是向左还是向右，最终都会在一个路口会和，迎来你想要的生活。</p><h4 id="曾很潇洒"><a href="#曾很潇洒" class="headerlink" title="曾很潇洒"></a>曾很潇洒</h4><p>和朋友聊到毕业时的情景，又想到去年另一位朋友告诉我 当年我说“那不是我想要的生活”，然后毅然决然就北漂了很帅气，觉得我是个很有主见的人。时隔两年听到别人这么赞美我很是高兴，没想到我也曾如此潇洒过。不可否认，虽然是面相长得年轻了点，但小时候的经历，二年级就自己报名以及一路走来坎坎坷坷的我向来是知道如何生存，如何独立的。说实话我并不是一个有很多正能力的人，也偶尔（可能是经常）负能量爆棚，所以我才一直积极乐观的生活，也害怕给身边的人带去负能量，我一直相信着自己，经历那么多不是被打败的，而是真正的强大起来。我相信人生没有如果只有后果和结果，我从不后悔自己做的每个决定和每件事。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>现在不止春节的时候父母才会讲我的终生大事了，已经成为每次通话的不可少话题了，好像无论聊什么都能聊到这的样子，每次大概是这样“都二十六七的人了，还不打算说媳妇儿…”。讲真，一个人的生活我也过了好多年了，谁不想找一个爱的人在一起互相慰藉，然而人生总是有很多不如意，比如在你不懂爱的年纪遇到爱你的人，不懂爱的年纪遇到你爱的，懂爱的年纪遇到你爱的不爱你的，懂爱的年纪遇不到你爱的也遇不到爱你的，最美好的年纪没有能力保护最想要保护的，有能力的时候已经淡然。父母总认为自己的孩子是最好的，也认为现在年轻人那么多，然而他们并不知其实现在人与人之间的交集早已经不如他们那个年代了，而且对于我这类人来说，喜欢一个人是多么的不容易的一件事。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someone == <span class="literal">I</span> loved) &#123;</span><br><span class="line"><span class="keyword">do</span> everything;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="literal">I</span> would like to sleeping alone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能这就是所谓的以前喜欢一个人，现在喜欢一个人吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-657580.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="流金岁月" scheme="http://yoursite.com/categories/%E6%B5%81%E9%87%91%E5%B2%81%E6%9C%88/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>使用CAShapeLayer &amp; UIBezierPath画图</title>
    <link href="http://yoursite.com/2017/02/24/%E4%BD%BF%E7%94%A8CAShapeLayer&amp;UIBezierPath%E7%94%BB%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/02/24/使用CAShapeLayer&amp;UIBezierPath画图/</id>
    <published>2017-02-24T03:14:10.000Z</published>
    <updated>2018-06-05T06:24:14.798Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660825.jpg" alt=""></p><blockquote><p>本篇主要从以下几个方面来写的一点东西：</p><ul><li>线段</li><li>曲线</li><li>动画</li><li>简单的柱状图</li><li>简单的折线图<a id="more"></a></li></ul></blockquote><h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-8c6af273e49d1835.gif?imageMogr2/auto-orient/strip" alt="线段"></p><ul><li>单线段<br>两点确定一条直线，给贝塞尔曲线一个起始点<code>moveToPoint</code>再添加一条线的终点<code>addLineToPoint</code>，这样就确定了一条直线。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLine &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1024</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">524</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"直线"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *line = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    line.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    line.strokeColor = [UIColor <span class="keyword">orangeColor].CGColor;</span></span><br><span class="line"><span class="keyword"> </span>   line.fillColor = nil<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:line];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(100, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    line.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>多线段<br>前面线段的终点是后面线段的起点。给一个起点<code>moveToPoint</code>，然后想添加几条线就给几个线的终点<code>addLineToPoint</code>。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawDoubleLine &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1025</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">525</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"折线"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *line = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    line.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    line.strokeColor = [UIColor <span class="keyword">orangeColor].CGColor;</span></span><br><span class="line"><span class="keyword"> </span>   line.fillColor = nil<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:line];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(100, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">100</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(250, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    line.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>闭合多边形<br>也是多线段连起来的，只不过最后一条线的终点为第一条线段的起点。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawTriangle &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1026</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">526</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"闭合多边形"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *triangle = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    triangle.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    triangle.strokeColor = [UIColor redColor].CGColor<span class="comment">;</span></span><br><span class="line">    triangle.fillColor = [UIColor clearColor].CGColor<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:triangle];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0-100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0+100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    triangle.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>线端点样式<br>CAShapeLayer的<code>lineCap</code>属性决定线端点样式，可选样式<code>kCALineCapButt（默认）</code>，<code>kCALineCapRound（圆角）</code>，<code>kCALineCapSquare（平角）</code>。默认为<code>kCALineCapButt</code>也是平角。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3950101908ae9c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线端点样式示例"></p></li><li><p>线段拐点处样式<br>CAShapeLayer的<code>lineJoin</code>属性决定线端点样式，可选样式<code>kCALineJoinMiter（尖角）</code>，<code>kCALineJoinRound（圆角）</code>，<code>kCALineJoinBevel（平角）</code>。默认为<code>kCALineJoinMiter</code>。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-ae5278976c113bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拐角样式示例"></p></li><li><p>虚线</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *lineDashPattern;</span><br></pre></td></tr></table></figure><p>CAShapeLayer的<code>lineDashPattern</code>属性决定你画出一条什么样的虚线，这个属性返回一组<code>NSNumber</code>类型的数组，其实就是<code>实虚相交</code>来表示你的虚线，数组的长度由你决定（当然最好不要第一轮实虚相加超过线段长度）。比如<code>line.lineDashPattern = @[@10,@5,@2,@8];</code>就是表示每轮都为长度为10的实线，长度为5的虚线，长度为2的实线，长度为8的虚线，循环直到线段结束。</p><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-6cbeb754f0ff140f.gif?imageMogr2/auto-orient/strip" alt="曲线"></p><ul><li>二次贝塞尔曲线<br><img src="http://upload-images.jianshu.io/upload_images/1276164-db1b50a659d63560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二次贝塞尔曲线"><br>二次贝塞尔曲线有一个控制点，控制点的位置决定了显示一条怎样的曲线。下面的例子，我把起点pA、终点pB、控制点pC 都画出来方便观察。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//篇幅限制 只贴主要代码</span></span><br><span class="line"><span class="comment">//曲线</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *layerOne = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">layerOne.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">layerOne.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">layerOne.strokeStart = <span class="number">0</span>;</span><br><span class="line">layerOne.strokeEnd = <span class="number">1</span>;</span><br><span class="line">[view.layer addSublayer:layerOne];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:pA];</span><br><span class="line">[path addQuadCurveToPoint:pB controlPoint:pC];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关联路径</span></span><br><span class="line">layerOne.path = path.CGPath;</span><br></pre></td></tr></table></figure><ul><li>三次贝塞尔曲线<br>![Uploading Glass_和_iPhone_7_Plus_–_iOS_10_2__14C89__158499.png . . .]<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3cfcc224f189e5a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次贝塞尔曲线"><br>三次贝塞尔曲线有两个控制点，两个控制点的位置决定了显示一条怎样的曲线。下面的例子，我把起点pA、终点pB、控制点pC、pD 都画出来方便观察。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//篇幅限制 只贴主要代码</span></span><br><span class="line"><span class="comment">//曲线</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *layerTwo = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">layerTwo.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">layerTwo.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">layerTwo.strokeStart = <span class="number">0</span>;</span><br><span class="line">layerTwo.strokeEnd = <span class="number">1</span>;</span><br><span class="line">[view.layer addSublayer:layerTwo];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:pA];</span><br><span class="line">[path addCurveToPoint:pB controlPoint1:pC controlPoint2:pD];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关联路径</span></span><br><span class="line">layerTwo.path = path.CGPath;</span><br></pre></td></tr></table></figure><ul><li>圆角矩形</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRectRound &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [<span class="keyword">self</span>.view viewWithTag:<span class="number">1028</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *rectRound = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(kDeviceWidth/<span class="number">2.0</span><span class="number">-100</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">100</span>) byRoundingCorners:<span class="built_in">UIRectCornerBottomLeft</span> | <span class="built_in">UIRectCornerBottomRight</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *layer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    layer.strokeColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    layer.fillColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">    layer.path = rectRound.CGPath;</span><br><span class="line">    </span><br><span class="line">    [view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1276164-7def553629daf890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆角矩形"></p><ul><li>虚线圆<br>如果是静态的(无动画)，那么需要两个贝塞尔圆环曲线表示内圆和外圆，内圆一周，外圆实时进度。<br>如果是动态的(有动画)，那么可以一个贝塞尔圆环曲线表示内圆和外圆，内、外圆都一周，外圆添加动画，动画的<code>toValue</code>标志实时进度。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-0e78eb5eaa0f4f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚线圆"></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawXuCircle &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [<span class="keyword">self</span>.view viewWithTag:<span class="number">1029</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//底部虚圆</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *xuCircle = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    xuCircle.lineWidth = <span class="number">10</span>;</span><br><span class="line">    xuCircle.strokeColor = ColorWithHex(<span class="number">0xbebebe</span>, <span class="number">1</span>).CGColor;</span><br><span class="line">    xuCircle.fillColor = <span class="literal">nil</span>;</span><br><span class="line">    xuCircle.lineJoin = kCALineJoinMiter;</span><br><span class="line">    xuCircle.lineDashPattern = @[@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    [view.layer addSublayer:xuCircle];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//外部虚圆</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *circle = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    circle.lineWidth = <span class="number">10</span>;</span><br><span class="line">    circle.strokeColor = ColorWithHex(<span class="number">0xa2d100</span>, <span class="number">1</span>).CGColor;</span><br><span class="line">    circle.fillColor = <span class="literal">nil</span>;</span><br><span class="line">    circle.lineJoin = kCALineJoinMiter;</span><br><span class="line">    circle.lineDashPattern = @[@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    [view.layer addSublayer:circle];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *xuBezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(kDeviceWidth/<span class="number">2.0</span>, <span class="number">100</span>) radius:<span class="number">55</span> startAngle:-M_PI_2 endAngle:<span class="number">3</span>*M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *bezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(kDeviceWidth/<span class="number">2.0</span>, <span class="number">100</span>) radius:<span class="number">55</span> startAngle:-M_PI_2 endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    xuCircle.path = xuBezierPath.CGPath;</span><br><span class="line">    circle.path = bezierPath.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><blockquote><p>现在我们来给一些图形加上动画，使运行起来更美观。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-879cf2a6c243266b.gif?imageMogr2/auto-orient/strip" alt="动画"></p></blockquote><ul><li>主要写了三类动画<br>1.最常用的普通动画<br>2.进度条动画<br>3.其他属性的动画（比如这里有重复次数和逆执行）</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通动画，strokeEnd</span></span><br><span class="line">- (CABasicAnimation *)animComm &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animComm</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animComm</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animComm</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animComm</span>.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        <span class="variable">_animComm</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animComm</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进度条动画</span></span><br><span class="line">- (CABasicAnimation *)animProgress &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animProgress</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animProgress</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animProgress</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animProgress</span>.toValue = @<span class="number">0.7</span>;</span><br><span class="line">        <span class="variable">_animProgress</span>.fillMode = kCAFillModeForwards;</span><br><span class="line">        <span class="variable">_animProgress</span>.removedOnCompletion = NO;</span><br><span class="line">        <span class="variable">_animProgress</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animProgress</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重复次数，逆执行试用</span></span><br><span class="line">- (CABasicAnimation *)animRepeat &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animRepeat</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animRepeat</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animRepeat</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.autoreverses = YES;</span><br><span class="line">        <span class="variable">_animRepeat</span>.repeatCount = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animRepeat</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的柱状图"><a href="#简单的柱状图" class="headerlink" title="简单的柱状图"></a>简单的柱状图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-452e7362dd44076b.gif?imageMogr2/auto-orient/strip" alt="简单柱状图"></p><p>这是个非常简单的柱状图，需要注意的是柱子的三个重要部分，起点、终点、柱宽。柱子由起点根据柱宽向左右两边扩张，如下图柱子的起点是位置2而不是位置1。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-f226f1e227c4c8f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="柱状图"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SJBarChart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> lineWidth  = <span class="number">1.0</span>;      <span class="comment">//坐标轴线宽</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> distance   = <span class="number">20.0</span>;     <span class="comment">//距屏幕边距</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> cornerW    = <span class="number">10.0</span>f;    <span class="comment">//拐角长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> barWidth   = <span class="number">50.0</span>f;    <span class="comment">//柱状宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> space      = <span class="number">30.0</span>f;    <span class="comment">//柱状之间的间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> scale      = <span class="number">3.0</span>f;     <span class="comment">//柱状显示高度计算比例 *scale</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJBarChart</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> selfW, selfH;</span><br><span class="line">    <span class="built_in">NSArray</span> *source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *xAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *yAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *barScrollView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CABasicAnimation</span> *animation;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SJBarChart</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        selfW = frame.size.width;</span><br><span class="line">        selfH = frame.size.height;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showBarChart:(<span class="built_in">NSArray</span> *)sourceArray &#123;</span><br><span class="line">    source = sourceArray;</span><br><span class="line">    [<span class="keyword">self</span> addxyAxis];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.barScrollView];</span><br><span class="line">    _barScrollView.contentSize = <span class="built_in">CGSizeMake</span>(sourceArray.count*(space+barWidth) + space, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    [sourceArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *bar = [<span class="keyword">self</span> drawBar:idx];</span><br><span class="line">        [_barScrollView.layer addSublayer:bar];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//柱状图</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)drawBar:(<span class="built_in">NSInteger</span>)index &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *layer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    layer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    layer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    layer.lineWidth = barWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//终点y</span></span><br><span class="line">    <span class="built_in">CGFloat</span> y = _barScrollView.frame.size.height<span class="number">-60</span> - lineWidth/<span class="number">2.0</span> - ([[source objectAtIndex:index] floatValue] * scale);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>((space + barWidth)*index + (space+barWidth/<span class="number">2.0</span>), _barScrollView.frame.size.height<span class="number">-60</span>)];</span><br><span class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>((space + barWidth)*index + (space+barWidth/<span class="number">2.0</span>), y)];</span><br><span class="line">    layer.path = path.CGPath;</span><br><span class="line">    </span><br><span class="line">    [layer addAnimation:<span class="keyword">self</span>.animation forKey:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加坐标轴</span></span><br><span class="line">- (<span class="keyword">void</span>)addxyAxis &#123;</span><br><span class="line">    <span class="keyword">self</span>.xAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance, selfH<span class="number">-30</span>) endPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance-cornerW, selfH<span class="number">-30</span>-cornerW)];</span><br><span class="line">    <span class="keyword">self</span>.yAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance+lineWidth/<span class="number">2.0</span>, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(distance, <span class="number">30</span>) endPoint:<span class="built_in">CGPointMake</span>(distance+cornerW, <span class="number">30</span>+cornerW)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.xAxis];</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.yAxis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画坐标轴</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)lineWithStartPoint:(<span class="built_in">CGPoint</span>)startPoint breakPoint:(<span class="built_in">CGPoint</span>)breakPoint endPoint:(<span class="built_in">CGPoint</span>)endPoint &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *line = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    line.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    line.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">    line.lineWidth = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *linePath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [linePath moveToPoint:startPoint];</span><br><span class="line">    [linePath addLineToPoint:breakPoint];</span><br><span class="line">    [linePath addLineToPoint:endPoint];</span><br><span class="line">    line.path = linePath.CGPath;</span><br><span class="line">    </span><br><span class="line">    [line addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"xyLineStrokeEndAnimation"</span>];</span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)barScrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (_barScrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _barScrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(distance+lineWidth, <span class="number">30</span>, kDeviceWidth-distance*<span class="number">2</span>-lineWidth-cornerW, selfH<span class="number">-60</span>-lineWidth/<span class="number">2.0</span>)];</span><br><span class="line">        _barScrollView.bounces = <span class="literal">NO</span>;</span><br><span class="line">        _barScrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _barScrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CABasicAnimation</span> *)animation &#123;</span><br><span class="line">    <span class="keyword">if</span> (_animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</span><br><span class="line">        _animation.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        _animation.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        _animation.duration = <span class="number">2.0</span>;</span><br><span class="line">        _animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _animation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-927e70f03aad6179.gif?imageMogr2/auto-orient/strip" alt="折线图"></p><p>柱状图是一条条单独的线段，折线图就是一条连起来的完整折线。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SJLineChart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> lineWidth  = <span class="number">1.0</span>;      <span class="comment">//坐标轴线宽</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> distance   = <span class="number">20.0</span>;     <span class="comment">//距屏幕边距</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> cornerW    = <span class="number">10.0</span>f;    <span class="comment">//拐角长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> space      = <span class="number">50.0</span>f;    <span class="comment">//柱状之间的间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> scale      = <span class="number">3.0</span>f;     <span class="comment">//直线显示高度计算比例 *scale</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> radius     = <span class="number">3.0</span>f;     <span class="comment">//标记每个点的小圆半径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJLineChart</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> selfW, selfH;</span><br><span class="line">    <span class="built_in">NSArray</span> *source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *xAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *yAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *lineScrollView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CABasicAnimation</span> *animation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SJLineChart</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        selfW = frame.size.width;</span><br><span class="line">        selfH = frame.size.height;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showLineChart:(<span class="built_in">NSArray</span> *)sourceArray &#123;</span><br><span class="line">    source = sourceArray;</span><br><span class="line">    [<span class="keyword">self</span> addxyAxis];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.lineScrollView];</span><br><span class="line">    _lineScrollView.contentSize = <span class="built_in">CGSizeMake</span>(sourceArray.count*(space+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    [<span class="keyword">self</span> drawLineChart:sourceArray];</span><br><span class="line">    [<span class="keyword">self</span> drawPoint:sourceArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLineChart:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *lineLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    lineLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    lineLayer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    lineLayer.lineWidth = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//轨迹</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(space, _lineScrollView.frame.size.height - <span class="number">60</span> - lineWidth/<span class="number">2.0</span> - ([[array objectAtIndex:<span class="number">0</span>] floatValue] * scale))];</span><br><span class="line">    </span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> y = _lineScrollView.frame.size.height<span class="number">-60</span> - lineWidth/<span class="number">2.0</span> - ([obj floatValue] * scale);</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(space*(idx+<span class="number">1</span>), y)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    lineLayer.path = path.CGPath;</span><br><span class="line">    [<span class="keyword">self</span>.lineScrollView.layer addSublayer:lineLayer];</span><br><span class="line">    [lineLayer addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"lineStrokeEndAnimation"</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把点标出来</span></span><br><span class="line">- (<span class="keyword">void</span>)drawPoint:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    </span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">CGFloat</span> y = _lineScrollView.frame.size.height - <span class="number">60</span> - lineWidth/<span class="number">2.0</span> - [obj floatValue]*scale;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIBezierPath</span> *circlePath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(space * (idx+<span class="number">1</span>), y) radius:radius startAngle:<span class="number">0</span> endAngle:(M_PI)*<span class="number">2</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *circleLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">        circleLayer.fillColor = [<span class="built_in">UIColor</span> orangeColor].CGColor;</span><br><span class="line">        circleLayer.strokeColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">        circleLayer.path = circlePath.CGPath;</span><br><span class="line">        </span><br><span class="line">        [_lineScrollView.layer addSublayer:circleLayer];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加坐标轴</span></span><br><span class="line">- (<span class="keyword">void</span>)addxyAxis &#123;</span><br><span class="line">    <span class="keyword">self</span>.xAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance, selfH<span class="number">-30</span>) endPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance-cornerW, selfH<span class="number">-30</span>-cornerW)];</span><br><span class="line">    <span class="keyword">self</span>.yAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance+lineWidth/<span class="number">2.0</span>, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(distance, <span class="number">30</span>) endPoint:<span class="built_in">CGPointMake</span>(distance+cornerW, <span class="number">30</span>+cornerW)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.xAxis];</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.yAxis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画坐标轴</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)lineWithStartPoint:(<span class="built_in">CGPoint</span>)startPoint breakPoint:(<span class="built_in">CGPoint</span>)breakPoint endPoint:(<span class="built_in">CGPoint</span>)endPoint &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *line = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    line.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    line.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">    line.lineWidth = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *linePath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [linePath moveToPoint:startPoint];</span><br><span class="line">    [linePath addLineToPoint:breakPoint];</span><br><span class="line">    [linePath addLineToPoint:endPoint];</span><br><span class="line">    line.path = linePath.CGPath;</span><br><span class="line">    </span><br><span class="line">    [line addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"xyLineStrokeEndAnimation"</span>];</span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)lineScrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (_lineScrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _lineScrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(distance+lineWidth, <span class="number">30</span>, kDeviceWidth-distance*<span class="number">2</span>-lineWidth, selfH<span class="number">-60</span>-lineWidth/<span class="number">2.0</span>)];</span><br><span class="line">        _lineScrollView.bounces = <span class="literal">NO</span>;</span><br><span class="line">        _lineScrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _lineScrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CABasicAnimation</span> *)animation &#123;</span><br><span class="line">    <span class="keyword">if</span> (_animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</span><br><span class="line">        _animation.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        _animation.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        _animation.duration = <span class="number">2.0</span>;</span><br><span class="line">        _animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _animation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>感谢阅读全文的朋友。<br>☞demo地址 <a href="https://github.com/SPIREJ/SJCAShapeLayer" target="_blank" rel="noopener">https://github.com/SPIREJ/SJCAShapeLayer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660825.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本篇主要从以下几个方面来写的一点东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线段&lt;/li&gt;
&lt;li&gt;曲线&lt;/li&gt;
&lt;li&gt;动画&lt;/li&gt;
&lt;li&gt;简单的柱状图&lt;/li&gt;
&lt;li&gt;简单的折线图
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="图形" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>CAShapeLayer &amp; UIBezierPath &amp; CABasicAnimation总结</title>
    <link href="http://yoursite.com/2017/02/16/CAShapeLayer&amp;UIBezierPath&amp;CABasicAnimation%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/02/16/CAShapeLayer&amp;UIBezierPath&amp;CABasicAnimation总结/</id>
    <published>2017-02-16T10:22:05.000Z</published>
    <updated>2018-06-05T07:13:46.612Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660824.jpg" alt=""></p><ul><li><strong>CAShapeLayer</strong><ul><li>CAShapeLayer常用属性及可设置说明</li><li>CAShapeLayer特点</li></ul></li><li><strong>UIBezierPath</strong><ul><li>UIBezierPath几种初始化方式说明</li></ul></li><li><strong>CABasicAnimation</strong><ul><li>CABasicAnimation是什么？</li><li>CABasicAnimation设定动画的属性说明</li><li>CABasicAnimation常用的KeyPath值总结</li></ul></li></ul><a id="more"></a><h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><p>普通<code>CALayer</code>在被初始化时是需要给一个frame值的,这个frame值一般都与给定view的bounds值一致,它本身是有形状的,而且是矩形.<br>每个<code>CAShapeLayer</code>对象都代表着将要被渲染到屏幕上的形状(shape),CAShapeLayer在初始化时也需要给一个frame值,但是,它本身没有形状,它的形状来源于你给定的一个path,然后它去取<code>CGPath</code>值,它与CALayer有着很大的区别.</p><p>并且，系统仅会渲染CAShapeLayer对象的形状，其他任何非CAShapeLayer的自由属性在渲染是都会被忽略。因此从某种意义上讲CAShapeLayer仅是形状的容器。虽然由于其实CALayer的子类，可以设置<code>contents</code>、<code>backgroundColor</code>等属性，但这些属性在渲染时也会被忽略。</p><h4 id="但是，CAShapeLayer提供了自身的可设置性："><a href="#但是，CAShapeLayer提供了自身的可设置性：" class="headerlink" title="- 但是，CAShapeLayer提供了自身的可设置性："></a>- 但是，CAShapeLayer提供了自身的可设置性：</h4><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>path</td><td>fillColor</td><td>fillRule</td><td>strokeColor</td></tr><tr><td>strokeStart</td><td>strokeEnd</td><td>lineWidth</td><td>miterLimit</td></tr><tr><td>lineCap</td><td>lineJoin</td><td>lineDashPhase</td><td>lineDashPattern</td></tr></tbody></table><ul><li><p>path<br>  动画路径，默认为NULL，不支持隐式动画。路径可以使用任何的具体子类的动画CAPropertyAnimation。如果此属性的值是不为NULL，则path使用指定的路径，而不是创建该层的合成后的alpha通道。它使用的是非零缠绕规则和当前颜色，不透明度和模糊半径填充。 </p></li><li><p>fillColor<br>  填充颜色，默认为不透明的黑色，若值为nil，则没有填充效果。<br>fillColor针对于闭合的图形，对于镂空图形只需设置画笔颜色<code>strokeColor</code>即可。</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//闭合多边形</span><br><span class="line">- (void)drawTriangle &#123;</span><br><span class="line">    UIView *view = [<span class="keyword">self.view </span>viewWithTag:<span class="number">1026</span>]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *triangle = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    triangle.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    triangle.<span class="keyword">strokeColor </span>= [UIColor clearColor].CGColor<span class="comment">;</span></span><br><span class="line">    triangle.fillColor = [UIColor redColor].CGColor<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:triangle];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0-100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0+100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    triangle.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1276164-cd35cad81961ab23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fillColor和strokeColor两种设置的效果"></p><ul><li><p>fillRule<br>  填充规则，默认是kCAFillRuleNonZero。<br>  kCAFillRuleNonZero：指定非零缠绕规则。计算每个左到右的路径+1或-1为每个从右到左的道路。如果所有交叉的总和为0，则点是路径之外，如果该和为非零，改点是在路径内与包含它的区域被填充。<br>  kCAFillRuleEvenOdd：指定奇偶缠绕规则。算路径交叉的总和，如果横跨的数目是偶数，改点在路径之外。如果横跨的数目是奇数，所述点是在路径内与包含它的区域应被填充。</p></li><li><p>strokeColor<br>  画笔颜色。</p></li><li><p>strokeStart<br>  和strokeEnd组合使用，默认值为1.0，取值范围0.0~1.0</p></li><li><p>strokeEnd<br>  和strokeStart组合使用，默认值为1.0，取值范围为0.0~1.0</p></li><li><p>lineWidth<br>  线宽。注意线宽有一个特点，线宽从你设置的起点往左右两边同时伸展。</p></li><li><p>miterLimit<br>  斜接样式，默认值为10.0</p></li><li><p>lineCap<br>  线端点样式，默认值为kCALineCapButt，还有kCALineCapRound，kCALineCapSquare<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3950101908ae9c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线端点样式示例"></p></li><li><p>lineJoin<br>  拐角样式，默认值为kCALineJoinMiter（尖角），还有kCALineJoinRound（圆角），kCALineJoinBevel（平角）<br><img src="http://upload-images.jianshu.io/upload_images/1276164-ae5278976c113bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拐角样式示例"></p></li><li><p>lineDashPhase<br>  冲刺阶段应用到的形状的路径，默认是0.0</p></li><li><p>lineDashPattern<br>设置线的样式，默认为实线，该数组为一个NSNumber数组，数组中的数值依次表示虚线中，单个线的长度，和空白的长度，如:数组@[@10,@5] 表示 有长度为10的线，长度为5的空白，不断循环后组成的虚线。<br>当然数组的长度是不做限制的，你亦可以@[@2,@3,@4,@5],可以表示为长度为2的线+长度为3的空白+长度为4的线+长度为5的空白，不断循环直到线段结束。</p></li><li><p>mask<br>  mask本身就是个CALayer，mask属性用作裁剪功能。<br>mask只作为形状（shape）的样子，裁剪后的形状以mask为准，其他例如颜色等属性以原图为准。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-30817b1838eee1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种mask裁剪示例"></p></li></ul><h4 id="CAShapeLayer有以下几点特点："><a href="#CAShapeLayer有以下几点特点：" class="headerlink" title="- CAShapeLayer有以下几点特点："></a>- CAShapeLayer有以下几点特点：</h4><ul><li>它依附于一个<code>path</code>，必须给予path，即使path不完整也会自动首尾相接。</li><li><code>strokeStart</code>及<code>strokeEnd</code>代表着在这个path中所占用的百分比。</li><li>CAShapeLayer动画仅限于沿着边缘的动画效果，它不能直接实现填充效果，但可以间接实现填充效果。</li></ul><h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><p>使用<code>UIBezierPath</code>可以创建基于矢量的路径，此类是<code>Core Graphics</code>框架关于路径的封装。使用此类可以定义简单的形状，如椭圆、矩形或有多个直线和曲线组成的形状等。</p><p><code>UIBezierPath</code>是<code>CGPathRef</code>数据类型的封装。如果是基于矢量形状的路径，都用直线或曲线去创建。我们使用直线段去创建矩形和多边形，使用曲线去创建圆弧、圆或其他复杂的曲线形状。</p><ul><li>最基本的初始化方法，用它创建的对象，我们可以根据我们的需要任意定制样式，可以话任何想画的图形。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPath;</span><br></pre></td></tr></table></figure><ul><li>初始化一个矩形矩形贝塞尔曲线。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRect:(<span class="type">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><ul><li>根据一个矩形画内切曲线，通常用来画圆或椭圆（取决于传入的rect是正方形还是长方形）。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithOvalInRect:(<span class="type">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><ul><li>画矩形，但是这个矩形可以画圆角。第一个参数是矩形，第二个参数是圆角大小。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRoundedRect:(<span class="type">CGRect</span>)rect cornerRadius:(<span class="type">CGFloat</span>)cornerRadius;</span><br></pre></td></tr></table></figure><ul><li>画矩形，矩形可以圆角，可以指定某个角或其中多个角成为圆角。参数：<code>UIRectCornerTopLeft</code>，<code>UIRectCornerTopRight</code>，<code>UIRectCornerBottomLeft</code>，<code>UIRectCornerBottomRight</code>，<code>UIRectCornerAllCorners</code></li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRoundedRect:(<span class="type">CGRect</span>)rect byRoundingCorners:(<span class="type">UIRectCorner</span>)corners cornerRadii:(<span class="type">CGSize</span>)cornerRadii;</span><br></pre></td></tr></table></figure><ul><li>画弧线，参数说明：<ul><li>center 弧线中心点的坐标</li><li>radius 弧线所在圆的半径</li><li>startAngle 弧线开始的角度值</li><li>endAngle 弧线结束的角度值</li><li>clockwise 是否顺时针画弧线</li></ul></li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithArcCenter:(<span class="type">CGPoint</span>)center radius:(<span class="type">CGFloat</span>)radius startAngle:(<span class="type">CGFloat</span>)startAngle endAngle:(<span class="type">CGFloat</span>)endAngle clockwise:(<span class="type">BOOL</span>)clockwise;</span><br></pre></td></tr></table></figure><h3 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h3><p><code>CABasicAnimation</code>类的使用方式就是关键帧动画，所谓关键帧动画，就是将Layer的属性作为<code>keyPath</code>来注册，指定动画的起始帧和结束帧，然后自动计算和实现中间的过渡动画的一种动画方式。</p><p>CABasicAnimation自己只有三个property:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> fromValue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> toValue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> byValue</span><br></pre></td></tr></table></figure><p>当创建一个<code>CABasicAnimation</code>的时候，需要通过 <code>-setFromValue</code>和 <code>-setToValue</code> 来指定一个开始值和结束值。当你增加基础动画到层中的时候，它开始运行。当用属性做动画完成时，例如用位置属性做动画，层就会立刻返回到它的初始位置。</p><h4 id="设定动画的属性说明"><a href="#设定动画的属性说明" class="headerlink" title="- 设定动画的属性说明"></a>- 设定动画的属性说明</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>duration</td><td>动画时长（单位：秒）</td></tr><tr><td>repeatCount</td><td>重复次数，永久重复的话设置为HUGE_VALF</td></tr><tr><td>beginTime</td><td>指定动画开始时间。从开始指定延迟几秒执行的话，请设置为「CACurrentMediaTime() + 秒数」的形式</td></tr><tr><td>timingFunction</td><td>设定动画的速度变化</td></tr><tr><td>autoreverses</td><td>动画结束时是否执行逆动画</td></tr><tr><td>shadowColor</td><td>阴影的颜色</td></tr><tr><td>shadowOffset</td><td>阴影的偏移量</td></tr><tr><td>shadowOpacity</td><td>阴影的透明度</td></tr><tr><td>shadowRadius</td><td>阴影的圆角</td></tr><tr><td>fromValue</td><td>所改变属性的起始值</td></tr><tr><td>toValue</td><td>所改变属性的结束时的值</td></tr><tr><td>byValue</td><td>所改变属性相同起始值得改变量</td><td>;</td></tr></tbody></table><h4 id="常用的animationWithKeyPath值的总结"><a href="#常用的animationWithKeyPath值的总结" class="headerlink" title="- 常用的animationWithKeyPath值的总结"></a>- 常用的animationWithKeyPath值的总结</h4><table><thead><tr><th>值</th><th>说明</th><th>使用形式</th></tr></thead><tbody><tr><td>transform.scale</td><td>比例转化</td><td>@(0.8)</td></tr><tr><td>transform.scale.x</td><td>宽的比例</td><td>@(0.8)</td></tr><tr><td>transform.scale.y</td><td>高的比例</td><td>@(0.8)</td></tr><tr><td>transform.rotation.x</td><td>围绕x轴旋转</td><td>@(M_PI)</td></tr><tr><td>transform.rotation.y</td><td>围绕y轴旋转</td><td>@(M_PI)</td></tr><tr><td>transform.rotation.z</td><td>围绕z轴旋转</td><td>@(M_PI)</td></tr><tr><td>cornerRadius</td><td>圆角的设置</td><td>@(20)</td></tr><tr><td>backgroundColor</td><td>背景颜色的变化</td><td>[UIColor orangeColor].CGColor;</td></tr><tr><td>bounds</td><td>大小，中心不变</td><td>[NSValue valueWithCGRect:CGRectMake(100,100)];</td></tr><tr><td>position</td><td>位置(中心点的改变)</td><td>[NSValue valueWithCGPoint:CGPointMake(100,100)];</td></tr><tr><td>contents</td><td>内容(比如UIImageView的图片)</td><td>imageAnima.toValue = (id)[UIImage imageNamed:@“toIcon”].CGImage;</td></tr><tr><td>opacity</td><td>透明度</td><td>@(0.8)</td></tr><tr><td>contentsRect.size.width</td><td>横向拉伸缩放</td><td>@(0.5)最好在0~1之间</td></tr></tbody></table><h5 id="捕获动画开始时和终了时的事件"><a href="#捕获动画开始时和终了时的事件" class="headerlink" title="- 捕获动画开始时和终了时的事件"></a>- 捕获动画开始时和终了时的事件</h5><p>设置委托对象，实现委托方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 动画开始时 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animationDidStart</span><span class="selector-pseudo">:(CAAnimation</span> *)<span class="selector-tag">theAnimation</span> &#123;</span><br><span class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"begin"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 动画结束时 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animationDidStop</span><span class="selector-pseudo">:(CAAnimation</span> *)<span class="selector-tag">theAnimation</span> <span class="selector-tag">finished</span><span class="selector-pseudo">:(BOOL)flag</span> &#123;  </span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"end"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><code>CAShapeLayer</code>和<code>UIBezierPath</code>规定一个形状，<code>CABasicAnimation</code>为其添加动画。下一篇我将写具体的实例。最后，非常感谢您阅读全文。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=347128&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660824.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CAShapeLayer&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;CAShapeLayer常用属性及可设置说明&lt;/li&gt;
&lt;li&gt;CAShapeLayer特点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UIBezierPath&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;UIBezierPath几种初始化方式说明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CABasicAnimation&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;CABasicAnimation是什么？&lt;/li&gt;
&lt;li&gt;CABasicAnimation设定动画的属性说明&lt;/li&gt;
&lt;li&gt;CABasicAnimation常用的KeyPath值总结&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>一个程序员的12个新年愿望</title>
    <link href="http://yoursite.com/2017/02/05/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8412%E4%B8%AA%E6%96%B0%E5%B9%B4%E6%84%BF%E6%9C%9B/"/>
    <id>http://yoursite.com/2017/02/05/一个程序员的12个新年愿望/</id>
    <published>2017-02-04T16:00:00.000Z</published>
    <updated>2018-06-05T06:25:20.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660845.jpg" alt=""></p><a id="more"></a><p>2017年的工作从今天正式开始了(从春节后算)，在新的一年，总结了12个新年心愿。</p><blockquote><ul><li>保持健康</li><li>学习一门新的编程语言</li><li>坚持写博客</li><li>注意安全</li><li>戒烟</li><li>早睡早起</li><li>出去走走</li><li>追求喜欢的人</li><li>健身</li><li>有自己的窝</li><li>保持联系</li><li>完成一个个人项目</li></ul></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31445772&auto=1&height=66"></iframe><ul><li><code>保持健康</code></li></ul><p>保持健康，不管是现在还是将来。<br>每天都久坐在座位上，又不爱锻炼的程序员，带来了健康的严峻挑战。<br>当我还在二十一二岁的时候，那时的我当然没察觉到健康到底对我有多重要，能跑能跳能熬夜能饿肚子能吃很多；当我快要三十岁了得时候，我终于意识到健康对我来说有多重要，不能跑不能跳不能熬夜不能饿肚子只能吃很少，以前认为的那种旺盛精力是不可能一直存在的，生活的方方面面都潜存着压力，身体的机能也一直在慢慢下降，你以为自己还好的很，但是身体是最不会撒谎的，如果不爱惜，它会准时的提醒你。<br>譬如现在一年总会感冒二到三次，而且必经三阶段：嗓子疼—&gt;流鼻涕—&gt;头疼，总是持续很长时间，吃药才能好，以前那个感冒了睡一觉出身汗就屁事儿没有的我已经不复存在了%&gt;_&lt;%。<br>现在，腰、颈、背 都是问题，纠正坐姿，站立结合，越快越好~<br>现在，不管是作息、饮食、心情、身体 都保持健康QAQ。</p><ul><li><code>学习一门新的编程语言</code></li></ul><p>保持学习是对自己不被淘汰的最大负责。<br>不管是主流的，还是非主流的，只要坚持学习，就一定是自己的收获~</p><ul><li><code>坚持写博客</code></li></ul><p>写博客已经是一个爱好了，有时候就是觉得自己写的不够好才不敢放出来，看了大神的写作确实会受到打击，但谁不是从新手过来的呢。<br>只要做好自己，应该就是最好的了吧~<br>工作，生活，学习，感想 都想统统的记下来~<br>积累下来，也不失为一笔财富~<br>也许多年之后，再回首，也感慨，不度虚年~</p><ul><li><code>注意安全</code></li></ul><p>注意安全，其实包括着方方面面。比如说每天出门的时候记得锁门，记得带钥匙。过马路的时候注意车辆，出去玩的时候注意保护自己，骑行的时候注意安全，</p><ul><li><code>戒烟</code></li></ul><p>啥也不说了，抽完这包不抽了…<br><img src="http://upload-images.jianshu.io/upload_images/1276164-d857e649f08f2dff.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这是最后一包烟"></p><ul><li><code>早睡早起</code></li></ul><p>早睡早起可能是最容易做到也可能是最难做到的了，舍不得早晨温暖的被窝，舍不得浪费夜晚大把的时光~</p><ul><li><code>出去走走</code></li></ul><p>河山大好，出去走走，别窝在家当懒虫，碧海蓝天吹吹风~<br>弹指一挥人生苦短，好地方一生都看不完。</p><ul><li><code>追求喜欢的人</code></li></ul><p>略。</p><ul><li><code>健身</code></li></ul><p>不让自己的身体提前进入老年化，要健康也要好身材QAQ</p><ul><li><code>有自己的窝</code></li></ul><p>这可能是一件最令我幸福也是最有压力的一件事了…</p><ul><li><code>保持联系</code></li></ul><p>和亲近的人保持联系，和不亲近的人随风而去~</p><ul><li><code>完成一个个人项目</code></li></ul><p>抽时间选一个有趣的项目慢慢完成它，不用赶进度，尽量完美，再好不过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660845.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="诗意生活" scheme="http://yoursite.com/categories/%E8%AF%97%E6%84%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="flag" scheme="http://yoursite.com/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>纪念狗正八</title>
    <link href="http://yoursite.com/2017/01/28/%E7%BA%AA%E5%BF%B5%E7%8B%97%E6%AD%A3%E5%85%AB/"/>
    <id>http://yoursite.com/2017/01/28/纪念狗正八/</id>
    <published>2017-01-28T14:02:13.000Z</published>
    <updated>2018-05-20T04:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在青春中，爱情只是其中的一部分，甚至在青春的爱情里，闪光的不是结局，而是那青涩懵懂的过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/1276164-bc83b67a349af60f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请回答1988"></p><a id="more"></a><p>狗正八，一张苦瓜脸，首尔大学补刀专业毕业，性情冷漠。</p><p>但是狗正八，真的很man，因为他是狗正八，是珍惜所有人的狗正八。为了爸爸开心可以做不喜欢的（goldstar）见面礼，为了妈妈开心可以做听话的“二女儿”，为了哥哥去飞行学院；为了朋友伸出拳头，为了维系伙伴关系不跨越界限一直逃避，在这个青春懵懂的年纪，已经是如此成熟的狗正八！</p><p>很可惜，狗正八和德善永远是一个人进，一个人退，他们从未相向而行。正如他经过的时候，她低下了头，错过了一秒就错过了一生。</p><p>可能在狗正八的世界里，暗恋，已经是对自己的圆满了，我爱你，与你无关。</p><p>正如我一直相信他能和德善走在一起一样，直到最后的错过，雨中的独白，错过的时机，自我剖析的悔恨，狗正八的爱情在独白中已经交代，他已经完全退出了，而后餐厅借戒指的表白，可能是对自己青春的一种交代，一种释怀，对自己暗恋画上一个句号。然后还是开心的叫着特工队、喜东东、崔大师。</p><p>狗正八的爱情无疑是青涩的，他一直爱着那个叫德善的女孩，爱情和喷嚏是藏不住的，而他却把全部的力气用作隐藏。</p><p>一遍遍的拆解鞋带，直到那个女孩出现在假装不耐烦的离开~<br>若无其事的路过吐槽，而后带着憨厚的傻笑躲在窗口偷看~<br>在那个女孩每次看过来的时候收回凝视的目光~<br>当着小伙伴的面用力划开和女孩的界限~<br>夜晚的时候担心女孩有没有按时回家~<br>违背自己的心意说一些不好听得话~<br>收到粉红色衬衫开心的不得了~<br>下雨的时候撑伞等待~<br>精心准备圣诞礼物~<br>…<br><img src="http://upload-images.jianshu.io/upload_images/1276164-f6aa02bc8dd38beb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QAQ"></p><p>他的爱情无疑是纯真的，他的爱情缺无疑是稚嫩的。<br>然而，爱情从来不是逃避和躲藏后，期待对方的蓦然回首。<br>爱情需要努力的一步步靠近，而终相濡以沫。<br>爱情是世界上最脆弱的东西，它需要不断的呵护。更重要的是，它不是单方面的付出，而是两个人的靠近。</p><p>狗正八的独白：缘分就像是机遇，是他的犹豫摧毁了他的缘分。<br>是的，如果，他能少一点逃避，在德善被善宇伤害之前能够有勇气听善宇解释他的爱情，如果他能够在得知崔大师的心意后，有勇气正视德善，而不是用力逃开，那么最后那个红绿灯，根本不是上天的戏弄。</p><p>甚至，在最最开始的时候，当一切还没开始，他能坦率的告诉所有人，他喜欢德善，那么接下来的故事应该也很有趣。</p><p>可惜，他是狗正八，是珍惜所有人的狗正八，是贴心的“二女儿”，他想得太多，他也想得太少，他只是一个18岁的少年，只是一个普通的青春期的孩子，他没有做出该有的选择。<br>他的爱情，也许在他没解释粉红色衬衫的那一天就已经死了。<br>可是他却是如此的真实，我们是否也拥有一段无疾而终的暗恋，在那个蠢动的青春时代，在那个最初对异性有过萌动的青春，是否也偷偷爱着那么一个人，不敢告诉任何人，甚至是你最好的朋友。</p><p>你小心的爱着，全心全意的爱着，又用尽全身的力气去掩饰，知道你们各奔东西，知道你们再无缘分，于是某一天你们再次相遇，所有的萌动和情愫都已经远去，但是内心深处正如狗正八一样的低俗：如果当初我能够勇敢一点，如果没有选择逃避，如果不介意别人的眼光，如果没有那么多犹豫爱你所爱……可是没有如果，失去了所有如果，也没有任何可能。<br>甚至，连一次开玩笑的告白，都显得多余。</p><p>关于德善，其实正如她当时告诉阿爸的没有想做的事情一样，虽然看起来他喜欢过善宇，喜欢过狗正八，也喜欢崔大师，但是我只能认为她那是在情窦初开的时候对爱情的渴望，不像狗正八爱她那般，那么真切。</p><p>一句，不要去联谊<br>一句，你想想我为什么会来找你<br>一句，我会去（看电影）</p><p><img src="http://upload-images.jianshu.io/upload_images/1276164-db2e071831bf1f5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QwQ"></p><p>虽然结局也是很好的，但为什么我会如此的心疼狗正八。</p><p>人类是很肤浅的动物，青春充满了自卑和遐想(不仅仅是青春)，现实没有观众，你不能指望你所爱的人从你别扭的言语背后读懂你的内心。</p><p>不要以爱的名义去伤害爱你的人，不要以外爱情不会离开，不要用自己的爱感动了自己却无人所知。</p><p>现实中没有崔大师，没有这么完美的解决所有冲突的人物，故事的结局只会是多年以后，德善找到一个爱人，无意中发现青春时曾有人深深爱着自己，也是自己蠢萌有心意的对方，但是如今摊手耸肩。而狗正八呢，以为放弃了，保住自己珍惜的所有人，当再次见到初恋时，却物是人非。</p><p>如果你现在还在经历着同样的暗恋，还在别扭的掩饰，那么请不要。</p><p>错过的，终究会错过。<br>人类是脆弱的，时间和距离会腐烂所有的爱情，无一幸免。时间和距离也会治愈所有的伤痛，无一例外。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=400876423&auto=1&height=66"></iframe><p>SPIREJ<br>2017.01.28</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在青春中，爱情只是其中的一部分，甚至在青春的爱情里，闪光的不是结局，而是那青涩懵懂的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1276164-bc83b67a349af60f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请回答1988&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="诗意生活" scheme="http://yoursite.com/categories/%E8%AF%97%E6%84%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="观影" scheme="http://yoursite.com/tags/%E8%A7%82%E5%BD%B1/"/>
    
      <category term="忆青春" scheme="http://yoursite.com/tags/%E5%BF%86%E9%9D%92%E6%98%A5/"/>
    
  </entry>
  
</feed>
