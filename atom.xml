<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>等风来，等花开❀~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-05T06:32:42.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ぱゐずだιονε゜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS多线程之GCD</title>
    <link href="http://yoursite.com/2018/05/18/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD/"/>
    <id>http://yoursite.com/2018/05/18/iOS多线程之GCD/</id>
    <published>2018-05-17T17:18:30.000Z</published>
    <updated>2018-06-05T06:32:42.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660834.jpg" alt=""></p><blockquote><p>本文用来介绍 iOS 多线程中 GCD的相关知识以及使用方法。通过本文，您将了解到：</p><ol><li>GCD 简介</li><li>GCD 任务和队列</li><li>GCD 的使用步骤</li><li>GCD 的基本使用（6种不同组合区别）</li><li>GCD 线程间的通信</li><li>GCD 的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore</li></ol></blockquote><a id="more"></a><h3 id="1-GCD简介"><a href="#1-GCD简介" class="headerlink" title="1. GCD简介"></a>1. GCD简介</h3><p>什么是 GCD 呢？我们先来看看百度百科的解释简单了解下概念</p><blockquote><p>引自百度百科<br>Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p></blockquote><p><strong>为什么要用 GCD 呢？</strong></p><p>因为 GCD 有很多好处啊，具体如下：</p><ul><li>GCD 可用于多核的并行运算</li><li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li><li>既然 GCD 有这么多的好处，那么下面我们就来系统的学习一下 GCD 的使用方法。</li></ul><h3 id="2-GCD任务和队列"><a href="#2-GCD任务和队列" class="headerlink" title="2. GCD任务和队列"></a>2. GCD任务和队列</h3><p>学习 GCD 之前，先来了解 GCD 中两个核心概念：<strong>任务</strong>和<strong>队列</strong>。</p><p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：<strong>同步执行（sync）</strong>和<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力</strong>。</p><ul><li><strong>同步执行（sync）</strong>：<ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul></li><li><strong>异步执行（async）</strong>：<ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul></li></ul><p>举个简单例子：你要打电话给小明和小白。<br>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。<br>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p><blockquote><p>注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p></blockquote><p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：<br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-DispatchQueue.png" alt="image"><br>在 GCD 中有两种队列：<strong>串行队列和并发队列</strong>。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：<strong>执行顺序不同，以及开启线程数不同</strong>。</p><ul><li><strong>串行队列（Serial Dispatch Queue）</strong>：<ul><li>每次只有一个任务被执行。让任务一个接着一个地执行。一个任务执行完毕后，再执行下一个任务。</li><li>只开启一个新线程（或者不开启新线程，在当前线程执行任务）。</li></ul></li><li><strong>并发队列（Concurrent Dispatch Queue）</strong>：<ul><li>可以让多个任务并发（同时）执行。</li><li>可以开启多个线程，并且同时执行任务。<blockquote><p>注意：并发队列的并发功能只有在异步（dispatch_async）函数下才有效。</p></blockquote></li></ul></li></ul><p>两者具体区别如下两图所示。<br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-SerialDispatchQueue.png" alt="image"><br><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-ConcurrentDispatchQueue.png" alt="image"></p><h3 id="3-GCD的使用步骤"><a href="#3-GCD的使用步骤" class="headerlink" title="3. GCD的使用步骤"></a>3. GCD的使用步骤</h3><p>GCD 的使用步骤其实很简单，只有两步。</p><blockquote><ol><li>创建一个队列（串行队列或并发队列）</li><li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li></ol></blockquote><p>下边来看看队列的创建方法/获取方法，以及任务的创建方法。</p><h4 id="3-1-队列的创建方法-获取方法"><a href="#3-1-队列的创建方法-获取方法" class="headerlink" title="3.1 队列的创建方法/获取方法"></a>3.1 队列的创建方法/获取方法</h4><p>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列的创建方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><ul><li>对于串行队列，GCD 提供了的一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。<ul><li>所有放在主队列中的任务，都会放到主线程中执行。</li><li>可使用<code>dispatch_get_main_queue()</code>获得主队列。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主队列的获取方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><ul><li>对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue）。<ul><li>可以使用dispatch_get_global_queue来获取。需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局并发队列的获取方法</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-任务的创建方法"><a href="#3-2-任务的创建方法" class="headerlink" title="3.2 任务的创建方法"></a>3.2 任务的创建方法</h4><p>GCD 提供了同步执行任务的创建方法<code>dispatch_sync</code>和异步执行任务创建方法<code>dispatch_async</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步执行任务创建方法</span></span><br><span class="line"><span class="selector-tag">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放同步执行任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 异步执行任务创建方法</span></span><br><span class="line"><span class="selector-tag">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放异步执行任务代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p><blockquote><ol><li>同步执行 + 并发队列</li><li>异步执行 + 并发队列</li><li>同步执行 + 串行队列</li><li>异步执行 + 串行队列</li></ol></blockquote><p>实际上，刚才还说了两种特殊队列：<strong>全局并发队列、主队列</strong>。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p><blockquote><ol><li>同步执行 + 主队列</li><li>异步执行 + 主队列</li></ol></blockquote><p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。</p><table><thead><tr><th>区别</th><th>并发队列</th><th>串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步(sync)</td><td>没有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td><td>主线程调用：死锁卡住不执行 其他线程调用：没有开启新线程，串行执行任务</td></tr><tr><td>异步(async)</td><td>有开启新线程，并发执行任务</td><td>有开启新线程(1条)，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr></tbody></table><h3 id="4-GCD的基本使用"><a href="#4-GCD的基本使用" class="headerlink" title="4. GCD的基本使用"></a>4. GCD的基本使用</h3><p>先来讲讲并发队列的两种执行方式。</p><h4 id="4-1-同步执行-并发队列"><a href="#4-1-同步执行-并发队列" class="headerlink" title="4.1 同步执行 + 并发队列"></a>4.1 同步执行 + 并发队列</h4><ul><li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">55.095932</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">55.096086</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] syncConcurrent—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34</span>:<span class="number">57.097589</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">34:59.099100</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35</span>:<span class="number">01.099843</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:03.101171</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:05.101750</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:07.102414</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">35:07.102575</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19892</span>:<span class="number">4996930</span>] syncConcurrent—end</span><br></pre></td></tr></table></figure><p>从同步执行 + 并发队列中可看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（同步执行不具备开启新线程的能力）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行的（同步任务需要等待队列的任务执行结束）。</li><li>任务按顺序执行的。按顺序执行的原因：虽然并发队列可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（同步任务需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li></ul><h4 id="4-2-异步执行-并发队列"><a href="#4-2-异步执行-并发队列" class="headerlink" title="4.2 异步执行 + 并发队列"></a>4.2 异步执行 + 并发队列</h4><ul><li>可以开启多个线程，任务交替（同时）执行</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：可以开启多个线程，任务交替（同时）执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769269</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769496</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] asyncConcurrent—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">41.769725</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005237</span>] asyncConcurrent—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774442</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005566</span>] <span class="number">2</span>—&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774440</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005567</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">43.774440</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005565</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779286</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005567</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779302</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005565</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">45.779286</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19929</span>:<span class="number">5005566</span>] <span class="number">2</span>—&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在异步执行 + 并发队列中可以看出：</p><ul><li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，可以继续执行任务）。</li></ul><p><strong>接下来再来讲讲串行队列的两种执行方式</strong>。</p><h5 id="4-3-同步执行-串行队列"><a href="#4-3-同步执行-串行队列" class="headerlink" title="4.3 同步执行 + 串行队列"></a>4.3 同步执行 + 串行队列</h5><ul><li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">37.876811</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">37.876998</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] syncSerial—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">39.878316</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">41.879829</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">43.880660</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">45.881265</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">47.882257</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">49.883008</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">39:49.883253</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">19975</span>:<span class="number">5017162</span>] syncSerial—end</span><br></pre></td></tr></table></figure><p>在同步执行 + 串行队列可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行不具备开启新线程的能力）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><h4 id="4-4-异步执行-串行队列"><a href="#4-4-异步执行-串行队列" class="headerlink" title="4.4 异步执行 + 串行队列"></a>4.4 异步执行 + 串行队列</h4><ul><li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">17.029999</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:17.030212</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] asyncSerial—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">17.030364</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024757</span>] asyncSerial—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">19.035379</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:21.037140</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41:23.042220</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">25.042971</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">27.047690</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">3</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">41</span>:<span class="number">29.052327</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20008</span>:<span class="number">5024950</span>] <span class="number">3</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在异步执行 + 串行队列可以看到：</p><ul><li>开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><p>下边讲讲刚才我们提到过的特殊队列：<strong>主队列</strong>。</p><ul><li>主队列：GCD自带的一种特殊的串行队列<ul><li>所有放在主队列中的任务，都会放到主线程中执行</li><li>可使用dispatch_get_main_queue()获得主队列</li></ul></li></ul><p><strong>我们再来看看主队列的两种组合方式。</strong></p><h4 id="4-5-同步执行-主队列"><a href="#4-5-同步执行-主队列" class="headerlink" title="4.5 同步执行 + 主队列"></a>4.5 同步执行 + 主队列</h4><ul><li>同步执行 + 主队列在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</li></ul><h5 id="4-5-1-在主线程中调用同步执行-主队列"><a href="#4-5-1-在主线程中调用同步执行-主队列" class="headerlink" title="4.5.1 在主线程中调用同步执行 + 主队列"></a>4.5.1 在主线程中调用同步执行 + 主队列</h5><ul><li>互相等待卡住不可行</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点(主线程调用)：互等卡主不执行。</span></span><br><span class="line"><span class="comment"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncMain &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">36.842892</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20041</span>:<span class="number">5030982</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">36.843050</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20041</span>:<span class="number">5030982</span>] syncMain—begin</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>在<code>同步执行 + 主队列</code>可以惊奇的发现：</p><ul><li>在主线程中使用<code>同步执行 + 主队列</code>，追加到主线程的任务1、任务2、任务3都不再执行了，而且<code>syncMain---end</code>也没有打印，在XCode 9上还会报崩溃。这是为什么呢？</li></ul><p>这是因为我们在主线程中执行<code>syncMain</code>方法，相当于把<code>syncMain</code>任务放到了主线程的队列中。而<code>同步执行</code>会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把<code>任务1</code>追加到主队列中，<code>任务1</code>就在等待主线程处理完<code>syncMain</code>任务。而<code>syncMain</code>任务需要等待<code>任务1</code>执行完毕，才能接着执行。</p><p>那么，现在的情况就是<code>syncMain</code>任务和<code>任务1</code>都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p><p><strong>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</strong></p><h5 id="4-5-2-在其他线程中调用同步执行-主队列"><a href="#4-5-2-在其他线程中调用同步执行-主队列" class="headerlink" title="4.5.2 在其他线程中调用同步执行 + 主队列"></a>4.5.2 在其他线程中调用同步执行 + 主队列</h5><ul><li>不会开启新线程，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行 selector 任务</span></span><br><span class="line">[NSThread <span class="string">detachNewThreadSelector:</span><span class="meta">@selector</span>(syncMain) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">19.377321</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] currentThread—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">19.377494</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] syncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">21.384716</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">23.386091</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">25.387687</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">27.388648</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">29.390459</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">31.391965</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040132</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">31.392513</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20083</span>:<span class="number">5040347</span>] syncMain—end</span><br></pre></td></tr></table></figure><p>在其他线程中使用<code>同步执行 + 主队列</code>可看到：</p><ul><li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><p><strong>为什么现在就不会卡住了呢？</strong></p><p>因为<code>syncMain</code> 任务放到了其他线程里，而<code>任务1</code>、<code>任务2</code>、<code>任务3</code>都在追加到主队列中，这三个任务都会在主线程中执行。<code>syncMain</code>任务在其他线程中执行到追加<code>任务1</code>到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的<code>任务1</code>，等<code>任务1</code>执行完毕，再接着执行<code>任务2</code>、<code>任务3</code>。所以这里不会卡住线程。</p><h3 id="4-6-异步执行-主队列"><a href="#4-6-异步执行-主队列" class="headerlink" title="4.6 异步执行 + 主队列"></a>4.6 异步执行 + 主队列</h3><ul><li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncMain &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.981505</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.981935</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] asyncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">49.982352</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] asyncMain—end</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">51.991096</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">53.991959</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">1</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">55.992937</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">57.993649</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">59.994928</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">01.995589</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20111</span>:<span class="number">5046708</span>] <span class="number">3</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>在<code>异步执行 + 主队列</code>可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li><li>所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（因为主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。<br>弄懂了难理解、绕来绕去的<strong>队列+任务</strong>之后，我们来学习一个简单的东西：<strong>5. GCD 线程间的通信。</strong></li></ul><h3 id="5-GCD-线程间的通信"><a href="#5-GCD-线程间的通信" class="headerlink" title="5. GCD 线程间的通信"></a>5. GCD 线程间的通信</h3><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)communication &#123;</span><br><span class="line">    <span class="comment">// 获取全局并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">// 获取主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue(); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 异步追加任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            <span class="comment">// 追加在主线程中执行的任务</span></span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">03.462394</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5053282</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">05.465912</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5053282</span>] <span class="number">1</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">07.466657</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20154</span>:<span class="number">5052953</span>] <span class="number">2</span>—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li></ul><h3 id="6-GCD的其他方法"><a href="#6-GCD的其他方法" class="headerlink" title="6. GCD的其他方法"></a>6. GCD的其他方法</h3><h4 id="6-1-GCD-栅栏方法：dispatch-barrier-async"><a href="#6-1-GCD-栅栏方法：dispatch-barrier-async" class="headerlink" title="6.1 GCD 栅栏方法：dispatch_barrier_async"></a>6.1 GCD 栅栏方法：dispatch_barrier_async</h4><ul><li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于<code>栅栏</code>一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到<code>dispatch_barrier_async</code>方法在两个操作组间形成栅栏。</li></ul><p><code>dispatch_barrier_async</code>函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在<code>dispatch_barrier_async</code>函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-GCD-demo-barrier.png" alt="image"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栅栏方法 dispatch_barrier_async</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)barrier &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务 barrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"barrier---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);<span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务4</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"4---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">18.297745</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">1</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">18.297745</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48:20.301139</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">1</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48:20.301139</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">2</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">22.306290</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] barrier—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">24.311655</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] barrier—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">26.316943</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">4</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">26.316956</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">28.320660</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059273</span>] <span class="number">4</span>—&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">28.320649</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20188</span>:<span class="number">5059274</span>] <span class="number">3</span>—&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>在<code>dispatch_barrier_async</code>执行结果中可以看出：</p><ul><li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li></ul><h4 id="6-2-GCD-延时执行方法：dispatch-after"><a href="#6-2-GCD-延时执行方法：dispatch-after" class="headerlink" title="6.2 GCD 延时执行方法：dispatch_after"></a>6.2 GCD 延时执行方法：dispatch_after</h4><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的<code>dispatch_after</code>函数来实现。</p><p><strong>需要注意的是</strong>:<code>dispatch_after</code>函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code>函数是很有效的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时执行方法 dispatch_after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)after &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 2.0秒后异步追加任务代码到主队列，并开始执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"after---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">08.713784</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] currentThread—&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">08.713962</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] asyncMain—begin</span><br><span class="line"><span class="number">2018-02-23</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">10.714283</span>+<span class="number">0800</span> YSC-GCD-demo[<span class="number">20282</span>:<span class="number">5080295</span>] after—&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看出：在打印 <code>asyncMain---begin</code> 之后大约 <strong>2.0</strong> 秒的时间，打印了 <code>after---&lt;NSThread: 0x60000006ee00&gt;{number = 1, name = main}</code></p><p>本文系转载，如有侵权，告知我删除。感谢原文：<br><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS多线程GCD详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660834.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文用来介绍 iOS 多线程中 GCD的相关知识以及使用方法。通过本文，您将了解到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCD 简介&lt;/li&gt;
&lt;li&gt;GCD 任务和队列&lt;/li&gt;
&lt;li&gt;GCD 的使用步骤&lt;/li&gt;
&lt;li&gt;GCD 的基本使用（6种不同组合区别）&lt;/li&gt;
&lt;li&gt;GCD 线程间的通信&lt;/li&gt;
&lt;li&gt;GCD 的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="GCD" scheme="http://yoursite.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程之pthread、NSThread</title>
    <link href="http://yoursite.com/2018/05/15/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bpthread%E3%80%81NSThread/"/>
    <id>http://yoursite.com/2018/05/15/iOS多线程之pthread、NSThread/</id>
    <published>2018-05-15T14:32:42.000Z</published>
    <updated>2018-06-05T06:35:51.456Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660819.jpg" alt=""></p><blockquote><p>本文用来介绍 iOS 多线程中，pthread、NSThread 的使用方法及实现。<br>第一部分：pthread 的使用、其他相关方法。<br>第二部分：NSThread 的使用、线程相关用法、线程状态控制方法、线程之间的通信、线程安全和线程同步，以及线程的状态转换相关知识。</p></blockquote><a id="more"></a><h2 id="1-pthread"><a href="#1-pthread" class="headerlink" title="1. pthread"></a>1. pthread</h2><h3 id="1-1-pthread简介"><a href="#1-1-pthread简介" class="headerlink" title="1.1 pthread简介"></a>1.1 pthread简介</h3><p>pthread 是一套通用的多线程的 API，可以在Unix / Linux / Windows 等系统跨平台使用，使用 C 语言编写，需要程序员自己管理线程的生命周期，使用难度较大，我们在 iOS 开发中几乎不使用 pthread，但是还是来可以了解一下的。</p><h3 id="1-2-pthread使用方法"><a href="#1-2-pthread使用方法" class="headerlink" title="1.2 pthread使用方法"></a>1.2 pthread使用方法</h3><ol><li>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></li><li>其次要创建线程，并开启线程执行任务</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程: 定义一个pthread_t类型变量</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="comment">// 2. 开启线程: 执行任务</span></span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 3. 设置子线程的状态设置为 detached，该线程运行结束后会自动释放所有资源</span></span><br><span class="line">pthread_detach(thread);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">run</span><span class="params">(<span class="keyword">void</span> *param)</span>    <span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>pthread_create(&amp;thread, NULL, run, NULL);</code> 中各项参数含义：<ul><li>第一个参数<code>&amp;thread</code>是线程对象，指向线程标识符的指针</li><li>第二个是线程属性，可赋值<code>NULL</code></li><li>第三个<code>run</code>表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li><li>第四个是运行函数的参数，可赋值<code>NULL</code></li></ul></li></ul><h3 id="1-3-pthread-其他相关方法"><a href="#1-3-pthread-其他相关方法" class="headerlink" title="1.3 pthread 其他相关方法"></a>1.3 pthread 其他相关方法</h3><ul><li><code>pthread_create()</code> 创建一个线程</li><li><code>pthread_exit()</code> 终止当前线程</li><li><code>pthread_cancel()</code> 中断另外一个线程的运行</li><li><code>pthread_join()</code> 阻塞当前的线程，直到另外一个线程运行结束</li><li><code>pthread_attr_init()</code> 初始化线程的属性</li><li><code>pthread_attr_setdetachstate()</code> 设置脱离状态的属性（决定这个线程在终止时是否可以被结合）</li><li><code>pthread_attr_getdetachstate()</code> 获取脱离状态的属性</li><li><code>pthread_attr_destroy()</code> 删除线程的属性</li><li><code>pthread_kill()</code> 向线程发送一个信号</li></ul><h2 id="2-NSThread"><a href="#2-NSThread" class="headerlink" title="2. NSThread"></a>2. NSThread</h2><p>NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用<code>[NSThread currentThread]</code>来显示当前的进程信息。</p><h3 id="2-1-创建、启动线程"><a href="#2-1-创建、启动线程" class="headerlink" title="2.1 创建、启动线程"></a>2.1 创建、启动线程</h3><ul><li>先创建线程，再启动线程</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 2. 启动线程</span></span><br><span class="line">[thread start];    <span class="comment">// 线程一启动，就会在线程thread中执行self的run方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建线程后自动启动线程</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程后自动启动线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>隐式创建并启动线程</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程后自动启动线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新线程调用方法，里边为需要执行的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-线程相关用法"><a href="#2-2-线程相关用法" class="headerlink" title="2.2 线程相关用法"></a>2.2 线程相关用法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得主线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为主线程(对象方法)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为主线程(类方法)</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *current = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的名字——setter方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的名字——getter方法</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure><h3 id="2-3-线程状态控制方法"><a href="#2-3-线程状态控制方法" class="headerlink" title="2.3 线程状态控制方法"></a>2.3 线程状态控制方法</h3><ul><li>启动线程方法</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start;</span><br><span class="line"><span class="comment">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span></span><br></pre></td></tr></table></figure><ul><li>阻塞（暂停）线程方法</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="string">sleepUntilDate:</span>(NSDate *)date;</span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">sleepForTimeInterval:</span>(NSTimeInterval)ti;</span><br><span class="line"><span class="comment">// 线程进入阻塞状态</span></span><br></pre></td></tr></table></figure><ul><li>强制停止线程</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)<span class="keyword">exit</span>;</span><br><span class="line"><span class="regexp">//</span> 线程进入死亡状态</span><br></pre></td></tr></table></figure><h3 id="2-4-线程之间的通信"><a href="#2-4-线程之间的通信" class="headerlink" title="2.4 线程之间的通信"></a>2.4 线程之间的通信</h3><p>在开发中，我们经常会在子线程中进行耗时操作，操作结束后再回到主线程去刷新UI。这就涉及到了子线程和主线程之间的通信。先来了解一下官方关于NSThread的线程间通信的方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在主线程上执行操作</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait;</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait modes:<span class="params">(NSArray&lt;NSString *&gt; *)</span>array;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">// 在指定线程上执行操作</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector onThread:<span class="params">(NSThread *)</span>thr withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait modes:<span class="params">(NSArray *)</span>array NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector onThread:<span class="params">(NSThread *)</span>thr withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line"></span><br><span class="line">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object1 withObject:<span class="params">(id)</span>object2;</span><br></pre></td></tr></table></figure><p>我们通过一个经典的下载图片的DEMO来展示线程间的通信。具体步骤如下：</p><ol><li>开启一个子线程，在子线程中下载图片</li><li>回到主线程刷新UI，将图片展示在UIImageView中</li></ol><p>DEMO代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个线程下载图片</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImageOnSubThread &#123;</span><br><span class="line"><span class="comment">// 在创建的子线程中调用downloadImage下载图片</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(downloadImage) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下载图片，下载完之后回到主线程进行 UI 刷新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)downloadImage &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取图片 imageUrl</span></span><br><span class="line"><span class="built_in">NSURL</span> *imageUrl = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-icon.jpg"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 imageUrl 中读取数据(下载图片) -- 耗时操作</span></span><br><span class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</span><br><span class="line"><span class="comment">// 通过二进制 data 创建 image</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 回到主线程进行图片赋值和界面刷新</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(refreshOnMainThread:) withObject:image waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 回到主线程进行图片赋值和界面刷新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)refreshOnMainThread:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值图片到imageview</span></span><br><span class="line"><span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-线程安全与线程同步"><a href="#2-5-线程安全与线程同步" class="headerlink" title="2.5 线程安全与线程同步"></a>2.5 线程安全与线程同步</h3><p><strong>线程安全：</strong>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行的结果和单线程运行的结果是一样的，而且其他的变量的值也和预期是一样的，就是线程安全的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；<br>若有多个线程同时执行写操作（更改变量），一般都要考虑线程同步，否则的话就可能影响线程安全。</p><p><strong>线程同步：</strong>可以理解为线程A和线程B一块儿配合，A执行到一定的程度是要依靠线程B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。</p><p>举个简单的例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清楚（操作冲突）。等一个人说完（一个线程结束操作），另一个再说，（两一个线程再开始操作）。</p><p>下面，我们将模拟火车篇售卖的方式，实现NSThread线程安全和解决线程同步的问题。</p><p><strong>场景：</strong>总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同事售卖火车票，卖完为止。</p><h4 id="2-5-1-NSThread非线程安全"><a href="#2-5-1-NSThread非线程安全" class="headerlink" title="2.5.1 NSThread非线程安全"></a>2.5.1 NSThread非线程安全</h4><p>先看看不考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusNotSave &#123;</span><br><span class="line"><span class="comment">// 1. 设置剩余火车票为 50</span></span><br><span class="line"><span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置北京火车票售卖窗口的线程</span></span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow1 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow1.name = <span class="string">@"北京火车票售票窗口"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置上海火车票售卖窗口的线程</span></span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow2 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span>.ticketSaleWindow2.name = <span class="string">@"上海火车票售票窗口"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 开始售卖火车票</span></span><br><span class="line">[<span class="keyword">self</span>.ticketSaleWindow1 start];</span><br><span class="line">[<span class="keyword">self</span>.ticketSaleWindow2 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 售卖火车票(非线程安全)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketNotSafe &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果还有票，继续售卖</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.ticketSurplusCount --;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>,<span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread].name]);</span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;<span class="comment">//如果已卖完，关闭售票窗口</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后部分结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.428108+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：48 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.428112+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：49 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.631715+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：47 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.631715+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：46 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.833247+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：45 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:55.833289+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：45 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.038194+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：44 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.038223+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：43 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.239316+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459324]</span> 剩余票数：42 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 18<span class="selector-pseudo">:44</span><span class="selector-pseudo">:56.239318+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4226:459323]</span> 剩余票数：42 窗口：北京火车票售票窗口</span><br></pre></td></tr></table></figure><p>可以看到在不考虑线程安全的情况下，得到的票数是错乱的，这样显示不符合我们的需求，所以我们需要考虑线程安全的问题。</p><h4 id="2-5-2-NSThread线程安全"><a href="#2-5-2-NSThread线程安全" class="headerlink" title="2.5.2 NSThread线程安全"></a>2.5.2 NSThread线程安全</h4><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS实现线程加锁有很多种方式：@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。<br>为了简单起见，这里不对各种锁的解决方案和性能做分析，只用最简单的@synchronized来保证线程安全，从而解决线程同步的问题。</p><p>考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusNotSave &#123;</span><br><span class="line">    <span class="comment">// 1. 设置剩余火车票为 50</span></span><br><span class="line">    <span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 设置北京火车票售卖窗口的线程</span></span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow1 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span>     selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow1.name = <span class="string">@"北京火车票售票窗口"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置上海火车票售卖窗口的线程</span></span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow2 = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span>     selector:<span class="keyword">@selector</span>(saleTicketNotSafe) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.ticketSaleWindow2.name = <span class="string">@"上海火车票售票窗口"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 开始售卖火车票</span></span><br><span class="line">    [<span class="keyword">self</span>.ticketSaleWindow1 start];</span><br><span class="line">    [<span class="keyword">self</span>.ticketSaleWindow2 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售卖火车票(非线程安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketNotSafe &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">//如果还有票，继续售卖</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.ticketSurplusCount --;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>,<span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread].name]);</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果已卖完，关闭售票窗口</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:20.789485+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：49 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:20.993775+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：48 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.196806+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：47 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.401549+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：46 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.606336+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：45 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:21.809718+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：44 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.015090+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：43 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.219827+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：42 窗口：上海火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.423403+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480055]</span> 剩余票数：41 窗口：北京火车票售票窗口</span><br><span class="line">2018<span class="selector-tag">-05-21</span> 19<span class="selector-pseudo">:01</span><span class="selector-pseudo">:22.625025+0800</span> <span class="selector-tag">RunLoop</span><span class="selector-attr">[4378:480056]</span> 剩余票数：40 窗口：上海火车票售票窗口</span><br></pre></td></tr></table></figure><p>可以看出，在考虑了线程安全的情况下，加锁之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p><h3 id="2-6-线程的状态转换"><a href="#2-6-线程的状态转换" class="headerlink" title="2.6 线程的状态转换"></a>2.6 线程的状态转换</h3><p>当我们新建一条线程<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</code>，在内存中的表现为：</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange.png" alt=""></p><p>当调用<code>[thread start];</code>后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示：</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange1.png" alt=""></p><p>当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange2.png" alt=""></p><p><strong>下边我们来看看当前线程的状态转换：</strong></p><ul><li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li><li>如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。</li><li>如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。</li></ul><p>只看文字可能不太好理解，具体当前线程对象的状态变化如下图所示。</p><p><img src="https://ysc-demo-1254961422.file.myqcloud.com/YSC-phread-NSThread-demo-StatusChange3.png" alt=""></p><p>本文系转载，如有侵权，告知我删除。感谢原文：<a href="https://bujige.net/blog/iOS-Complete-learning-pthread-and-NSThread.html" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660819.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文用来介绍 iOS 多线程中，pthread、NSThread 的使用方法及实现。&lt;br&gt;第一部分：pthread 的使用、其他相关方法。&lt;br&gt;第二部分：NSThread 的使用、线程相关用法、线程状态控制方法、线程之间的通信、线程安全和线程同步，以及线程的状态转换相关知识。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="NSThread" scheme="http://yoursite.com/tags/NSThread/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程之RunLoop</title>
    <link href="http://yoursite.com/2018/05/10/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BRunLoop/"/>
    <id>http://yoursite.com/2018/05/10/iOS多线程之RunLoop/</id>
    <published>2018-05-10T14:32:42.000Z</published>
    <updated>2018-06-05T06:46:24.008Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-659241.jpg" alt=""></p><p><strong>本篇包括以下内容：</strong></p><ul><li>RunLoop简介</li><li>RunLoop相关类</li><li>RunLoop原理</li><li>RunLoop实战应用</li></ul><a id="more"></a><h2 id="1-RunLoop简介"><a href="#1-RunLoop简介" class="headerlink" title="1. RunLoop简介"></a>1. RunLoop简介</h2><h3 id="1-1-什么是RunLoop？"><a href="#1-1-什么是RunLoop？" class="headerlink" title="1.1 什么是RunLoop？"></a>1.1 什么是RunLoop？</h3><p>可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。哈哈，我更愿意翻译为『跑圈』。直观理解就像是不停的跑圈。</p><p>RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。</p><h3 id="1-2-RunLoop和线程"><a href="#1-2-RunLoop和线程" class="headerlink" title="1.2 RunLoop和线程"></a>1.2 RunLoop和线程</h3><p>RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。</p><p>一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。<br>我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。<br>RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。<br>主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。</p><h3 id="1-3-默认情况下主线程的RunLoop原理"><a href="#1-3-默认情况下主线程的RunLoop原理" class="headerlink" title="1.3 默认情况下主线程的RunLoop原理"></a>1.3 默认情况下主线程的RunLoop原理</h3><p>我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中UIApplicationMain函数内部帮我们开启了主线程的RunLoop，<code>UIApplicationMain</code>内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;        </span><br><span class="line">    BOOL <span class="built_in">running</span> = YES;</span><br><span class="line">    <span class="built_in">do</span> &#123;</span><br><span class="line">        <span class="comment">// 执行各种任务，处理各种事件</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="built_in">while</span> (<span class="built_in">running</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。</p><p>下图是苹果官方给出的RunLoop模型图。</p><p><img src="https://upload-images.jianshu.io/upload_images/1877784-6ab632fc118e31f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。</p><h2 id="2-RunLoop相关类"><a href="#2-RunLoop相关类" class="headerlink" title="2. RunLoop相关类"></a>2. RunLoop相关类</h2><p>下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。</p><ul><li>CFRunLoopRef：代表RunLoop的对象</li><li>CFRunLoopModeRef：RunLoop的运行模式</li><li>CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源</li><li>CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源</li><li>CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变</li></ul><p>下边详细讲解下几种类的具体含义和关系。</p><p>先来看一张表示这5个类的关系图（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>）。<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt=""></p><p>接着来讲解这5个类的相互关系（来源：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a>），这篇文章总结的特别好，就拿来参考一下，有兴趣的朋友可以去看看，写的很好。</p><p>一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。</p><ul><li>每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。</li><li>如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。</li><li>这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响。</li></ul><p><strong>下边我们来详细讲解下这五个类：</strong></p><h3 id="2-1-CFRunLoopRef"><a href="#2-1-CFRunLoopRef" class="headerlink" title="2.1 CFRunLoopRef"></a>2.1 CFRunLoopRef</h3><p>CFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：</p><ul><li>Core Foundation<ul><li>CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</li><li>CFRunLoopGetMain(); // 获得主线程的RunLoop对象</li></ul></li></ul><p>当然，在Foundation框架下获取RunLoop对象类的方法如下：</p><ul><li>Foundation<ul><li>[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</li><li>[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</li></ul></li></ul><h3 id="2-2-CFRunLoopModeRef"><a href="#2-2-CFRunLoopModeRef" class="headerlink" title="2.2 CFRunLoopModeRef"></a>2.2 CFRunLoopModeRef</h3><p>系统默认定义了多种运行模式（CFRunLoopModeRef），如下：</p><ol><li><strong>kCFRunLoopDefaultMode</strong>：App的默认运行模式，通常主线程是在这个运行模式下运行</li><li><strong>UITrackingRunLoopMode</strong>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li><li>UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li><li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li><li><strong>kCFRunLoopCommonModes</strong>：伪模式，不是一种真正的运行模式（后边会用到）</li></ol><p>其中<strong>kCFRunLoopDefaultMode</strong>、<strong>UITrackingRunLoopMode</strong>、<strong>kCFRunLoopCommonModes</strong>是我们开发中需要用到的模式，具体使用方法我们在 <strong>2.3 CFRunLoopTimerRef</strong> 中结合CFRunLoopTimerRef来演示说明。</p><h3 id="2-3-CFRunLoopTimerRef"><a href="#2-3-CFRunLoopTimerRef" class="headerlink" title="2.3 CFRunLoopTimerRef"></a>2.3 CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer（哈哈，这个理解就简单了吧）。</p><p>下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法，从而加深理解。</p><ol><li>首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。</li><li>在ViewController.m文件中加入以下代码，来演示。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个定时器，约定两秒之后调用self的run方法</span></span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。</li><li>但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。</li></ol><p>这是因为：</p><ul><li>当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。</li><li>而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。</li><li>但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。</li></ul><p>你可以试着将上述代码中的<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>语句换为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</code>，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。</p><p>那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？</p><p>当然可以，这就用到了我们之前说过的<strong>伪模式（kCFRunLoopCommonModes）</strong>，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。</p><p>那么哪些模式被标记上了Common Modes呢？</p><p><strong>NSDefaultRunLoopMode</strong> 和 <strong>UITrackingRunLoopMode</strong>。</p><p>所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。</p><p>具体做法就是讲添加语句改为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p><p>既然讲到了NSTimer，这里顺便讲下NSTimer中的<code>scheduledTimerWithTimeInterval</code>方法和RunLoop的关系。添加下面的代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">2.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(run) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br></pre></td></tr></table></figure><p>这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">2.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(run) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure><h3 id="2-4-CFRunLoopSourceRef"><a href="#2-4-CFRunLoopSourceRef" class="headerlink" title="2.4 CFRunLoopSourceRef"></a>2.4 CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。</p><ul><li><p>第一种按照官方文档来分类（就像RunLoop模型图中那样）：</p><ul><li>Port-Based Sources（基于端口）</li><li>Custom Input Sources（自定义）</li><li>Cocoa Perform Selector Sources</li></ul></li><li><p>第二种按照函数调用栈来分类：</p><ul><li>Source0 ：非基于Port</li><li>Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件</li></ul></li></ul><p>这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。</p><p>下边我们举个例子大致来了解一下函数调用栈和Source。</p><ol><li>在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。</li><li>然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/1877784-f801715c95de19f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>然后运行程序，并点击按钮。</li><li>然后在项目中单击下图红色部分。<br><img src="https://upload-images.jianshu.io/upload_images/1877784-970c15ff611d4d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>可以看到如下图所示的就是点击事件产生的函数调用栈。<br><img src="https://upload-images.jianshu.io/upload_images/1877784-c014e77adce248c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p>所以，点击事件是这样来的：</p><ol><li><p>首先启动程序，调用16行的main函数，main函数调用15行的UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。</p></li><li><p>同时我们可以看到11行中有Source0，也就是说我们点击函数是属于Source0函数的，点击事件就是在Source0中处理的。</p></li><li><p>而至于Source1，则是用来接收、分发系统事件，然后在分发到Source0中处理的。</p></li></ol><h3 id="2-5-CFRunLoopObserverRef"><a href="#2-5-CFRunLoopObserverRef" class="headerlink" title="2.5 CFRunLoopObserverRef"></a>2.5 CFRunLoopObserverRef</h3><p>CFRunLoopObserver是观察者，用来监听RunLoop的状态改变。</p><p>CFRunLoopObserver可以监听的状态改变有以下几种：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),               <span class="comment">// 即将进入Loop：1</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),        <span class="comment">// 即将处理Timer：2    </span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),       <span class="comment">// 即将处理Source：4</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),       <span class="comment">// 即将进入休眠：32</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),        <span class="comment">// 即将从休眠中唤醒：64</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),                <span class="comment">// 即将从Loop中退出：128</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U       <span class="comment">// 监听全部状态改变  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下边我们通过代码来监听下RunLoop中的状态改变。</p><ol><li>在viewController.m中添加如下代码。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建观察者</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"监听到RunLoop发生改变---%zd"</span>,activity);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者到当前RunLoop中</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放observer，最后添加完需要释放掉</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后运行，看下打印结果:</li></ol><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.694917<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.695057<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.695230<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.695338<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696426<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696564<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696686<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696784<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.696904<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-32</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713356<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-64</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713527<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-2</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713655<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-4</span></span><br><span class="line">2018<span class="string">-05</span><span class="string">-21</span> 14:10:18.713759<span class="string">+0800</span> RunLoop[2305:184915] 监听到RunLoop发生改变--<span class="string">-32</span></span><br></pre></td></tr></table></figure><p>可以看到RunLoop状态在不断的变化，最终变成了状态32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。</p><h2 id="3-RunLoop原理"><a href="#3-RunLoop原理" class="headerlink" title="3.RunLoop原理"></a>3.RunLoop原理</h2><p>好了，五个类都讲解完了，下边开始放大招了。这下我们就可以来理解RunLoop的运行逻辑了。</p><p>下边上一张之前提到的文章中博主提供的运行逻辑图<br><img src="https://upload-images.jianshu.io/upload_images/1877784-94c6cdb3a7864593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这张图对于我们理解RunLoop来说太有帮助了，下边我们可以来说下官方文档给我们的RunLoop逻辑。</p><p>在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。</p><p>具体顺序如下：</p><ol><li>通知观察者RunLoop已经启动</li><li>通知观察者即将要开始的定时器</li><li>通知观察者任何即将要启动的非基于端口的源</li><li>启动任何准备好的非基于端口的源</li><li>如果基于端口的源准备好并处于等待状态，立即启动，并进入步骤9</li><li>通知观察者线程进入休眠状态</li><li>将线程置于休眠直到任一下面的时间发生：<ul><li>某一事件到达基于端口的源</li><li>定时器启动</li><li>RunLoop设置的时间已经超时</li><li>RunLoop被显示唤醒</li></ul></li><li>通知观察者线程即将被唤醒</li><li>处理未处理的事件<ul><li>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2</li><li>如果输入源启动，传递相应的消息</li><li>如果RunLoop被显示唤醒且事件还没超时，重启RunLoop。进入步骤2</li></ul></li><li>通知观察者RunLoop结束</li></ol><h2 id="4-RunLoop实战应用"><a href="#4-RunLoop实战应用" class="headerlink" title="4. RunLoop实战应用"></a>4. RunLoop实战应用</h2><p>下面讲一下RunLoop的几种应用。</p><h3 id="4-1-NSTimer的使用"><a href="#4-1-NSTimer的使用" class="headerlink" title="4.1 NSTimer的使用"></a>4.1 NSTimer的使用</h3><p>NSTimer的使用方法在讲解CFRunLoopTimerRef类的时候详细讲解过，具体参考上边 <strong>2.3 CFRunLoopTimerRef</strong>。</p><h3 id="4-2-ImageView推迟显示"><a href="#4-2-ImageView推迟显示" class="headerlink" title="4.2 ImageView推迟显示"></a>4.2 ImageView推迟显示</h3><p>有时候，我们会遇到这种情况：<br>当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。</p><p>怎么解决这个问题呢？</p><p>这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：</p><ol><li><strong>监听UIScrollView的滚动</strong></li></ol><p>因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。</p><ol start="2"><li><strong>利用PerformSelector设置当前线程的RunLoop的运行模式</strong></li></ol><p>利用performSelector方法为UIImageView调用setImage:方法，并利用inModes将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.imageView <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">setImage:</span>) <span class="string">withObject:</span>[UIImage <span class="string">imageNamed:</span>@<span class="string">"tupian"</span>] <span class="string">afterDelay:</span><span class="number">4.0</span> <span class="string">inModes:</span>NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure><p>下面用Demo演示一下：</p><ol><li>在项目中的Main.storyboard中添加一个UIImageView，并添加属性，并简单添加一下约束（不然无法显示）如下图所示</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1877784-8253c4b57f1b674e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="2"><li>在项目中拖入一张图片，如下图</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1877784-b4777f945878a0b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="3"><li>然后我们在touchesBegan方法中添加下面的代码</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">touchesBegan:</span>(NSSet&lt;UITouch *&gt; *)touches <span class="string">withEvent:</span>(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self.imageView <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">setImage:</span>) <span class="string">withObject:</span>[UIImage <span class="string">imageNamed:</span>@<span class="string">"tupian"</span>] <span class="string">afterDelay:</span><span class="number">4.0</span> <span class="string">inModes:</span>@[NSDefaultRunLoopMode]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行程序，点击一下屏幕，然后拖动UIText View，拖动4秒以上，发现过了4秒之后，UIImageView还没有显示图片，当我们松开的时候，则显示图片，效果如下：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1877784-13880540c8c89552.gif?imageMogr2/auto-orient/strip" alt=""></p><p>这样我们就实现了在拖动完之后，在延迟显示UIImageView.</p><h3 id="4-3-后台常驻线程（很常用）"><a href="#4-3-后台常驻线程（很常用）" class="headerlink" title="4.3 后台常驻线程（很常用）"></a>4.3 后台常驻线程（很常用）</h3><p>我们在开发应用程序的时候，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好让这条线程永远常驻内存。</p><p>那么怎么做呢？</p><p>添加一条用于常驻内存强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。</p><p>具体实现过程如下：</p><ol><li>在项目的viewController.m中添加一条强引用的thread线程属性，如下：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"viewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">viewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在viewDidLoad中创建线程self.thread，使线程启动并执行run1方法</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，并调用run1方法执行任务</span></span><br><span class="line">    <span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run1) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// 开启线程</span></span><br><span class="line">    [<span class="keyword">self</span>.thread start];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里写任务</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----run1-----"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"未开启RunLoop"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行之后发现打印了 <em>—-run1—-</em>，而 <em>未开启RunLoop</em> 则未打印。</li></ol><p>这时，我们就开启了一条常驻线程，下面我们来试着添加其他任务，除了之前创建的时候调用了run1方法，我们另外在点击的时候调用run2方法</p><p>那么，我们在touchesBegan中调用PerformSelector，从而实现在点击屏幕的时候调用run2方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 利用performSelector，在self.thread的线程中调用run2方法执行任务</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run2) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----run2------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过运行测试，除了之前打印的<em>—-run1—-</em>，每当我们点击屏幕，都能调用<em>—-run2—-</em>。<br>这样我们就实现了常驻线程的需求。</p><p>本文系转载，如有侵权，告知我删除。 感谢原文：<a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" target="_blank" rel="noopener">彻底学会多线程之『RunLoop』</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-659241.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇包括以下内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RunLoop简介&lt;/li&gt;
&lt;li&gt;RunLoop相关类&lt;/li&gt;
&lt;li&gt;RunLoop原理&lt;/li&gt;
&lt;li&gt;RunLoop实战应用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="RunLoop" scheme="http://yoursite.com/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>追忆</title>
    <link href="http://yoursite.com/2017/06/09/%E8%BF%BD%E5%BF%86/"/>
    <id>http://yoursite.com/2017/06/09/追忆/</id>
    <published>2017-06-09T09:52:21.000Z</published>
    <updated>2018-06-05T06:50:29.669Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660821.jpg" alt=""></p><p><del>一首歌，一个故事，一个人，一个世界</del></p><a id="more"></a><p>突然听到一首歌<br>想起是你曾经很喜欢的歌<br>“你说过牵了手就算约定”<br>“但亲爱的那并不是爱情”</p><p>虽然这么多年过去了<br>虽然好几年没联系了<br>但关于你的一切都在遇到熟悉的东西时不自然的想起</p><p>把你送我的东西整理起来<br>当年没勇气带在身边<br>但后来朋友告诉我把东西弄丢了<br>我的内心几乎是崩溃的<br>仿佛感觉我的青春被焚烧了一般<br>感觉自己永远都不会再拥有青春</p><p>现在<br>我们成了永远的陌路人<br>但我们一起走过的青春岁月<br>我会一直记得<br>那是生命中最美好的部分</p><p>其实<br>我一直想告诉你<br>男人是需要成长的<br>如果当年我有你那样成熟的高度<br>且不那么懦弱的面对一些现实问题<br>也许…<br>罢了…<br>如果就是如果<br>也许也只能是也许<br>现在想起那句一个男人在最无用的时候<br>遇到想要保护一生的女人<br>奈何奈何</p><p>现在我成长了<br>我不在渴求那样的爱情<br>我也从不觉得年近而立就得恋爱结婚<br>一个人的日子有点孤单<br>但也自在快乐</p><p>现在我没有你的消息<br>你不需要我的消息<br>但我永远祝福你过的比我好<br>祝福你一定要幸福</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=36841953&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660821.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;一首歌，一个故事，一个人，一个世界&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="诗意生活" scheme="http://yoursite.com/categories/%E8%AF%97%E6%84%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>swift入门项目实战之遇坑出坑</title>
    <link href="http://yoursite.com/2017/05/27/swift%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B9%8B%E9%81%87%E5%9D%91%E5%87%BA%E5%9D%91/"/>
    <id>http://yoursite.com/2017/05/27/swift入门项目实战之遇坑出坑/</id>
    <published>2017-05-27T07:10:22.000Z</published>
    <updated>2018-06-05T06:55:54.314Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-658274.jpg" alt=""></p><p>本篇主要是关于</p><ol><li>初学swift时，练手的一个demo</li><li>遇到的一点坑及如何解决的</li></ol><p>有兴趣的朋友可以看看<a href="https://github.com/SPIREJ/XSLC_Swift" target="_blank" rel="noopener">demo</a></p><a id="more"></a><p><strong>环境：swift版本3.0</strong></p><ul><li>首页：<ul><li>首页主要由banner、collectionView、tableView 组成</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-8dd445ec88ad80c9.gif?imageMogr2/auto-orient/strip" alt="首页"></p><ul><li>理财页<ul><li>理财列表页、计划详情页以及键盘等</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-54ba71800d8ad53a.gif?imageMogr2/auto-orient/strip" alt="理财"></p><ul><li>我的页<ul><li>collectionView 、webView</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1276164-dc48d734c996f772.gif?imageMogr2/auto-orient/strip" alt="我的"></p><ul><li>初学者，UI就这么多，就说说遇到的两个坑吧~<h5 id="第一个坑，使用pod建立工程时终端出错"><a href="#第一个坑，使用pod建立工程时终端出错" class="headerlink" title="第一个坑，使用pod建立工程时终端出错"></a>第一个坑，使用pod建立工程时终端出错</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod[!] Unable <span class="built_in">to</span> <span class="built_in">add</span> <span class="keyword">a</span> source <span class="keyword">with</span> url `<span class="keyword">https</span>://github.com/CocoaPods/Specs.git` named `master`.You can</span><br><span class="line"> <span class="keyword">try</span> adding <span class="keyword">it</span> manually <span class="keyword">in</span> `~/.cocoapods/repos` <span class="keyword">or</span> via `pod repo <span class="built_in">add</span>`.</span><br></pre></td></tr></table></figure></li></ul><p>解决方案：终端输入以下命令<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add <span class="keyword">master</span> <span class="title">https</span>://github.com/CocoaPods/Specs.git</span><br></pre></td></tr></table></figure></p><p>然后提示执行<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="built_in">setup</span></span><br></pre></td></tr></table></figure></p><p>如果出现<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod[!] The `master` repo is <span class="literal">not</span> <span class="literal">a</span> git repo.</span><br></pre></td></tr></table></figure></p><p>进入/users/你的用户名/.cocoapods/repos，删除master文件夹然后执行，如我这么进入<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.cocoapods/repos/</span></span><br></pre></td></tr></table></figure></p><p>master文件夹是个目录，删除时需要连下面的分支一起删掉<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~<span class="regexp">/.cocoapods/</span>repos<span class="regexp">/master</span></span><br></pre></td></tr></table></figure></p><p>删除master之后，再<code>pod setup</code>,之后配置好你的<code>Podfile</code>,最后<code>pod install</code>就成功的建立了 同名的<code>.xcworkspace</code>工程了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pod setup</span><br><span class="line"><span class="meta">#</span><span class="bash">先 <span class="built_in">cd</span> 到你工程的目录</span></span><br><span class="line">pod init</span><br><span class="line">open -a Xcode Podfile</span><br><span class="line"><span class="meta">#</span><span class="bash">添加你需要的三方库</span></span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p><ul><li>还有以下情况：<br>如果是安装多个Xcdoe，还需要选择Xcode的路径,后面是你自己的Xcode路径，显示Xcode包内容可查看<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sudo</span> xcode-<span class="keyword">select </span>-<span class="keyword">switch </span>/Applications/Xcode.app/</span><br></pre></td></tr></table></figure></li></ul><p>在终端里输入下方命令可以知道Xcode的路径：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span> -p</span><br></pre></td></tr></table></figure></p><h5 id="第二个坑，加载基于XIB创建的自定义控件时报错"><a href="#第二个坑，加载基于XIB创建的自定义控件时报错" class="headerlink" title="第二个坑，加载基于XIB创建的自定义控件时报错"></a>第二个坑，加载基于XIB创建的自定义控件时报错</h5><ul><li><p>我像写OC的基于XIB自定义控件一样,创建一个基于<code>UIView</code>的新类<code>XSCustomView</code><br><img src="http://upload-images.jianshu.io/upload_images/1276164-1b14c0c6d09230a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建基于UIView的新类XSCustomView"></p></li><li><p>创建一个同名的<code>XIB</code>文件<br><img src="http://upload-images.jianshu.io/upload_images/1276164-5cf6d8adcca145fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建一个同名的XIB文件"></p></li><li><p>像OC一样给文件指定类<br><img src="http://upload-images.jianshu.io/upload_images/1276164-c8a1c91da6af44f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="像OC一样给文件连线"></p></li><li><p>然后加载View就会出错</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="keyword">error</span>: init(coder:) has not been implemented: <span class="keyword">file</span> </span><br><span class="line">/路径/XXX.swift, <span class="keyword">line</span> 43</span><br><span class="line">(lldb)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 解决办法，查了好久资料，找到解决办法</span><br><span class="line">swift指定类与OC略有不同，swift需要的是<span class="symbol">`File'</span>s Owner`归属于咱们定义的哪个类,而下面的<span class="keyword">View</span>是不需要指定类的</span><br><span class="line">![解决问题](http:<span class="comment">//upload-images.jianshu.io/upload_images/1276164-f09189b3807fa34b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">- 最后咱们从XIB加载<span class="keyword">View</span>即可，如在custom.swift文件里有如下代码</span><br></pre></td></tr></table></figure></li></ul><p>class XSCustomView: UIView {</p><pre><code>var contentView:UIView!override func awakeFromNib() {    super.awakeFromNib()}override init(frame: CGRect) {    super.init(frame: frame)    contentView = loadFromNib()    addSubview(contentView)}func loadFromNib() -&gt; UIView {    return Bundle.main.loadNibNamed(&quot;XSCustomView&quot;, owner: nil, options: nil)?.first as! UIView}override func layoutSubviews() {    contentView.frame = bounds}required init?(coder aDecoder: NSCoder) {    super.init(coder: aDecoder)    fatalError(&quot;init(coder:) has not been implemented&quot;)}</code></pre><p>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-658274.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇主要是关于&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初学swift时，练手的一个demo&lt;/li&gt;
&lt;li&gt;遇到的一点坑及如何解决的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有兴趣的朋友可以看看&lt;a href=&quot;https://github.com/SPIREJ/XSLC_Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何在swift中实现oc中的分类</title>
    <link href="http://yoursite.com/2017/05/22/%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E5%AE%9E%E7%8E%B0oc%E4%B8%AD%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/05/22/如何在swift中实现oc中的分类/</id>
    <published>2017-05-22T09:02:24.000Z</published>
    <updated>2018-06-05T06:59:59.178Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-654521.jpg" alt=""></p><p>如何在swift中实现oc的<code>category</code>？<br>示例:<br>1、对<code>UIView</code>的扩展<br>2、对<code>UIColor</code>的扩展</p><a id="more"></a><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>在oc中为了增强已有类的功能，我们经常使用<code>分类</code>。使用分类，我们可以在不破坏原有类的结构的前提下，对原有类进行模块化的扩展。</p><p>但是在swift中没有分类这种写法了。相对应的是swift中只有扩展(<code>Extensions</code>)。</p><p>下面是swift中扩展(<code>Extensions</code>)的说明:<br>扩展就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（<code>functionality</code>）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（<code>categories</code>）类似。（不过与 Objective-C 不同的是，Swift 的扩展没有名字。）</p><h4 id="2-对UIView的扩展"><a href="#2-对UIView的扩展" class="headerlink" title="2.对UIView的扩展"></a>2.对UIView的扩展</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">extension UIView &#123;</span><br><span class="line">    <span class="comment">// .x</span></span><br><span class="line">    public <span class="selector-tag">var</span> x: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.x</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.origin</span><span class="selector-class">.x</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .y</span></span><br><span class="line">    public <span class="selector-tag">var</span> y: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.y</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.origin</span><span class="selector-class">.y</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .maxX</span></span><br><span class="line">    public <span class="selector-tag">var</span> maxX: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.maxX</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .maxY</span></span><br><span class="line">    public <span class="selector-tag">var</span> maxY: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.maxY</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .centerX</span></span><br><span class="line">    public <span class="selector-tag">var</span> centerX: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.center</span><span class="selector-class">.x</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self<span class="selector-class">.center</span> = CGPoint(x: newValue, y: self<span class="selector-class">.center</span><span class="selector-class">.y</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .centerY</span></span><br><span class="line">    public <span class="selector-tag">var</span> centerY: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.center</span><span class="selector-class">.y</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self<span class="selector-class">.center</span> = CGPoint(x: self<span class="selector-class">.center</span><span class="selector-class">.x</span>, y: newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .width</span></span><br><span class="line">    public <span class="selector-tag">var</span> <span class="attribute">width</span>: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.width</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.size</span><span class="selector-class">.width</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .height</span></span><br><span class="line">    public <span class="selector-tag">var</span> <span class="attribute">height</span>: CGFloat &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return self<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.height</span></span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            <span class="selector-tag">var</span> rect = self.frame</span><br><span class="line">            rect<span class="selector-class">.size</span><span class="selector-class">.height</span> = newValue</span><br><span class="line">            self<span class="selector-class">.frame</span> = rect</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="selector-tag">label</span> = UILabel()</span><br><span class="line">        <span class="selector-tag">label</span>.x</span><br><span class="line">        <span class="selector-tag">label</span>.<span class="attribute">width</span></span><br><span class="line">        <span class="selector-tag">label</span>.centerX</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="3-对UIColor的扩展"><a href="#3-对UIColor的扩展" class="headerlink" title="3.对UIColor的扩展"></a>3.对UIColor的扩展</h4><p>十六进制颜色转换为rgb</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">colorWithHex</span><span class="params">(rgb:Int, alpha: CGFloat)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIColor</span>(red: ((<span class="type">CGFloat</span>)((rgb &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span>, green: ((<span class="type">CGFloat</span>)((rgb &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span>, blue: ((<span class="type">CGFloat</span>)(rgb &amp; <span class="number">0xFF</span>)) / <span class="number">255.0</span>, alpha: alpha)        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">UIColor</span><span class="selector-class">.clear</span><span class="selector-class">.colorWithHex</span>(<span class="selector-tag">rgb</span>: 0<span class="selector-tag">x2588dd</span>, <span class="selector-tag">alpha</span>: 1<span class="selector-class">.0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-654521.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如何在swift中实现oc的&lt;code&gt;category&lt;/code&gt;？&lt;br&gt;示例:&lt;br&gt;1、对&lt;code&gt;UIView&lt;/code&gt;的扩展&lt;br&gt;2、对&lt;code&gt;UIColor&lt;/code&gt;的扩展&lt;/p&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>归期不遇</title>
    <link href="http://yoursite.com/2017/03/20/%E5%BD%92%E6%9C%9F%E4%B8%8D%E9%81%87/"/>
    <id>http://yoursite.com/2017/03/20/归期不遇/</id>
    <published>2017-03-20T14:46:40.000Z</published>
    <updated>2018-06-05T06:20:41.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-657580.png" alt=""></p><a id="more"></a><h4 id="临时出发"><a href="#临时出发" class="headerlink" title="临时出发"></a>临时出发</h4><p>此刻我坐在从北京开往西安的火车上，由于临时出发没买到卧铺只有硬座将就一下，说“将就”可能对我来说还太牵强了，想起以前站过的火车，想起当年逃票的光辉历史，想起为了省点钱不买卧铺的日子，想起去武汉站13小时的信念……此刻，我觉得人活着还是不能缺了信念的。</p><h4 id="信念是什么？"><a href="#信念是什么？" class="headerlink" title="信念是什么？"></a>信念是什么？</h4><p>但是，关于信念到底是一种什么东西我又摸不清的，可能在我这就是一个你真心爱的人，一个你觉得舒适的城，一份你不讨厌的工作，一个可以实现的目标或者是你应尽的义务，比如作为子女应该像父母无私无怨养育你一样亲近父母，善待朋友，真诚待人不虚伪不造作。一个人真正有信念的时候，那时候他是强大的，拥有强大的内心力量和精神力量。</p><h4 id="向左向右？"><a href="#向左向右？" class="headerlink" title="向左向右？"></a>向左向右？</h4><p>有朋友面临毕业再为工作犯愁，大多数人都是这么走过来的，我觉得毕业的时候分几类人，其他的外界条件就都不考虑了，一类人完全明确自己想要做什么不担心做不好，一类人想做这个也想做那个但是担心自己做不做得好，还有一类人不知道自己想要做什么也觉得自己做不好。很不幸当年我就是属于最后一类，后来我发现大多数人毕业的时候都有焦虑症，我把这统称为“毕业综合症”。这绝对不是病，我们要离开一个熟悉的环境熟悉的人去探知不确定的未来，有焦虑有排斥有不舍，这种不舍在将来的几年内会更浓烈呢。总之，再没开始探险之前，未知的前方总是充满传奇的色彩和迷样的精彩，所以在向左还是向右的十字路口，不要害怕迈出哪一步是错误的还是正确的，因为不管是向左还是向右，最终都会在一个路口会和，迎来你想要的生活。</p><h4 id="曾很潇洒"><a href="#曾很潇洒" class="headerlink" title="曾很潇洒"></a>曾很潇洒</h4><p>和朋友聊到毕业时的情景，又想到去年另一位朋友告诉我 当年我说“那不是我想要的生活”，然后毅然决然就北漂了很帅气，觉得我是个很有主见的人。时隔两年听到别人这么赞美我很是高兴，没想到我也曾如此潇洒过。不可否认，虽然是面相长得年轻了点，但小时候的经历，二年级就自己报名以及一路走来坎坎坷坷的我向来是知道如何生存，如何独立的。说实话我并不是一个有很多正能力的人，也偶尔（可能是经常）负能量爆棚，所以我才一直积极乐观的生活，也害怕给身边的人带去负能量，我一直相信着自己，经历那么多不是被打败的，而是真正的强大起来。我相信人生没有如果只有后果和结果，我从不后悔自己做的每个决定和每件事。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>现在不止春节的时候父母才会讲我的终生大事了，已经成为每次通话的不可少话题了，好像无论聊什么都能聊到这的样子，每次大概是这样“都二十六七的人了，还不打算说媳妇儿…”。讲真，一个人的生活我也过了好多年了，谁不想找一个爱的人在一起互相慰藉，然而人生总是有很多不如意，比如在你不懂爱的年纪遇到爱你的人，不懂爱的年纪遇到你爱的，懂爱的年纪遇到你爱的不爱你的，懂爱的年纪遇不到你爱的也遇不到爱你的，最美好的年纪没有能力保护最想要保护的，有能力的时候已经淡然。父母总认为自己的孩子是最好的，也认为现在年轻人那么多，然而他们并不知其实现在人与人之间的交集早已经不如他们那个年代了，而且对于我这类人来说，喜欢一个人是多么的不容易的一件事。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someone == <span class="literal">I</span> loved) &#123;</span><br><span class="line"><span class="keyword">do</span> everything;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="literal">I</span> would like to sleeping alone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能这就是所谓的以前喜欢一个人，现在喜欢一个人吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-657580.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="诗意生活" scheme="http://yoursite.com/categories/%E8%AF%97%E6%84%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>使用CAShapeLayer &amp; UIBezierPath画图</title>
    <link href="http://yoursite.com/2017/02/24/%E4%BD%BF%E7%94%A8CAShapeLayer&amp;UIBezierPath%E7%94%BB%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/02/24/使用CAShapeLayer&amp;UIBezierPath画图/</id>
    <published>2017-02-24T03:14:10.000Z</published>
    <updated>2018-06-05T06:24:14.798Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660825.jpg" alt=""></p><blockquote><p>本篇主要从以下几个方面来写的一点东西：</p><ul><li>线段</li><li>曲线</li><li>动画</li><li>简单的柱状图</li><li>简单的折线图<a id="more"></a></li></ul></blockquote><h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-8c6af273e49d1835.gif?imageMogr2/auto-orient/strip" alt="线段"></p><ul><li>单线段<br>两点确定一条直线，给贝塞尔曲线一个起始点<code>moveToPoint</code>再添加一条线的终点<code>addLineToPoint</code>，这样就确定了一条直线。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLine &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1024</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">524</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"直线"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *line = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    line.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    line.strokeColor = [UIColor <span class="keyword">orangeColor].CGColor;</span></span><br><span class="line"><span class="keyword"> </span>   line.fillColor = nil<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:line];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(100, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    line.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>多线段<br>前面线段的终点是后面线段的起点。给一个起点<code>moveToPoint</code>，然后想添加几条线就给几个线的终点<code>addLineToPoint</code>。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawDoubleLine &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1025</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">525</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"折线"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *line = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    line.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    line.strokeColor = [UIColor <span class="keyword">orangeColor].CGColor;</span></span><br><span class="line"><span class="keyword"> </span>   line.fillColor = nil<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:line];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(100, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(200, </span><span class="number">100</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(250, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    line.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>闭合多边形<br>也是多线段连起来的，只不过最后一条线的终点为第一条线段的起点。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawTriangle &#123;</span><br><span class="line">    UIView *view = [self.view viewWithTag:<span class="number">1026</span>]<span class="comment">;</span></span><br><span class="line">    UILabel *label = [view viewWithTag:<span class="number">526</span>]<span class="comment">;</span></span><br><span class="line">    label<span class="meta">.text</span> = @<span class="string">"闭合多边形"</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *triangle = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    triangle.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    triangle.strokeColor = [UIColor redColor].CGColor<span class="comment">;</span></span><br><span class="line">    triangle.fillColor = [UIColor clearColor].CGColor<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:triangle];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0-100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0+100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    triangle.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>线端点样式<br>CAShapeLayer的<code>lineCap</code>属性决定线端点样式，可选样式<code>kCALineCapButt（默认）</code>，<code>kCALineCapRound（圆角）</code>，<code>kCALineCapSquare（平角）</code>。默认为<code>kCALineCapButt</code>也是平角。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3950101908ae9c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线端点样式示例"></p></li><li><p>线段拐点处样式<br>CAShapeLayer的<code>lineJoin</code>属性决定线端点样式，可选样式<code>kCALineJoinMiter（尖角）</code>，<code>kCALineJoinRound（圆角）</code>，<code>kCALineJoinBevel（平角）</code>。默认为<code>kCALineJoinMiter</code>。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-ae5278976c113bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拐角样式示例"></p></li><li><p>虚线</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *lineDashPattern;</span><br></pre></td></tr></table></figure><p>CAShapeLayer的<code>lineDashPattern</code>属性决定你画出一条什么样的虚线，这个属性返回一组<code>NSNumber</code>类型的数组，其实就是<code>实虚相交</code>来表示你的虚线，数组的长度由你决定（当然最好不要第一轮实虚相加超过线段长度）。比如<code>line.lineDashPattern = @[@10,@5,@2,@8];</code>就是表示每轮都为长度为10的实线，长度为5的虚线，长度为2的实线，长度为8的虚线，循环直到线段结束。</p><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-6cbeb754f0ff140f.gif?imageMogr2/auto-orient/strip" alt="曲线"></p><ul><li>二次贝塞尔曲线<br><img src="http://upload-images.jianshu.io/upload_images/1276164-db1b50a659d63560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二次贝塞尔曲线"><br>二次贝塞尔曲线有一个控制点，控制点的位置决定了显示一条怎样的曲线。下面的例子，我把起点pA、终点pB、控制点pC 都画出来方便观察。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//篇幅限制 只贴主要代码</span></span><br><span class="line"><span class="comment">//曲线</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *layerOne = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">layerOne.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">layerOne.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">layerOne.strokeStart = <span class="number">0</span>;</span><br><span class="line">layerOne.strokeEnd = <span class="number">1</span>;</span><br><span class="line">[view.layer addSublayer:layerOne];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:pA];</span><br><span class="line">[path addQuadCurveToPoint:pB controlPoint:pC];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关联路径</span></span><br><span class="line">layerOne.path = path.CGPath;</span><br></pre></td></tr></table></figure><ul><li>三次贝塞尔曲线<br>![Uploading Glass_和_iPhone_7_Plus_–_iOS_10_2__14C89__158499.png . . .]<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3cfcc224f189e5a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次贝塞尔曲线"><br>三次贝塞尔曲线有两个控制点，两个控制点的位置决定了显示一条怎样的曲线。下面的例子，我把起点pA、终点pB、控制点pC、pD 都画出来方便观察。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//篇幅限制 只贴主要代码</span></span><br><span class="line"><span class="comment">//曲线</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *layerTwo = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">layerTwo.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">layerTwo.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">layerTwo.strokeStart = <span class="number">0</span>;</span><br><span class="line">layerTwo.strokeEnd = <span class="number">1</span>;</span><br><span class="line">[view.layer addSublayer:layerTwo];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">[path moveToPoint:pA];</span><br><span class="line">[path addCurveToPoint:pB controlPoint1:pC controlPoint2:pD];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关联路径</span></span><br><span class="line">layerTwo.path = path.CGPath;</span><br></pre></td></tr></table></figure><ul><li>圆角矩形</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRectRound &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [<span class="keyword">self</span>.view viewWithTag:<span class="number">1028</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *rectRound = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(kDeviceWidth/<span class="number">2.0</span><span class="number">-100</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">100</span>) byRoundingCorners:<span class="built_in">UIRectCornerBottomLeft</span> | <span class="built_in">UIRectCornerBottomRight</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *layer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    layer.strokeColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    layer.fillColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;</span><br><span class="line">    layer.path = rectRound.CGPath;</span><br><span class="line">    </span><br><span class="line">    [view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1276164-7def553629daf890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆角矩形"></p><ul><li>虚线圆<br>如果是静态的(无动画)，那么需要两个贝塞尔圆环曲线表示内圆和外圆，内圆一周，外圆实时进度。<br>如果是动态的(有动画)，那么可以一个贝塞尔圆环曲线表示内圆和外圆，内、外圆都一周，外圆添加动画，动画的<code>toValue</code>标志实时进度。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-0e78eb5eaa0f4f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚线圆"></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawXuCircle &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [<span class="keyword">self</span>.view viewWithTag:<span class="number">1029</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//底部虚圆</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *xuCircle = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    xuCircle.lineWidth = <span class="number">10</span>;</span><br><span class="line">    xuCircle.strokeColor = ColorWithHex(<span class="number">0xbebebe</span>, <span class="number">1</span>).CGColor;</span><br><span class="line">    xuCircle.fillColor = <span class="literal">nil</span>;</span><br><span class="line">    xuCircle.lineJoin = kCALineJoinMiter;</span><br><span class="line">    xuCircle.lineDashPattern = @[@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    [view.layer addSublayer:xuCircle];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//外部虚圆</span></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *circle = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    circle.lineWidth = <span class="number">10</span>;</span><br><span class="line">    circle.strokeColor = ColorWithHex(<span class="number">0xa2d100</span>, <span class="number">1</span>).CGColor;</span><br><span class="line">    circle.fillColor = <span class="literal">nil</span>;</span><br><span class="line">    circle.lineJoin = kCALineJoinMiter;</span><br><span class="line">    circle.lineDashPattern = @[@<span class="number">2</span>,@<span class="number">3</span>];</span><br><span class="line">    [view.layer addSublayer:circle];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *xuBezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(kDeviceWidth/<span class="number">2.0</span>, <span class="number">100</span>) radius:<span class="number">55</span> startAngle:-M_PI_2 endAngle:<span class="number">3</span>*M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *bezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(kDeviceWidth/<span class="number">2.0</span>, <span class="number">100</span>) radius:<span class="number">55</span> startAngle:-M_PI_2 endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    xuCircle.path = xuBezierPath.CGPath;</span><br><span class="line">    circle.path = bezierPath.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><blockquote><p>现在我们来给一些图形加上动画，使运行起来更美观。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-879cf2a6c243266b.gif?imageMogr2/auto-orient/strip" alt="动画"></p></blockquote><ul><li>主要写了三类动画<br>1.最常用的普通动画<br>2.进度条动画<br>3.其他属性的动画（比如这里有重复次数和逆执行）</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通动画，strokeEnd</span></span><br><span class="line">- (CABasicAnimation *)animComm &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animComm</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animComm</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animComm</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animComm</span>.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        <span class="variable">_animComm</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animComm</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进度条动画</span></span><br><span class="line">- (CABasicAnimation *)animProgress &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animProgress</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animProgress</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animProgress</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animProgress</span>.toValue = @<span class="number">0.7</span>;</span><br><span class="line">        <span class="variable">_animProgress</span>.fillMode = kCAFillModeForwards;</span><br><span class="line">        <span class="variable">_animProgress</span>.removedOnCompletion = NO;</span><br><span class="line">        <span class="variable">_animProgress</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animProgress</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重复次数，逆执行试用</span></span><br><span class="line">- (CABasicAnimation *)animRepeat &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_animRepeat</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="variable">_animRepeat</span> = [CABasicAnimation animationWithKeyPath:@<span class="string">"strokeEnd"</span>];</span><br><span class="line">        <span class="variable">_animRepeat</span>.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.duration = <span class="number">2.0</span>;</span><br><span class="line">        <span class="variable">_animRepeat</span>.autoreverses = YES;</span><br><span class="line">        <span class="variable">_animRepeat</span>.repeatCount = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="variable">_animRepeat</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的柱状图"><a href="#简单的柱状图" class="headerlink" title="简单的柱状图"></a>简单的柱状图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-452e7362dd44076b.gif?imageMogr2/auto-orient/strip" alt="简单柱状图"></p><p>这是个非常简单的柱状图，需要注意的是柱子的三个重要部分，起点、终点、柱宽。柱子由起点根据柱宽向左右两边扩张，如下图柱子的起点是位置2而不是位置1。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-f226f1e227c4c8f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="柱状图"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SJBarChart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> lineWidth  = <span class="number">1.0</span>;      <span class="comment">//坐标轴线宽</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> distance   = <span class="number">20.0</span>;     <span class="comment">//距屏幕边距</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> cornerW    = <span class="number">10.0</span>f;    <span class="comment">//拐角长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> barWidth   = <span class="number">50.0</span>f;    <span class="comment">//柱状宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> space      = <span class="number">30.0</span>f;    <span class="comment">//柱状之间的间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> scale      = <span class="number">3.0</span>f;     <span class="comment">//柱状显示高度计算比例 *scale</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJBarChart</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> selfW, selfH;</span><br><span class="line">    <span class="built_in">NSArray</span> *source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *xAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *yAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *barScrollView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CABasicAnimation</span> *animation;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SJBarChart</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        selfW = frame.size.width;</span><br><span class="line">        selfH = frame.size.height;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showBarChart:(<span class="built_in">NSArray</span> *)sourceArray &#123;</span><br><span class="line">    source = sourceArray;</span><br><span class="line">    [<span class="keyword">self</span> addxyAxis];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.barScrollView];</span><br><span class="line">    _barScrollView.contentSize = <span class="built_in">CGSizeMake</span>(sourceArray.count*(space+barWidth) + space, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    [sourceArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *bar = [<span class="keyword">self</span> drawBar:idx];</span><br><span class="line">        [_barScrollView.layer addSublayer:bar];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//柱状图</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)drawBar:(<span class="built_in">NSInteger</span>)index &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *layer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    layer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    layer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    layer.lineWidth = barWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//终点y</span></span><br><span class="line">    <span class="built_in">CGFloat</span> y = _barScrollView.frame.size.height<span class="number">-60</span> - lineWidth/<span class="number">2.0</span> - ([[source objectAtIndex:index] floatValue] * scale);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>((space + barWidth)*index + (space+barWidth/<span class="number">2.0</span>), _barScrollView.frame.size.height<span class="number">-60</span>)];</span><br><span class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>((space + barWidth)*index + (space+barWidth/<span class="number">2.0</span>), y)];</span><br><span class="line">    layer.path = path.CGPath;</span><br><span class="line">    </span><br><span class="line">    [layer addAnimation:<span class="keyword">self</span>.animation forKey:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加坐标轴</span></span><br><span class="line">- (<span class="keyword">void</span>)addxyAxis &#123;</span><br><span class="line">    <span class="keyword">self</span>.xAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance, selfH<span class="number">-30</span>) endPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance-cornerW, selfH<span class="number">-30</span>-cornerW)];</span><br><span class="line">    <span class="keyword">self</span>.yAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance+lineWidth/<span class="number">2.0</span>, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(distance, <span class="number">30</span>) endPoint:<span class="built_in">CGPointMake</span>(distance+cornerW, <span class="number">30</span>+cornerW)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.xAxis];</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.yAxis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画坐标轴</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)lineWithStartPoint:(<span class="built_in">CGPoint</span>)startPoint breakPoint:(<span class="built_in">CGPoint</span>)breakPoint endPoint:(<span class="built_in">CGPoint</span>)endPoint &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *line = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    line.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    line.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">    line.lineWidth = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *linePath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [linePath moveToPoint:startPoint];</span><br><span class="line">    [linePath addLineToPoint:breakPoint];</span><br><span class="line">    [linePath addLineToPoint:endPoint];</span><br><span class="line">    line.path = linePath.CGPath;</span><br><span class="line">    </span><br><span class="line">    [line addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"xyLineStrokeEndAnimation"</span>];</span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)barScrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (_barScrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _barScrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(distance+lineWidth, <span class="number">30</span>, kDeviceWidth-distance*<span class="number">2</span>-lineWidth-cornerW, selfH<span class="number">-60</span>-lineWidth/<span class="number">2.0</span>)];</span><br><span class="line">        _barScrollView.bounces = <span class="literal">NO</span>;</span><br><span class="line">        _barScrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _barScrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CABasicAnimation</span> *)animation &#123;</span><br><span class="line">    <span class="keyword">if</span> (_animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</span><br><span class="line">        _animation.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        _animation.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        _animation.duration = <span class="number">2.0</span>;</span><br><span class="line">        _animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _animation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1276164-927e70f03aad6179.gif?imageMogr2/auto-orient/strip" alt="折线图"></p><p>柱状图是一条条单独的线段，折线图就是一条连起来的完整折线。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SJLineChart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> lineWidth  = <span class="number">1.0</span>;      <span class="comment">//坐标轴线宽</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> distance   = <span class="number">20.0</span>;     <span class="comment">//距屏幕边距</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> cornerW    = <span class="number">10.0</span>f;    <span class="comment">//拐角长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> space      = <span class="number">50.0</span>f;    <span class="comment">//柱状之间的间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> scale      = <span class="number">3.0</span>f;     <span class="comment">//直线显示高度计算比例 *scale</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> radius     = <span class="number">3.0</span>f;     <span class="comment">//标记每个点的小圆半径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJLineChart</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> selfW, selfH;</span><br><span class="line">    <span class="built_in">NSArray</span> *source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *xAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAShapeLayer</span> *yAxis;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *lineScrollView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CABasicAnimation</span> *animation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SJLineChart</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        selfW = frame.size.width;</span><br><span class="line">        selfH = frame.size.height;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showLineChart:(<span class="built_in">NSArray</span> *)sourceArray &#123;</span><br><span class="line">    source = sourceArray;</span><br><span class="line">    [<span class="keyword">self</span> addxyAxis];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.lineScrollView];</span><br><span class="line">    _lineScrollView.contentSize = <span class="built_in">CGSizeMake</span>(sourceArray.count*(space+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    [<span class="keyword">self</span> drawLineChart:sourceArray];</span><br><span class="line">    [<span class="keyword">self</span> drawPoint:sourceArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLineChart:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *lineLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    lineLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    lineLayer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    lineLayer.lineWidth = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">//轨迹</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(space, _lineScrollView.frame.size.height - <span class="number">60</span> - lineWidth/<span class="number">2.0</span> - ([[array objectAtIndex:<span class="number">0</span>] floatValue] * scale))];</span><br><span class="line">    </span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> y = _lineScrollView.frame.size.height<span class="number">-60</span> - lineWidth/<span class="number">2.0</span> - ([obj floatValue] * scale);</span><br><span class="line">            [path addLineToPoint:<span class="built_in">CGPointMake</span>(space*(idx+<span class="number">1</span>), y)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    lineLayer.path = path.CGPath;</span><br><span class="line">    [<span class="keyword">self</span>.lineScrollView.layer addSublayer:lineLayer];</span><br><span class="line">    [lineLayer addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"lineStrokeEndAnimation"</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把点标出来</span></span><br><span class="line">- (<span class="keyword">void</span>)drawPoint:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    </span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">CGFloat</span> y = _lineScrollView.frame.size.height - <span class="number">60</span> - lineWidth/<span class="number">2.0</span> - [obj floatValue]*scale;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIBezierPath</span> *circlePath = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(space * (idx+<span class="number">1</span>), y) radius:radius startAngle:<span class="number">0</span> endAngle:(M_PI)*<span class="number">2</span> clockwise:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *circleLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">        circleLayer.fillColor = [<span class="built_in">UIColor</span> orangeColor].CGColor;</span><br><span class="line">        circleLayer.strokeColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">        circleLayer.path = circlePath.CGPath;</span><br><span class="line">        </span><br><span class="line">        [_lineScrollView.layer addSublayer:circleLayer];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加坐标轴</span></span><br><span class="line">- (<span class="keyword">void</span>)addxyAxis &#123;</span><br><span class="line">    <span class="keyword">self</span>.xAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance, selfH<span class="number">-30</span>) endPoint:<span class="built_in">CGPointMake</span>(kDeviceWidth-distance-cornerW, selfH<span class="number">-30</span>-cornerW)];</span><br><span class="line">    <span class="keyword">self</span>.yAxis = [<span class="keyword">self</span> lineWithStartPoint:<span class="built_in">CGPointMake</span>(distance+lineWidth/<span class="number">2.0</span>, selfH<span class="number">-30</span>) breakPoint:<span class="built_in">CGPointMake</span>(distance, <span class="number">30</span>) endPoint:<span class="built_in">CGPointMake</span>(distance+cornerW, <span class="number">30</span>+cornerW)];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.xAxis];</span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.yAxis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画坐标轴</span></span><br><span class="line">- (<span class="built_in">CAShapeLayer</span> *)lineWithStartPoint:(<span class="built_in">CGPoint</span>)startPoint breakPoint:(<span class="built_in">CGPoint</span>)breakPoint endPoint:(<span class="built_in">CGPoint</span>)endPoint &#123;</span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *line = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    line.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">    line.strokeColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">    line.lineWidth = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *linePath = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    [linePath moveToPoint:startPoint];</span><br><span class="line">    [linePath addLineToPoint:breakPoint];</span><br><span class="line">    [linePath addLineToPoint:endPoint];</span><br><span class="line">    line.path = linePath.CGPath;</span><br><span class="line">    </span><br><span class="line">    [line addAnimation:<span class="keyword">self</span>.animation forKey:<span class="string">@"xyLineStrokeEndAnimation"</span>];</span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIScrollView</span> *)lineScrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (_lineScrollView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _lineScrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(distance+lineWidth, <span class="number">30</span>, kDeviceWidth-distance*<span class="number">2</span>-lineWidth, selfH<span class="number">-60</span>-lineWidth/<span class="number">2.0</span>)];</span><br><span class="line">        _lineScrollView.bounces = <span class="literal">NO</span>;</span><br><span class="line">        _lineScrollView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _lineScrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CABasicAnimation</span> *)animation &#123;</span><br><span class="line">    <span class="keyword">if</span> (_animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</span><br><span class="line">        _animation.fromValue = @<span class="number">0.0</span>;</span><br><span class="line">        _animation.toValue = @<span class="number">1.0</span>;</span><br><span class="line">        _animation.duration = <span class="number">2.0</span>;</span><br><span class="line">        _animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _animation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>感谢阅读全文的朋友。<br>☞demo地址 <a href="https://github.com/SPIREJ/SJCAShapeLayer" target="_blank" rel="noopener">https://github.com/SPIREJ/SJCAShapeLayer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660825.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本篇主要从以下几个方面来写的一点东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线段&lt;/li&gt;
&lt;li&gt;曲线&lt;/li&gt;
&lt;li&gt;动画&lt;/li&gt;
&lt;li&gt;简单的柱状图&lt;/li&gt;
&lt;li&gt;简单的折线图
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="图形" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>CAShapeLayer &amp; UIBezierPath &amp; CABasicAnimation总结</title>
    <link href="http://yoursite.com/2017/02/16/CAShapeLayer&amp;UIBezierPath&amp;CABasicAnimation%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/02/16/CAShapeLayer&amp;UIBezierPath&amp;CABasicAnimation总结/</id>
    <published>2017-02-16T10:22:05.000Z</published>
    <updated>2018-06-05T07:13:46.612Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660824.jpg" alt=""></p><ul><li><strong>CAShapeLayer</strong><ul><li>CAShapeLayer常用属性及可设置说明</li><li>CAShapeLayer特点</li></ul></li><li><strong>UIBezierPath</strong><ul><li>UIBezierPath几种初始化方式说明</li></ul></li><li><strong>CABasicAnimation</strong><ul><li>CABasicAnimation是什么？</li><li>CABasicAnimation设定动画的属性说明</li><li>CABasicAnimation常用的KeyPath值总结</li></ul></li></ul><a id="more"></a><h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><p>普通<code>CALayer</code>在被初始化时是需要给一个frame值的,这个frame值一般都与给定view的bounds值一致,它本身是有形状的,而且是矩形.<br>每个<code>CAShapeLayer</code>对象都代表着将要被渲染到屏幕上的形状(shape),CAShapeLayer在初始化时也需要给一个frame值,但是,它本身没有形状,它的形状来源于你给定的一个path,然后它去取<code>CGPath</code>值,它与CALayer有着很大的区别.</p><p>并且，系统仅会渲染CAShapeLayer对象的形状，其他任何非CAShapeLayer的自由属性在渲染是都会被忽略。因此从某种意义上讲CAShapeLayer仅是形状的容器。虽然由于其实CALayer的子类，可以设置<code>contents</code>、<code>backgroundColor</code>等属性，但这些属性在渲染时也会被忽略。</p><h4 id="但是，CAShapeLayer提供了自身的可设置性："><a href="#但是，CAShapeLayer提供了自身的可设置性：" class="headerlink" title="- 但是，CAShapeLayer提供了自身的可设置性："></a>- 但是，CAShapeLayer提供了自身的可设置性：</h4><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>path</td><td>fillColor</td><td>fillRule</td><td>strokeColor</td></tr><tr><td>strokeStart</td><td>strokeEnd</td><td>lineWidth</td><td>miterLimit</td></tr><tr><td>lineCap</td><td>lineJoin</td><td>lineDashPhase</td><td>lineDashPattern</td></tr></tbody></table><ul><li><p>path<br>  动画路径，默认为NULL，不支持隐式动画。路径可以使用任何的具体子类的动画CAPropertyAnimation。如果此属性的值是不为NULL，则path使用指定的路径，而不是创建该层的合成后的alpha通道。它使用的是非零缠绕规则和当前颜色，不透明度和模糊半径填充。 </p></li><li><p>fillColor<br>  填充颜色，默认为不透明的黑色，若值为nil，则没有填充效果。<br>fillColor针对于闭合的图形，对于镂空图形只需设置画笔颜色<code>strokeColor</code>即可。</p></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//闭合多边形</span><br><span class="line">- (void)drawTriangle &#123;</span><br><span class="line">    UIView *view = [<span class="keyword">self.view </span>viewWithTag:<span class="number">1026</span>]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *triangle = [CAShapeLayer layer]<span class="comment">;</span></span><br><span class="line">    triangle.lineWidth = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    triangle.<span class="keyword">strokeColor </span>= [UIColor clearColor].CGColor<span class="comment">;</span></span><br><span class="line">    triangle.fillColor = [UIColor redColor].CGColor<span class="comment">;</span></span><br><span class="line">    [view.layer <span class="keyword">addSublayer:triangle];</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    UIBezierPath *<span class="keyword">bezierPath </span>= [UIBezierPath <span class="keyword">bezierPath];</span></span><br><span class="line"><span class="keyword"> </span>   [<span class="keyword">bezierPath </span><span class="keyword">moveToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0-100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0+100, </span><span class="number">150</span>)]<span class="comment">;</span></span><br><span class="line">    [<span class="keyword">bezierPath </span><span class="keyword">addLineToPoint:CGPointMake(kDeviceWidth/2.0, </span><span class="number">50</span>)]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    triangle.path = <span class="keyword">bezierPath.CGPath;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1276164-cd35cad81961ab23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fillColor和strokeColor两种设置的效果"></p><ul><li><p>fillRule<br>  填充规则，默认是kCAFillRuleNonZero。<br>  kCAFillRuleNonZero：指定非零缠绕规则。计算每个左到右的路径+1或-1为每个从右到左的道路。如果所有交叉的总和为0，则点是路径之外，如果该和为非零，改点是在路径内与包含它的区域被填充。<br>  kCAFillRuleEvenOdd：指定奇偶缠绕规则。算路径交叉的总和，如果横跨的数目是偶数，改点在路径之外。如果横跨的数目是奇数，所述点是在路径内与包含它的区域应被填充。</p></li><li><p>strokeColor<br>  画笔颜色。</p></li><li><p>strokeStart<br>  和strokeEnd组合使用，默认值为1.0，取值范围0.0~1.0</p></li><li><p>strokeEnd<br>  和strokeStart组合使用，默认值为1.0，取值范围为0.0~1.0</p></li><li><p>lineWidth<br>  线宽。注意线宽有一个特点，线宽从你设置的起点往左右两边同时伸展。</p></li><li><p>miterLimit<br>  斜接样式，默认值为10.0</p></li><li><p>lineCap<br>  线端点样式，默认值为kCALineCapButt，还有kCALineCapRound，kCALineCapSquare<br><img src="http://upload-images.jianshu.io/upload_images/1276164-3950101908ae9c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线端点样式示例"></p></li><li><p>lineJoin<br>  拐角样式，默认值为kCALineJoinMiter（尖角），还有kCALineJoinRound（圆角），kCALineJoinBevel（平角）<br><img src="http://upload-images.jianshu.io/upload_images/1276164-ae5278976c113bef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拐角样式示例"></p></li><li><p>lineDashPhase<br>  冲刺阶段应用到的形状的路径，默认是0.0</p></li><li><p>lineDashPattern<br>设置线的样式，默认为实线，该数组为一个NSNumber数组，数组中的数值依次表示虚线中，单个线的长度，和空白的长度，如:数组@[@10,@5] 表示 有长度为10的线，长度为5的空白，不断循环后组成的虚线。<br>当然数组的长度是不做限制的，你亦可以@[@2,@3,@4,@5],可以表示为长度为2的线+长度为3的空白+长度为4的线+长度为5的空白，不断循环直到线段结束。</p></li><li><p>mask<br>  mask本身就是个CALayer，mask属性用作裁剪功能。<br>mask只作为形状（shape）的样子，裁剪后的形状以mask为准，其他例如颜色等属性以原图为准。<br><img src="http://upload-images.jianshu.io/upload_images/1276164-30817b1838eee1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种mask裁剪示例"></p></li></ul><h4 id="CAShapeLayer有以下几点特点："><a href="#CAShapeLayer有以下几点特点：" class="headerlink" title="- CAShapeLayer有以下几点特点："></a>- CAShapeLayer有以下几点特点：</h4><ul><li>它依附于一个<code>path</code>，必须给予path，即使path不完整也会自动首尾相接。</li><li><code>strokeStart</code>及<code>strokeEnd</code>代表着在这个path中所占用的百分比。</li><li>CAShapeLayer动画仅限于沿着边缘的动画效果，它不能直接实现填充效果，但可以间接实现填充效果。</li></ul><h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><p>使用<code>UIBezierPath</code>可以创建基于矢量的路径，此类是<code>Core Graphics</code>框架关于路径的封装。使用此类可以定义简单的形状，如椭圆、矩形或有多个直线和曲线组成的形状等。</p><p><code>UIBezierPath</code>是<code>CGPathRef</code>数据类型的封装。如果是基于矢量形状的路径，都用直线或曲线去创建。我们使用直线段去创建矩形和多边形，使用曲线去创建圆弧、圆或其他复杂的曲线形状。</p><ul><li>最基本的初始化方法，用它创建的对象，我们可以根据我们的需要任意定制样式，可以话任何想画的图形。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPath;</span><br></pre></td></tr></table></figure><ul><li>初始化一个矩形矩形贝塞尔曲线。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRect:(<span class="type">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><ul><li>根据一个矩形画内切曲线，通常用来画圆或椭圆（取决于传入的rect是正方形还是长方形）。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithOvalInRect:(<span class="type">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><ul><li>画矩形，但是这个矩形可以画圆角。第一个参数是矩形，第二个参数是圆角大小。</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRoundedRect:(<span class="type">CGRect</span>)rect cornerRadius:(<span class="type">CGFloat</span>)cornerRadius;</span><br></pre></td></tr></table></figure><ul><li>画矩形，矩形可以圆角，可以指定某个角或其中多个角成为圆角。参数：<code>UIRectCornerTopLeft</code>，<code>UIRectCornerTopRight</code>，<code>UIRectCornerBottomLeft</code>，<code>UIRectCornerBottomRight</code>，<code>UIRectCornerAllCorners</code></li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithRoundedRect:(<span class="type">CGRect</span>)rect byRoundingCorners:(<span class="type">UIRectCorner</span>)corners cornerRadii:(<span class="type">CGSize</span>)cornerRadii;</span><br></pre></td></tr></table></figure><ul><li>画弧线，参数说明：<ul><li>center 弧线中心点的坐标</li><li>radius 弧线所在圆的半径</li><li>startAngle 弧线开始的角度值</li><li>endAngle 弧线结束的角度值</li><li>clockwise 是否顺时针画弧线</li></ul></li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)bezierPathWithArcCenter:(<span class="type">CGPoint</span>)center radius:(<span class="type">CGFloat</span>)radius startAngle:(<span class="type">CGFloat</span>)startAngle endAngle:(<span class="type">CGFloat</span>)endAngle clockwise:(<span class="type">BOOL</span>)clockwise;</span><br></pre></td></tr></table></figure><h3 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h3><p><code>CABasicAnimation</code>类的使用方式就是关键帧动画，所谓关键帧动画，就是将Layer的属性作为<code>keyPath</code>来注册，指定动画的起始帧和结束帧，然后自动计算和实现中间的过渡动画的一种动画方式。</p><p>CABasicAnimation自己只有三个property:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> fromValue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> toValue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> byValue</span><br></pre></td></tr></table></figure><p>当创建一个<code>CABasicAnimation</code>的时候，需要通过 <code>-setFromValue</code>和 <code>-setToValue</code> 来指定一个开始值和结束值。当你增加基础动画到层中的时候，它开始运行。当用属性做动画完成时，例如用位置属性做动画，层就会立刻返回到它的初始位置。</p><h4 id="设定动画的属性说明"><a href="#设定动画的属性说明" class="headerlink" title="- 设定动画的属性说明"></a>- 设定动画的属性说明</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>duration</td><td>动画时长（单位：秒）</td></tr><tr><td>repeatCount</td><td>重复次数，永久重复的话设置为HUGE_VALF</td></tr><tr><td>beginTime</td><td>指定动画开始时间。从开始指定延迟几秒执行的话，请设置为「CACurrentMediaTime() + 秒数」的形式</td></tr><tr><td>timingFunction</td><td>设定动画的速度变化</td></tr><tr><td>autoreverses</td><td>动画结束时是否执行逆动画</td></tr><tr><td>shadowColor</td><td>阴影的颜色</td></tr><tr><td>shadowOffset</td><td>阴影的偏移量</td></tr><tr><td>shadowOpacity</td><td>阴影的透明度</td></tr><tr><td>shadowRadius</td><td>阴影的圆角</td></tr><tr><td>fromValue</td><td>所改变属性的起始值</td></tr><tr><td>toValue</td><td>所改变属性的结束时的值</td></tr><tr><td>byValue</td><td>所改变属性相同起始值得改变量</td><td>;</td></tr></tbody></table><h4 id="常用的animationWithKeyPath值的总结"><a href="#常用的animationWithKeyPath值的总结" class="headerlink" title="- 常用的animationWithKeyPath值的总结"></a>- 常用的animationWithKeyPath值的总结</h4><table><thead><tr><th>值</th><th>说明</th><th>使用形式</th></tr></thead><tbody><tr><td>transform.scale</td><td>比例转化</td><td>@(0.8)</td></tr><tr><td>transform.scale.x</td><td>宽的比例</td><td>@(0.8)</td></tr><tr><td>transform.scale.y</td><td>高的比例</td><td>@(0.8)</td></tr><tr><td>transform.rotation.x</td><td>围绕x轴旋转</td><td>@(M_PI)</td></tr><tr><td>transform.rotation.y</td><td>围绕y轴旋转</td><td>@(M_PI)</td></tr><tr><td>transform.rotation.z</td><td>围绕z轴旋转</td><td>@(M_PI)</td></tr><tr><td>cornerRadius</td><td>圆角的设置</td><td>@(20)</td></tr><tr><td>backgroundColor</td><td>背景颜色的变化</td><td>[UIColor orangeColor].CGColor;</td></tr><tr><td>bounds</td><td>大小，中心不变</td><td>[NSValue valueWithCGRect:CGRectMake(100,100)];</td></tr><tr><td>position</td><td>位置(中心点的改变)</td><td>[NSValue valueWithCGPoint:CGPointMake(100,100)];</td></tr><tr><td>contents</td><td>内容(比如UIImageView的图片)</td><td>imageAnima.toValue = (id)[UIImage imageNamed:@“toIcon”].CGImage;</td></tr><tr><td>opacity</td><td>透明度</td><td>@(0.8)</td></tr><tr><td>contentsRect.size.width</td><td>横向拉伸缩放</td><td>@(0.5)最好在0~1之间</td></tr></tbody></table><h5 id="捕获动画开始时和终了时的事件"><a href="#捕获动画开始时和终了时的事件" class="headerlink" title="- 捕获动画开始时和终了时的事件"></a>- 捕获动画开始时和终了时的事件</h5><p>设置委托对象，实现委托方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 动画开始时 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animationDidStart</span><span class="selector-pseudo">:(CAAnimation</span> *)<span class="selector-tag">theAnimation</span> &#123;</span><br><span class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"begin"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 动画结束时 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">animationDidStop</span><span class="selector-pseudo">:(CAAnimation</span> *)<span class="selector-tag">theAnimation</span> <span class="selector-tag">finished</span><span class="selector-pseudo">:(BOOL)flag</span> &#123;  </span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"end"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><code>CAShapeLayer</code>和<code>UIBezierPath</code>规定一个形状，<code>CABasicAnimation</code>为其添加动画。下一篇我将写具体的实例。最后，非常感谢您阅读全文。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=347128&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660824.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CAShapeLayer&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;CAShapeLayer常用属性及可设置说明&lt;/li&gt;
&lt;li&gt;CAShapeLayer特点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UIBezierPath&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;UIBezierPath几种初始化方式说明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CABasicAnimation&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;CABasicAnimation是什么？&lt;/li&gt;
&lt;li&gt;CABasicAnimation设定动画的属性说明&lt;/li&gt;
&lt;li&gt;CABasicAnimation常用的KeyPath值总结&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS技术开发" scheme="http://yoursite.com/categories/iOS%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>一个程序员的12个新年愿望</title>
    <link href="http://yoursite.com/2017/02/05/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8412%E4%B8%AA%E6%96%B0%E5%B9%B4%E6%84%BF%E6%9C%9B/"/>
    <id>http://yoursite.com/2017/02/05/一个程序员的12个新年愿望/</id>
    <published>2017-02-04T16:00:00.000Z</published>
    <updated>2018-06-05T06:25:20.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660845.jpg" alt=""></p><a id="more"></a><p>2017年的工作从今天正式开始了(从春节后算)，在新的一年，总结了12个新年心愿。</p><blockquote><ul><li>保持健康</li><li>学习一门新的编程语言</li><li>坚持写博客</li><li>注意安全</li><li>戒烟</li><li>早睡早起</li><li>出去走走</li><li>追求喜欢的人</li><li>健身</li><li>有自己的窝</li><li>保持联系</li><li>完成一个个人项目</li></ul></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31445772&auto=1&height=66"></iframe><ul><li><code>保持健康</code></li></ul><p>保持健康，不管是现在还是将来。<br>每天都久坐在座位上，又不爱锻炼的程序员，带来了健康的严峻挑战。<br>当我还在二十一二岁的时候，那时的我当然没察觉到健康到底对我有多重要，能跑能跳能熬夜能饿肚子能吃很多；当我快要三十岁了得时候，我终于意识到健康对我来说有多重要，不能跑不能跳不能熬夜不能饿肚子只能吃很少，以前认为的那种旺盛精力是不可能一直存在的，生活的方方面面都潜存着压力，身体的机能也一直在慢慢下降，你以为自己还好的很，但是身体是最不会撒谎的，如果不爱惜，它会准时的提醒你。<br>譬如现在一年总会感冒二到三次，而且必经三阶段：嗓子疼—&gt;流鼻涕—&gt;头疼，总是持续很长时间，吃药才能好，以前那个感冒了睡一觉出身汗就屁事儿没有的我已经不复存在了%&gt;_&lt;%。<br>现在，腰、颈、背 都是问题，纠正坐姿，站立结合，越快越好~<br>现在，不管是作息、饮食、心情、身体 都保持健康QAQ。</p><ul><li><code>学习一门新的编程语言</code></li></ul><p>保持学习是对自己不被淘汰的最大负责。<br>不管是主流的，还是非主流的，只要坚持学习，就一定是自己的收获~</p><ul><li><code>坚持写博客</code></li></ul><p>写博客已经是一个爱好了，有时候就是觉得自己写的不够好才不敢放出来，看了大神的写作确实会受到打击，但谁不是从新手过来的呢。<br>只要做好自己，应该就是最好的了吧~<br>工作，生活，学习，感想 都想统统的记下来~<br>积累下来，也不失为一笔财富~<br>也许多年之后，再回首，也感慨，不度虚年~</p><ul><li><code>注意安全</code></li></ul><p>注意安全，其实包括着方方面面。比如说每天出门的时候记得锁门，记得带钥匙。过马路的时候注意车辆，出去玩的时候注意保护自己，骑行的时候注意安全，</p><ul><li><code>戒烟</code></li></ul><p>啥也不说了，抽完这包不抽了…<br><img src="http://upload-images.jianshu.io/upload_images/1276164-d857e649f08f2dff.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这是最后一包烟"></p><ul><li><code>早睡早起</code></li></ul><p>早睡早起可能是最容易做到也可能是最难做到的了，舍不得早晨温暖的被窝，舍不得浪费夜晚大把的时光~</p><ul><li><code>出去走走</code></li></ul><p>河山大好，出去走走，别窝在家当懒虫，碧海蓝天吹吹风~<br>弹指一挥人生苦短，好地方一生都看不完。</p><ul><li><code>追求喜欢的人</code></li></ul><p>略。</p><ul><li><code>健身</code></li></ul><p>不让自己的身体提前进入老年化，要健康也要好身材QAQ</p><ul><li><code>有自己的窝</code></li></ul><p>这可能是一件最令我幸福也是最有压力的一件事了…</p><ul><li><code>保持联系</code></li></ul><p>和亲近的人保持联系，和不亲近的人随风而去~</p><ul><li><code>完成一个个人项目</code></li></ul><p>抽时间选一个有趣的项目慢慢完成它，不用赶进度，尽量完美，再好不过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9u62mso1.bkt.clouddn.com/coverwallhaven-660845.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="诗意生活" scheme="http://yoursite.com/categories/%E8%AF%97%E6%84%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="flag" scheme="http://yoursite.com/tags/flag/"/>
    
  </entry>
  
  <entry>
    <title>纪念狗正八</title>
    <link href="http://yoursite.com/2017/01/28/%E7%BA%AA%E5%BF%B5%E7%8B%97%E6%AD%A3%E5%85%AB/"/>
    <id>http://yoursite.com/2017/01/28/纪念狗正八/</id>
    <published>2017-01-28T14:02:13.000Z</published>
    <updated>2018-05-20T04:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在青春中，爱情只是其中的一部分，甚至在青春的爱情里，闪光的不是结局，而是那青涩懵懂的过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/1276164-bc83b67a349af60f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请回答1988"></p><a id="more"></a><p>狗正八，一张苦瓜脸，首尔大学补刀专业毕业，性情冷漠。</p><p>但是狗正八，真的很man，因为他是狗正八，是珍惜所有人的狗正八。为了爸爸开心可以做不喜欢的（goldstar）见面礼，为了妈妈开心可以做听话的“二女儿”，为了哥哥去飞行学院；为了朋友伸出拳头，为了维系伙伴关系不跨越界限一直逃避，在这个青春懵懂的年纪，已经是如此成熟的狗正八！</p><p>很可惜，狗正八和德善永远是一个人进，一个人退，他们从未相向而行。正如他经过的时候，她低下了头，错过了一秒就错过了一生。</p><p>可能在狗正八的世界里，暗恋，已经是对自己的圆满了，我爱你，与你无关。</p><p>正如我一直相信他能和德善走在一起一样，直到最后的错过，雨中的独白，错过的时机，自我剖析的悔恨，狗正八的爱情在独白中已经交代，他已经完全退出了，而后餐厅借戒指的表白，可能是对自己青春的一种交代，一种释怀，对自己暗恋画上一个句号。然后还是开心的叫着特工队、喜东东、崔大师。</p><p>狗正八的爱情无疑是青涩的，他一直爱着那个叫德善的女孩，爱情和喷嚏是藏不住的，而他却把全部的力气用作隐藏。</p><p>一遍遍的拆解鞋带，直到那个女孩出现在假装不耐烦的离开~<br>若无其事的路过吐槽，而后带着憨厚的傻笑躲在窗口偷看~<br>在那个女孩每次看过来的时候收回凝视的目光~<br>当着小伙伴的面用力划开和女孩的界限~<br>夜晚的时候担心女孩有没有按时回家~<br>违背自己的心意说一些不好听得话~<br>收到粉红色衬衫开心的不得了~<br>下雨的时候撑伞等待~<br>精心准备圣诞礼物~<br>…<br><img src="http://upload-images.jianshu.io/upload_images/1276164-f6aa02bc8dd38beb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QAQ"></p><p>他的爱情无疑是纯真的，他的爱情缺无疑是稚嫩的。<br>然而，爱情从来不是逃避和躲藏后，期待对方的蓦然回首。<br>爱情需要努力的一步步靠近，而终相濡以沫。<br>爱情是世界上最脆弱的东西，它需要不断的呵护。更重要的是，它不是单方面的付出，而是两个人的靠近。</p><p>狗正八的独白：缘分就像是机遇，是他的犹豫摧毁了他的缘分。<br>是的，如果，他能少一点逃避，在德善被善宇伤害之前能够有勇气听善宇解释他的爱情，如果他能够在得知崔大师的心意后，有勇气正视德善，而不是用力逃开，那么最后那个红绿灯，根本不是上天的戏弄。</p><p>甚至，在最最开始的时候，当一切还没开始，他能坦率的告诉所有人，他喜欢德善，那么接下来的故事应该也很有趣。</p><p>可惜，他是狗正八，是珍惜所有人的狗正八，是贴心的“二女儿”，他想得太多，他也想得太少，他只是一个18岁的少年，只是一个普通的青春期的孩子，他没有做出该有的选择。<br>他的爱情，也许在他没解释粉红色衬衫的那一天就已经死了。<br>可是他却是如此的真实，我们是否也拥有一段无疾而终的暗恋，在那个蠢动的青春时代，在那个最初对异性有过萌动的青春，是否也偷偷爱着那么一个人，不敢告诉任何人，甚至是你最好的朋友。</p><p>你小心的爱着，全心全意的爱着，又用尽全身的力气去掩饰，知道你们各奔东西，知道你们再无缘分，于是某一天你们再次相遇，所有的萌动和情愫都已经远去，但是内心深处正如狗正八一样的低俗：如果当初我能够勇敢一点，如果没有选择逃避，如果不介意别人的眼光，如果没有那么多犹豫爱你所爱……可是没有如果，失去了所有如果，也没有任何可能。<br>甚至，连一次开玩笑的告白，都显得多余。</p><p>关于德善，其实正如她当时告诉阿爸的没有想做的事情一样，虽然看起来他喜欢过善宇，喜欢过狗正八，也喜欢崔大师，但是我只能认为她那是在情窦初开的时候对爱情的渴望，不像狗正八爱她那般，那么真切。</p><p>一句，不要去联谊<br>一句，你想想我为什么会来找你<br>一句，我会去（看电影）</p><p><img src="http://upload-images.jianshu.io/upload_images/1276164-db2e071831bf1f5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QwQ"></p><p>虽然结局也是很好的，但为什么我会如此的心疼狗正八。</p><p>人类是很肤浅的动物，青春充满了自卑和遐想(不仅仅是青春)，现实没有观众，你不能指望你所爱的人从你别扭的言语背后读懂你的内心。</p><p>不要以爱的名义去伤害爱你的人，不要以外爱情不会离开，不要用自己的爱感动了自己却无人所知。</p><p>现实中没有崔大师，没有这么完美的解决所有冲突的人物，故事的结局只会是多年以后，德善找到一个爱人，无意中发现青春时曾有人深深爱着自己，也是自己蠢萌有心意的对方，但是如今摊手耸肩。而狗正八呢，以为放弃了，保住自己珍惜的所有人，当再次见到初恋时，却物是人非。</p><p>如果你现在还在经历着同样的暗恋，还在别扭的掩饰，那么请不要。</p><p>错过的，终究会错过。<br>人类是脆弱的，时间和距离会腐烂所有的爱情，无一幸免。时间和距离也会治愈所有的伤痛，无一例外。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=400876423&auto=1&height=66"></iframe><p>SPIREJ<br>2017.01.28</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在青春中，爱情只是其中的一部分，甚至在青春的爱情里，闪光的不是结局，而是那青涩懵懂的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1276164-bc83b67a349af60f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;请回答1988&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="诗意生活" scheme="http://yoursite.com/categories/%E8%AF%97%E6%84%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="观影" scheme="http://yoursite.com/tags/%E8%A7%82%E5%BD%B1/"/>
    
      <category term="忆青春" scheme="http://yoursite.com/tags/%E5%BF%86%E9%9D%92%E6%98%A5/"/>
    
  </entry>
  
</feed>
